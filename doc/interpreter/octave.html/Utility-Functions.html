<html lang="en">
<head>
<title>Utility Functions - GNU Octave</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Octave">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Arithmetic.html#Arithmetic" title="Arithmetic">
<link rel="prev" href="Sums-and-Products.html#Sums-and-Products" title="Sums and Products">
<link rel="next" href="Special-Functions.html#Special-Functions" title="Special Functions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Utility-Functions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Special-Functions.html#Special-Functions">Special Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Sums-and-Products.html#Sums-and-Products">Sums and Products</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Arithmetic.html#Arithmetic">Arithmetic</a>
<hr>
</div>

<h3 class="section">17.5 Utility Functions</h3>

<!-- ceil libinterp/corefcn/mappers.cc -->
<p><a name="XREFceil"></a>

<div class="defun">
&mdash; Mapping Function:  <b>ceil</b> (<var>x</var>)<var><a name="index-ceil-2196"></a></var><br>
<blockquote><p>Return the smallest integer not less than <var>x</var>.  This is equivalent to
rounding towards positive infinity.  If <var>x</var> is
complex, return <code>ceil (real (</code><var>x</var><code>)) + ceil (imag (</code><var>x</var><code>)) * I</code>.

     <pre class="example">          ceil ([-2.7, 2.7])
              &rArr; -2    3
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFfloor.html#XREFfloor">floor</a>, <a href="XREFround.html#XREFround">round</a>, <a href="XREFfix.html#XREFfix">fix</a>.

        </blockquote></div>

<!-- fix libinterp/corefcn/mappers.cc -->
   <p><a name="XREFfix"></a>

<div class="defun">
&mdash; Mapping Function:  <b>fix</b> (<var>x</var>)<var><a name="index-fix-2197"></a></var><br>
<blockquote><p>Truncate fractional portion of <var>x</var> and return the integer portion.  This
is equivalent to rounding towards zero.  If <var>x</var> is complex, return
<code>fix (real (</code><var>x</var><code>)) + fix (imag (</code><var>x</var><code>)) * I</code>.

     <pre class="example">          fix ([-2.7, 2.7])
             &rArr; -2    2
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFceil.html#XREFceil">ceil</a>, <a href="XREFfloor.html#XREFfloor">floor</a>, <a href="XREFround.html#XREFround">round</a>.

        </blockquote></div>

<!-- floor libinterp/corefcn/mappers.cc -->
   <p><a name="XREFfloor"></a>

<div class="defun">
&mdash; Mapping Function:  <b>floor</b> (<var>x</var>)<var><a name="index-floor-2198"></a></var><br>
<blockquote><p>Return the largest integer not greater than <var>x</var>.  This is equivalent to
rounding towards negative infinity.  If <var>x</var> is
complex, return <code>floor (real (</code><var>x</var><code>)) + floor (imag (</code><var>x</var><code>)) * I</code>.

     <pre class="example">          floor ([-2.7, 2.7])
               &rArr; -3    2
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFceil.html#XREFceil">ceil</a>, <a href="XREFround.html#XREFround">round</a>, <a href="XREFfix.html#XREFfix">fix</a>.

        </blockquote></div>

<!-- round libinterp/corefcn/mappers.cc -->
   <p><a name="XREFround"></a>

<div class="defun">
&mdash; Mapping Function:  <b>round</b> (<var>x</var>)<var><a name="index-round-2199"></a></var><br>
<blockquote><p>Return the integer nearest to <var>x</var>.  If <var>x</var> is complex, return
<code>round (real (</code><var>x</var><code>)) + round (imag (</code><var>x</var><code>)) * I</code>.  If there
are two nearest integers, return the one further away from zero.

     <pre class="example">          round ([-2.7, 2.7])
               &rArr; -3    3
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFceil.html#XREFceil">ceil</a>, <a href="XREFfloor.html#XREFfloor">floor</a>, <a href="XREFfix.html#XREFfix">fix</a>, <a href="XREFroundb.html#XREFroundb">roundb</a>.

        </blockquote></div>

<!-- roundb libinterp/corefcn/mappers.cc -->
   <p><a name="XREFroundb"></a>

<div class="defun">
&mdash; Mapping Function:  <b>roundb</b> (<var>x</var>)<var><a name="index-roundb-2200"></a></var><br>
<blockquote><p>Return the integer nearest to <var>x</var>.  If there are two nearest
integers, return the even one (banker's rounding).  If <var>x</var> is complex,
return <code>roundb (real (</code><var>x</var><code>)) + roundb (imag (</code><var>x</var><code>)) * I</code>.

     <p class="noindent"><strong>See also:</strong> <a href="XREFround.html#XREFround">round</a>.

        </blockquote></div>

<!-- max libinterp/corefcn/max.cc -->
   <p><a name="XREFmax"></a>

<div class="defun">
&mdash; Built-in Function:  <b>max</b> (<var>x</var>)<var><a name="index-max-2201"></a></var><br>
&mdash; Built-in Function:  <b>max</b> (<var>x, y</var>)<var><a name="index-max-2202"></a></var><br>
&mdash; Built-in Function:  <b>max</b> (<var>x, </var>[]<var>, dim</var>)<var><a name="index-max-2203"></a></var><br>
&mdash; Built-in Function:  <b>max</b> (<var>x, y, dim</var>)<var><a name="index-max-2204"></a></var><br>
&mdash; Built-in Function: [<var>w</var>, <var>iw</var>] = <b>max</b> (<var>x</var>)<var><a name="index-max-2205"></a></var><br>
<blockquote><p>For a vector argument, return the maximum value.  For a matrix
argument, return the maximum value from each column, as a row
vector, or over the dimension <var>dim</var> if defined, in which case <var>y</var>
should be set to the empty matrix (it's ignored otherwise).  For two matrices
(or a matrix and scalar), return the pair-wise maximum. 
Thus,

     <pre class="example">          max (max (<var>x</var>))
</pre>
        <p class="noindent">returns the largest element of the matrix <var>x</var>, and

     <pre class="example">          max (2:5, pi)
              &rArr;  3.1416  3.1416  4.0000  5.0000
</pre>
        <p class="noindent">compares each element of the range <code>2:5</code> with <code>pi</code>, and
returns a row vector of the maximum values.

        <p>For complex arguments, the magnitude of the elements are used for
comparison.

        <p>If called with one input and two output arguments,
<code>max</code> also returns the first index of the
maximum value(s).  Thus,

     <pre class="example">          [x, ix] = max ([1, 3, 5, 2, 5])
              &rArr;  x = 5
                  ix = 3
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFmin.html#XREFmin">min</a>, <a href="XREFcummax.html#XREFcummax">cummax</a>, <a href="XREFcummin.html#XREFcummin">cummin</a>.

        </blockquote></div>

<!-- min libinterp/corefcn/max.cc -->
   <p><a name="XREFmin"></a>

<div class="defun">
&mdash; Built-in Function:  <b>min</b> (<var>x</var>)<var><a name="index-min-2206"></a></var><br>
&mdash; Built-in Function:  <b>min</b> (<var>x, y</var>)<var><a name="index-min-2207"></a></var><br>
&mdash; Built-in Function:  <b>min</b> (<var>x, </var>[]<var>, dim</var>)<var><a name="index-min-2208"></a></var><br>
&mdash; Built-in Function:  <b>min</b> (<var>x, y, dim</var>)<var><a name="index-min-2209"></a></var><br>
&mdash; Built-in Function: [<var>w</var>, <var>iw</var>] = <b>min</b> (<var>x</var>)<var><a name="index-min-2210"></a></var><br>
<blockquote><p>For a vector argument, return the minimum value.  For a matrix
argument, return the minimum value from each column, as a row
vector, or over the dimension <var>dim</var> if defined, in which case <var>y</var>
should be set to the empty matrix (it's ignored otherwise).  For two matrices
(or a matrix and scalar), return the pair-wise minimum. 
Thus,

     <pre class="example">          min (min (<var>x</var>))
</pre>
        <p class="noindent">returns the smallest element of <var>x</var>, and

     <pre class="example">          min (2:5, pi)
              &rArr;  2.0000  3.0000  3.1416  3.1416
</pre>
        <p class="noindent">compares each element of the range <code>2:5</code> with <code>pi</code>, and
returns a row vector of the minimum values.

        <p>For complex arguments, the magnitude of the elements are used for
comparison.

        <p>If called with one input and two output arguments,
<code>min</code> also returns the first index of the
minimum value(s).  Thus,

     <pre class="example">          [x, ix] = min ([1, 3, 0, 2, 0])
              &rArr;  x = 0
                  ix = 3
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFmax.html#XREFmax">max</a>, <a href="XREFcummin.html#XREFcummin">cummin</a>, <a href="XREFcummax.html#XREFcummax">cummax</a>.

        </blockquote></div>

<!-- cummax libinterp/corefcn/max.cc -->
   <p><a name="XREFcummax"></a>

<div class="defun">
&mdash; Built-in Function:  <b>cummax</b> (<var>x</var>)<var><a name="index-cummax-2211"></a></var><br>
&mdash; Built-in Function:  <b>cummax</b> (<var>x, dim</var>)<var><a name="index-cummax-2212"></a></var><br>
&mdash; Built-in Function: [<var>w</var>, <var>iw</var>] = <b>cummax</b> (<var>x</var>)<var><a name="index-cummax-2213"></a></var><br>
<blockquote><p>Return the cumulative maximum values along dimension <var>dim</var>.  If <var>dim</var>
is unspecified it defaults to column-wise operation.  For example:

     <pre class="example">          cummax ([1 3 2 6 4 5])
             &rArr;  1  3  3  6  6  6
</pre>
        <p>The call

     <pre class="example">          [w, iw] = cummax (x, dim)
</pre>
        <p class="noindent">with <code>x</code> a vector, is equivalent to the following code:

     <pre class="example">          w = iw = zeros (size (x));
          for i = 1:length (x)
            [w(i), iw(i)] = max (x(1:i));
          endfor
</pre>
        <p class="noindent">but computed in a much faster manner.

     <p class="noindent"><strong>See also:</strong> <a href="XREFcummin.html#XREFcummin">cummin</a>, <a href="XREFmax.html#XREFmax">max</a>, <a href="XREFmin.html#XREFmin">min</a>.

        </blockquote></div>

<!-- cummin libinterp/corefcn/max.cc -->
   <p><a name="XREFcummin"></a>

<div class="defun">
&mdash; Built-in Function:  <b>cummin</b> (<var>x</var>)<var><a name="index-cummin-2214"></a></var><br>
&mdash; Built-in Function:  <b>cummin</b> (<var>x, dim</var>)<var><a name="index-cummin-2215"></a></var><br>
&mdash; Built-in Function: [<var>w</var>, <var>iw</var>] = <b>cummin</b> (<var>x</var>)<var><a name="index-cummin-2216"></a></var><br>
<blockquote><p>Return the cumulative minimum values along dimension <var>dim</var>.  If <var>dim</var>
is unspecified it defaults to column-wise operation.  For example:

     <pre class="example">          cummin ([5 4 6 2 3 1])
             &rArr;  5  4  4  2  2  1
</pre>
        <p>The call

     <pre class="example">            [w, iw] = cummin (x)
</pre>
        <p class="noindent">with <code>x</code> a vector, is equivalent to the following code:

     <pre class="example">          w = iw = zeros (size (x));
          for i = 1:length (x)
            [w(i), iw(i)] = max (x(1:i));
          endfor
</pre>
        <p class="noindent">but computed in a much faster manner.

     <p class="noindent"><strong>See also:</strong> <a href="XREFcummax.html#XREFcummax">cummax</a>, <a href="XREFmin.html#XREFmin">min</a>, <a href="XREFmax.html#XREFmax">max</a>.

        </blockquote></div>

<!-- hypot libinterp/corefcn/data.cc -->
   <p><a name="XREFhypot"></a>

<div class="defun">
&mdash; Built-in Function:  <b>hypot</b> (<var>x, y</var>)<var><a name="index-hypot-2217"></a></var><br>
&mdash; Built-in Function:  <b>hypot</b> (<var>x, y, z, <small class="dots">...</small></var>)<var><a name="index-hypot-2218"></a></var><br>
<blockquote><p>Compute the element-by-element square root of the sum of the squares of
<var>x</var> and <var>y</var>.  This is equivalent to
<code>sqrt (</code><var>x</var><code>.^2 + </code><var>y</var><code>.^2)</code>, but calculated in a manner that
avoids overflows for large values of <var>x</var> or <var>y</var>. 
<code>hypot</code> can also be called with more than 2 arguments; in this case,
the arguments are accumulated from left to right:

     <pre class="example">          hypot (hypot (<var>x</var>, <var>y</var>), <var>z</var>)
          hypot (hypot (hypot (<var>x</var>, <var>y</var>), <var>z</var>), <var>w</var>), etc.
</pre>
        </blockquote></div>

<!-- gradient scripts/general/gradient.m -->
   <p><a name="XREFgradient"></a>

<div class="defun">
&mdash; Function File: <var>dx</var> = <b>gradient</b> (<var>m</var>)<var><a name="index-gradient-2219"></a></var><br>
&mdash; Function File: [<var>dx</var>, <var>dy</var>, <var>dz</var>, <small class="dots">...</small>] = <b>gradient</b> (<var>m</var>)<var><a name="index-gradient-2220"></a></var><br>
&mdash; Function File: [<small class="dots">...</small>] = <b>gradient</b> (<var>m, s</var>)<var><a name="index-gradient-2221"></a></var><br>
&mdash; Function File: [<small class="dots">...</small>] = <b>gradient</b> (<var>m, x, y, z, <small class="dots">...</small></var>)<var><a name="index-gradient-2222"></a></var><br>
&mdash; Function File: [<small class="dots">...</small>] = <b>gradient</b> (<var>f, x0</var>)<var><a name="index-gradient-2223"></a></var><br>
&mdash; Function File: [<small class="dots">...</small>] = <b>gradient</b> (<var>f, x0, s</var>)<var><a name="index-gradient-2224"></a></var><br>
&mdash; Function File: [<small class="dots">...</small>] = <b>gradient</b> (<var>f, x0, x, y, <small class="dots">...</small></var>)<var><a name="index-gradient-2225"></a></var><br>
<blockquote>
        <p>Calculate the gradient of sampled data or a function.  If <var>m</var>
is a vector, calculate the one-dimensional gradient of <var>m</var>.  If
<var>m</var> is a matrix the gradient is calculated for each dimension.

        <p><code>[</code><var>dx</var><code>, </code><var>dy</var><code>] = gradient (</code><var>m</var><code>)</code> calculates the one
dimensional gradient for <var>x</var> and <var>y</var> direction if <var>m</var> is a
matrix.  Additional return arguments can be use for multi-dimensional
matrices.

        <p>A constant spacing between two points can be provided by the
<var>s</var> parameter.  If <var>s</var> is a scalar, it is assumed to be the spacing
for all dimensions. 
Otherwise, separate values of the spacing can be supplied by
the <var>x</var>, <small class="dots">...</small> arguments.  Scalar values specify an equidistant
spacing. 
Vector values for the <var>x</var>, <small class="dots">...</small> arguments specify the coordinate for
that
dimension.  The length must match their respective dimension of <var>m</var>.

        <p>At boundary points a linear extrapolation is applied.  Interior points
are calculated with the first approximation of the numerical gradient

     <pre class="example">          y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).
</pre>
        <p>If the first argument <var>f</var> is a function handle, the gradient of the
function at the points in <var>x0</var> is approximated using central
difference.  For example, <code>gradient (@cos, 0)</code> approximates the
gradient of the cosine function in the point x0 = 0.  As with
sampled data, the spacing values between the points from which the
gradient is estimated can be set via the <var>s</var> or <var>dx</var>,
<var>dy</var>, <small class="dots">...</small> arguments.  By default a spacing of 1 is used.

     <p class="noindent"><strong>See also:</strong> <a href="XREFdiff.html#XREFdiff">diff</a>, <a href="XREFdel2.html#XREFdel2">del2</a>.

        </blockquote></div>

<!-- dot libinterp/corefcn/dot.cc -->
   <p><a name="XREFdot"></a>

<div class="defun">
&mdash; Built-in Function:  <b>dot</b> (<var>x, y, dim</var>)<var><a name="index-dot-2226"></a></var><br>
<blockquote><p>Compute the dot product of two vectors.  If <var>x</var> and <var>y</var>
are matrices, calculate the dot products along the first
non-singleton dimension.  If the optional argument <var>dim</var> is
given, calculate the dot products along this dimension.

        <p>This is equivalent to
<code>sum (conj (</code><var>X</var><code>) .* </code><var>Y</var><code>, </code><var>dim</var><code>)</code>,
but avoids forming a temporary array and is faster.  When <var>X</var> and
<var>Y</var> are column vectors, the result is equivalent to
<var>X</var><code>' * </code><var>Y</var>.

     <p class="noindent"><strong>See also:</strong> <a href="XREFcross.html#XREFcross">cross</a>, <a href="XREFdivergence.html#XREFdivergence">divergence</a>.

        </blockquote></div>

<!-- cross scripts/linear-algebra/cross.m -->
   <p><a name="XREFcross"></a>

<div class="defun">
&mdash; Function File:  <b>cross</b> (<var>x, y</var>)<var><a name="index-cross-2227"></a></var><br>
&mdash; Function File:  <b>cross</b> (<var>x, y, dim</var>)<var><a name="index-cross-2228"></a></var><br>
<blockquote><p>Compute the vector cross product of two 3-dimensional vectors
<var>x</var> and <var>y</var>.

     <pre class="example">          cross ([1,1,0], [0,1,1])
               &rArr; [ 1; -1; 1 ]
</pre>
        <p>If <var>x</var> and <var>y</var> are matrices, the cross product is applied
along the first dimension with 3 elements.  The optional argument
<var>dim</var> forces the cross product to be calculated along
the specified dimension.

     <p class="noindent"><strong>See also:</strong> <a href="XREFdot.html#XREFdot">dot</a>, <a href="XREFcurl.html#XREFcurl">curl</a>, <a href="XREFdivergence.html#XREFdivergence">divergence</a>.

        </blockquote></div>

<!-- divergence scripts/general/divergence.m -->
   <p><a name="XREFdivergence"></a>

<div class="defun">
&mdash; Function File: <var>div</var> = <b>divergence</b> (<var>x, y, z, fx, fy, fz</var>)<var><a name="index-divergence-2229"></a></var><br>
&mdash; Function File: <var>div</var> = <b>divergence</b> (<var>fx, fy, fz</var>)<var><a name="index-divergence-2230"></a></var><br>
&mdash; Function File: <var>div</var> = <b>divergence</b> (<var>x, y, fx, fy</var>)<var><a name="index-divergence-2231"></a></var><br>
&mdash; Function File: <var>div</var> = <b>divergence</b> (<var>fx, fy</var>)<var><a name="index-divergence-2232"></a></var><br>
<blockquote><p>Calculate divergence of a vector field given by the arrays <var>fx</var>,
<var>fy</var>, and <var>fz</var> or <var>fx</var>, <var>fy</var> respectively.

     <pre class="example">                            d               d               d
          div F(x,y,z)  =   -- F(x,y,z)  +  -- F(x,y,z)  +  -- F(x,y,z)
                            dx              dy              dz
</pre>
        <p>The coordinates of the vector field can be given by the arguments <var>x</var>,
<var>y</var>, <var>z</var> or <var>x</var>, <var>y</var> respectively.

     <p class="noindent"><strong>See also:</strong> <a href="XREFcurl.html#XREFcurl">curl</a>, <a href="XREFgradient.html#XREFgradient">gradient</a>, <a href="XREFdel2.html#XREFdel2">del2</a>, <a href="XREFdot.html#XREFdot">dot</a>.

        </blockquote></div>

<!-- curl scripts/general/curl.m -->
   <p><a name="XREFcurl"></a>

<div class="defun">
&mdash; Function File: [<var>cx</var>, <var>cy</var>, <var>cz</var>, <var>v</var>] = <b>curl</b> (<var>x, y, z, fx, fy, fz</var>)<var><a name="index-curl-2233"></a></var><br>
&mdash; Function File: [<var>cz</var>, <var>v</var>] = <b>curl</b> (<var>x, y, fx, fy</var>)<var><a name="index-curl-2234"></a></var><br>
&mdash; Function File: [<small class="dots">...</small>] = <b>curl</b> (<var>fx, fy, fz</var>)<var><a name="index-curl-2235"></a></var><br>
&mdash; Function File: [<small class="dots">...</small>] = <b>curl</b> (<var>fx, fy</var>)<var><a name="index-curl-2236"></a></var><br>
&mdash; Function File: <var>v</var> = <b>curl</b> (<var><small class="dots">...</small></var>)<var><a name="index-curl-2237"></a></var><br>
<blockquote><p>Calculate curl of vector field given by the arrays <var>fx</var>, <var>fy</var>, and
<var>fz</var> or <var>fx</var>, <var>fy</var> respectively.

     <pre class="example">                            / d         d       d         d       d         d     \
          curl F(x,y,z)  =  | -- Fz  -  -- Fy,  -- Fx  -  -- Fz,  -- Fy  -  -- Fx |
                            \ dy        dz      dz        dx      dx        dy    /
</pre>
        <p>The coordinates of the vector field can be given by the arguments <var>x</var>,
<var>y</var>, <var>z</var> or <var>x</var>, <var>y</var> respectively.  <var>v</var> calculates the
scalar component of the angular velocity vector in direction of the z-axis
for two-dimensional input.  For three-dimensional input the scalar
rotation is calculated at each grid point in direction of the vector field
at that point.

     <p class="noindent"><strong>See also:</strong> <a href="XREFdivergence.html#XREFdivergence">divergence</a>, <a href="XREFgradient.html#XREFgradient">gradient</a>, <a href="XREFdel2.html#XREFdel2">del2</a>, <a href="XREFcross.html#XREFcross">cross</a>.

        </blockquote></div>

<!-- del2 scripts/general/del2.m -->
   <p><a name="XREFdel2"></a>

<div class="defun">
&mdash; Function File: <var>d</var> = <b>del2</b> (<var>M</var>)<var><a name="index-del2-2238"></a></var><br>
&mdash; Function File: <var>d</var> = <b>del2</b> (<var>M, h</var>)<var><a name="index-del2-2239"></a></var><br>
&mdash; Function File: <var>d</var> = <b>del2</b> (<var>M, dx, dy, <small class="dots">...</small></var>)<var><a name="index-del2-2240"></a></var><br>
<blockquote>
        <p>Calculate the discrete Laplace
operator. 
For a 2-dimensional matrix <var>M</var> this is defined as

     <pre class="example">                1    / d^2            d^2         \
          D  = --- * | ---  M(x,y) +  ---  M(x,y) |
                4    \ dx^2           dy^2        /
</pre>
        <p>For N-dimensional arrays the sum in parentheses is expanded to include second
derivatives over the additional higher dimensions.

        <p>The spacing between evaluation points may be defined by <var>h</var>, which is a
scalar defining the equidistant spacing in all dimensions.  Alternatively,
the spacing in each dimension may be defined separately by <var>dx</var>,
<var>dy</var>, etc.  A scalar spacing argument defines equidistant spacing,
whereas a vector argument can be used to specify variable spacing.  The
length of the spacing vectors must match the respective dimension of
<var>M</var>.  The default spacing value is 1.

        <p>At least 3 data points are needed for each dimension.  Boundary points are
calculated from the linear extrapolation of interior points.

     <p class="noindent"><strong>See also:</strong> <a href="XREFgradient.html#XREFgradient">gradient</a>, <a href="XREFdiff.html#XREFdiff">diff</a>.

        </blockquote></div>

<!-- factorial scripts/specfun/factorial.m -->
   <p><a name="XREFfactorial"></a>

<div class="defun">
&mdash; Function File:  <b>factorial</b> (<var>n</var>)<var><a name="index-factorial-2241"></a></var><br>
<blockquote><p>Return the factorial of <var>n</var> where <var>n</var> is a positive integer.  If
<var>n</var> is a scalar, this is equivalent to <code>prod (1:</code><var>n</var><code>)</code>.  For
vector or matrix arguments, return the factorial of each element in the
array.  For non-integers see the generalized factorial function
<code>gamma</code>.

     <p class="noindent"><strong>See also:</strong> <a href="XREFprod.html#XREFprod">prod</a>, <a href="XREFgamma.html#XREFgamma">gamma</a>.

        </blockquote></div>

<!-- factor scripts/specfun/factor.m -->
   <p><a name="XREFfactor"></a>

<div class="defun">
&mdash; Function File: <var>p</var> = <b>factor</b> (<var>q</var>)<var><a name="index-factor-2242"></a></var><br>
&mdash; Function File: [<var>p</var>, <var>n</var>] = <b>factor</b> (<var>q</var>)<var><a name="index-factor-2243"></a></var><br>
<blockquote>
        <p>Return prime factorization of <var>q</var>.  That is,
<code>prod (</code><var>p</var><code>) == </code><var>q</var> and every element of <var>p</var> is a prime
number.  If <var>q</var><code> == 1</code>, return 1.

        <p>With two output arguments, return the unique primes <var>p</var> and
their multiplicities.  That is, <code>prod (</code><var>p</var><code> .^ </code><var>n</var><code>) ==
</code><var>q</var>.

     <p class="noindent"><strong>See also:</strong> <a href="XREFgcd.html#XREFgcd">gcd</a>, <a href="XREFlcm.html#XREFlcm">lcm</a>.

        </blockquote></div>

<!-- gcd libinterp/corefcn/gcd.cc -->
   <p><a name="XREFgcd"></a>

<div class="defun">
&mdash; Built-in Function: <var>g</var> = <b>gcd</b> (<var>a1, a2, <small class="dots">...</small></var>)<var><a name="index-gcd-2244"></a></var><br>
&mdash; Built-in Function: [<var>g</var>, <var>v1</var>, <small class="dots">...</small>] = <b>gcd</b> (<var>a1, a2, <small class="dots">...</small></var>)<var><a name="index-gcd-2245"></a></var><br>
<blockquote>
        <p>Compute the greatest common divisor of <var>a1</var>, <var>a2</var>, <small class="dots">...</small>.  If more
than one argument is given all arguments must be the same size or scalar. 
In this case the greatest common divisor is calculated for each element
individually.  All elements must be ordinary or Gaussian (complex)
integers.  Note that for Gaussian integers, the gcd is not unique up to
units (multiplication by 1, -1, <var>i</var> or -<var>i</var>), so an arbitrary
greatest common divisor amongst four possible is returned.

        <p>Example code:

     <pre class="example">          gcd ([15, 9], [20, 18])
             &rArr;  5  9
</pre>
        <p>Optional return arguments <var>v1</var>, etc., contain integer vectors such
that,

     <pre class="example">          <var>g</var> = <var>v1</var> .* <var>a1</var> + <var>v2</var> .* <var>a2</var> + ...
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFlcm.html#XREFlcm">lcm</a>, <a href="XREFfactor.html#XREFfactor">factor</a>.

        </blockquote></div>

<!-- lcm scripts/specfun/lcm.m -->
   <p><a name="XREFlcm"></a>

<div class="defun">
&mdash; Mapping Function:  <b>lcm</b> (<var>x, y</var>)<var><a name="index-lcm-2246"></a></var><br>
&mdash; Mapping Function:  <b>lcm</b> (<var>x, y, <small class="dots">...</small></var>)<var><a name="index-lcm-2247"></a></var><br>
<blockquote><p>Compute the least common multiple of <var>x</var> and <var>y</var>,
or of the list of all arguments.  All elements must be the same size or
scalar.

     <p class="noindent"><strong>See also:</strong> <a href="XREFfactor.html#XREFfactor">factor</a>, <a href="XREFgcd.html#XREFgcd">gcd</a>.

        </blockquote></div>

<!-- chop scripts/general/chop.m -->
   <p><a name="XREFchop"></a>

<div class="defun">
&mdash; Function File:  <b>chop</b> (<var>x, ndigits, base</var>)<var><a name="index-chop-2248"></a></var><br>
<blockquote><p>Truncate elements of <var>x</var> to a length of <var>ndigits</var> such that the
resulting numbers are exactly divisible by <var>base</var>.  If <var>base</var> is not
specified it defaults to 10.

     <pre class="example">          chop (-pi, 5, 10)
             &rArr; -3.14200000000000
          chop (-pi, 5, 5)
             &rArr; -3.14150000000000
</pre>
        </blockquote></div>

<!-- rem libinterp/corefcn/data.cc -->
   <p><a name="XREFrem"></a>

<div class="defun">
&mdash; Mapping Function:  <b>rem</b> (<var>x, y</var>)<var><a name="index-rem-2249"></a></var><br>
&mdash; Mapping Function:  <b>fmod</b> (<var>x, y</var>)<var><a name="index-fmod-2250"></a></var><br>
<blockquote><p>Return the remainder of the division <var>x</var><code> / </code><var>y</var>, computed
using the expression

     <pre class="example">          x - y .* fix (x ./ y)
</pre>
        <p>An error message is printed if the dimensions of the arguments do not
agree, or if either of the arguments is complex.

     <p class="noindent"><strong>See also:</strong> <a href="XREFmod.html#XREFmod">mod</a>.

        </blockquote></div>

<!-- mod libinterp/corefcn/data.cc -->
   <p><a name="XREFmod"></a>

<div class="defun">
&mdash; Mapping Function:  <b>mod</b> (<var>x, y</var>)<var><a name="index-mod-2251"></a></var><br>
<blockquote><p>Compute the modulo of <var>x</var> and <var>y</var>.  Conceptually this is given by

     <pre class="example">          x - y .* floor (x ./ y)
</pre>
        <p class="noindent">and is written such that the correct modulus is returned for
integer types.  This function handles negative values correctly.  That
is, <code>mod (-1, 3)</code> is 2, not -1, as <code>rem (-1, 3)</code> returns. 
<code>mod (</code><var>x</var><code>, 0)</code> returns <var>x</var>.

        <p>An error results if the dimensions of the arguments do not agree, or if
either of the arguments is complex.

     <p class="noindent"><strong>See also:</strong> <a href="XREFrem.html#XREFrem">rem</a>.

        </blockquote></div>

<!-- primes scripts/specfun/primes.m -->
   <p><a name="XREFprimes"></a>

<div class="defun">
&mdash; Function File:  <b>primes</b> (<var>n</var>)<var><a name="index-primes-2252"></a></var><br>
<blockquote>
        <p>Return all primes up to <var>n</var>.

        <p>The algorithm used is the Sieve of Eratosthenes.

        <p>Note that if you need a specific number of primes you can use the
fact that the distance from one prime to the next is, on average,
proportional to the logarithm of the prime.  Integrating, one finds
that there are about k primes less than
k*log (5*k).

     <p class="noindent"><strong>See also:</strong> <a href="XREFlist_005fprimes.html#XREFlist_005fprimes">list_primes</a>, <a href="XREFisprime.html#XREFisprime">isprime</a>.

        </blockquote></div>

<!-- list_primes scripts/miscellaneous/list_primes.m -->
   <p><a name="XREFlist_005fprimes"></a>

<div class="defun">
&mdash; Function File:  <b>list_primes</b> ()<var><a name="index-list_005fprimes-2253"></a></var><br>
&mdash; Function File:  <b>list_primes</b> (<var>n</var>)<var><a name="index-list_005fprimes-2254"></a></var><br>
<blockquote><p>List the first <var>n</var> primes.  If <var>n</var> is unspecified, the first
25 primes are listed.

        <p>The algorithm used is from page 218 of the TeXbook.

     <p class="noindent"><strong>See also:</strong> <a href="XREFprimes.html#XREFprimes">primes</a>, <a href="XREFisprime.html#XREFisprime">isprime</a>.

        </blockquote></div>

<!-- sign libinterp/corefcn/mappers.cc -->
   <p><a name="XREFsign"></a>

<div class="defun">
&mdash; Mapping Function:  <b>sign</b> (<var>x</var>)<var><a name="index-sign-2255"></a></var><br>
<blockquote><p>Compute the <dfn>signum</dfn> function, which is defined as

     <pre class="example">                     -1, x &lt; 0;
          sign (x) =  0, x = 0;
                      1, x &gt; 0.
</pre>
        <p>For complex arguments, <code>sign</code> returns <code>x ./ abs (</code><var>x</var><code>)</code>.

        <p>Note that <code>sign (-0.0)</code> is 0. 
Although IEEE 754 floating point
allows zero to be signed, 0.0 and -0.0 compare equal.  If you must test
whether zero is signed, use the <code>signbit</code> function.

     <p class="noindent"><strong>See also:</strong> <a href="XREFsignbit.html#XREFsignbit">signbit</a>.

        </blockquote></div>

<!-- signbit libinterp/corefcn/mappers.cc -->
   <p><a name="XREFsignbit"></a>

<div class="defun">
&mdash; Mapping Function:  <b>signbit</b> (<var>x</var>)<var><a name="index-signbit-2256"></a></var><br>
<blockquote><p>Return logical true if the value of <var>x</var> has its sign bit set. 
Otherwise return logical false.  This behavior is consistent with the other
logical functions.  See<a href="Logical-Values.html#Logical-Values">Logical Values</a>.  The behavior differs from the
C language function which returns non-zero if the sign bit is set.

        <p>This is not the same as <code>x &lt; 0.0</code>, because IEEE 754 floating point
allows zero to be signed.  The comparison <code>-0.0 &lt; 0.0</code> is false,
but <code>signbit (-0.0)</code> will return a nonzero value.

     <p class="noindent"><strong>See also:</strong> <a href="XREFsign.html#XREFsign">sign</a>.

        </blockquote></div>

   </body></html>

