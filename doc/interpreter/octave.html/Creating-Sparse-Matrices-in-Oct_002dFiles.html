<html lang="en">
<head>
<title>Creating Sparse Matrices in Oct-Files - GNU Octave</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Octave">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Sparse-Matrices-in-Oct_002dFiles.html#Sparse-Matrices-in-Oct_002dFiles" title="Sparse Matrices in Oct-Files">
<link rel="prev" href="Array-and-Sparse-Class-Differences.html#Array-and-Sparse-Class-Differences" title="Array and Sparse Class Differences">
<link rel="next" href="Using-Sparse-Matrices-in-Oct_002dFiles.html#Using-Sparse-Matrices-in-Oct_002dFiles" title="Using Sparse Matrices in Oct-Files">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Creating-Sparse-Matrices-in-Oct-Files"></a>
<a name="Creating-Sparse-Matrices-in-Oct_002dFiles"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Using-Sparse-Matrices-in-Oct_002dFiles.html#Using-Sparse-Matrices-in-Oct_002dFiles">Using Sparse Matrices in Oct-Files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Array-and-Sparse-Class-Differences.html#Array-and-Sparse-Class-Differences">Array and Sparse Class Differences</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Sparse-Matrices-in-Oct_002dFiles.html#Sparse-Matrices-in-Oct_002dFiles">Sparse Matrices in Oct-Files</a>
<hr>
</div>

<h5 class="subsubsection">A.1.6.2 Creating Sparse Matrices in Oct-Files</h5>

<p>There are several useful alternatives for creating a sparse matrix. 
The first is to create three vectors representing the row index, column index,
and data values, and from these create the matrix. 
The second alternative is to create a sparse matrix with the appropriate
amount of space and then fill in the values.  Both techniques have their
advantages and disadvantages.

   <p>Below is an example of creating a small sparse matrix using the first
technique

<pre class="example">     int nz = 4, nr = 3, nc = 4;
     
     ColumnVector ridx (nz);
     ColumnVector cidx (nz);
     ColumnVector data (nz);
     
     ridx(0) = 0; cidx(0) = 0; data(0) = 1;
     ridx(1) = 0; cidx(1) = 1; data(1) = 2;
     ridx(2) = 1; cidx(2) = 3; data(2) = 3;
     ridx(3) = 2; cidx(3) = 3; data(3) = 4;
     SparseMatrix sm (data, ridx, cidx, nr, nc);
</pre>
   <p class="noindent">which creates the matrix given in section
<a href="Storage-of-Sparse-Matrices.html#Storage-of-Sparse-Matrices">Storage of Sparse Matrices</a>.  Note that the compressed matrix
format is not used at the time of the creation of the matrix itself,
but is used internally.

   <p>As discussed in the chapter on Sparse Matrices, the values of the sparse
matrix are stored in increasing column-major ordering.  Although the data
passed by the user need not respect this requirement, pre-sorting the
data will significantly speed up creation of the sparse matrix.

   <p>The disadvantage of this technique for creating a sparse matrix is
that there is a brief time when two copies of the data exist.  For
extremely memory constrained problems this may not be the best
technique for creating a sparse matrix.

   <p>The alternative is to first create a sparse matrix with the desired
number of non-zero elements and then later fill those elements in. 
Sample code:

<pre class="example">     int nz = 4, nr = 3, nc = 4;
     SparseMatrix sm (nr, nc, nz);
     sm(0,0) = 1; sm(0,1) = 2; sm(1,3) = 3; sm(2,3) = 4;
</pre>
   <p>This creates the same matrix as previously.  Again, although not
strictly necessary, it is significantly faster if the sparse matrix is
created and the elements are added in column-major ordering.  The reason
for this is that when elements are inserted at the end of the current list
of known elements then no element in the matrix needs to be moved to allow
the new element to be inserted; Only the column indexes need to be updated.

   <p>There are a few further points to note about this method of creating
a sparse matrix.  First, it is possible to create a sparse matrix
with fewer elements than are actually inserted in the matrix.  Therefore,

<pre class="example">     int nz = 4, nr = 3, nc = 4;
     SparseMatrix sm (nr, nc, 0);
     sm(0,0) = 1; sm(0,1) = 2; sm(1,3) = 3; sm(2,3) = 4;
</pre>
   <p class="noindent">is perfectly valid.  However, it is a very bad idea because as each new
element is added to the sparse matrix the matrix needs to request more
space and reallocate memory.  This is an expensive operation, that will
significantly slow this means of creating a sparse matrix.  Furthermore,
it is possible to create a sparse matrix with too much storage, so having
<var>nz</var> greater than 4 is also valid.  The disadvantage is that the matrix
occupies more memory than strictly needed.

   <p>It is not always possible to know the number of non-zero elements prior
to filling a matrix.  For this reason the additional unused storage of
a sparse matrix can be removed after its creation with the
<code>maybe_compress</code> function.  In addition, <code>maybe_compress</code> can
deallocate the unused storage, but it can also remove zero elements
from the matrix.  The removal of zero elements from the matrix is
controlled by setting the argument of the <code>maybe_compress</code> function
to be <code>true</code>.  However, the cost of removing the zeros is high because it
implies re-sorting the elements.  If possible, it is better
if the user does not add the unnecessary zeros in the first place. 
An example of the use of <code>maybe_compress</code> is

<pre class="example">     int nz = 6, nr = 3, nc = 4;
     
     SparseMatrix sm1 (nr, nc, nz);
     sm1(0,0) = 1; sm1(0,1) = 2; sm1(1,3) = 3; sm1(2,3) = 4;
     sm1.maybe_compress ();  // No zero elements were added
     
     SparseMatrix sm2 (nr, nc, nz);
     sm2(0,0) = 1; sm2(0,1) = 2; sm(0,2) = 0; sm(1,2) = 0;
     sm1(1,3) = 3; sm1(2,3) = 4;
     sm2.maybe_compress (true);  // Zero elements were added
</pre>
   <p>The use of the <code>maybe_compress</code> function should be avoided if
possible as it will slow the creation of the matrix.

   <p>A third means of creating a sparse matrix is to work directly with
the data in compressed row format.  An example of this technique might
be

<pre class="example">     octave_value arg;
     ...
     int nz = 6, nr = 3, nc = 4;   // Assume we know the max # nz
     SparseMatrix sm (nr, nc, nz);
     Matrix m = arg.matrix_value ();
     
     int ii = 0;
     sm.cidx (0) = 0;
     for (int j = 1; j &lt; nc; j++)
       {
         for (int i = 0; i &lt; nr; i++)
           {
             double tmp = foo (m(i,j));
             if (tmp != 0.)
               {
                 sm.data(ii) = tmp;
                 sm.ridx(ii) = i;
                 ii++;
               }
           }
         sm.cidx(j+1) = ii;
      }
     sm.maybe_compress ();  // If don't know a-priori the final # of nz.
</pre>
   <p class="noindent">which is probably the most efficient means of creating a sparse matrix.

   <p>Finally, it might sometimes arise that the amount of storage initially
created is insufficient to completely store the sparse matrix.  Therefore,
the method <code>change_capacity</code> exists to reallocate the sparse memory. 
The above example would then be modified as

<pre class="example">     octave_value arg;
     ...
     int nz = 6, nr = 3, nc = 4;   // Assume we know the max # nz
     SparseMatrix sm (nr, nc, nz);
     Matrix m = arg.matrix_value ();
     
     int ii = 0;
     sm.cidx (0) = 0;
     for (int j = 1; j &lt; nc; j++)
       {
         for (int i = 0; i &lt; nr; i++)
           {
             double tmp = foo (m(i,j));
             if (tmp != 0.)
               {
                 if (ii == nz)
                   {
                     nz += 2;   // Add 2 more elements
                     sm.change_capacity (nz);
                   }
                 sm.data(ii) = tmp;
                 sm.ridx(ii) = i;
                 ii++;
               }
           }
         sm.cidx(j+1) = ii;
      }
     sm.maybe_mutate ();  // If don't know a-priori the final # of nz.
</pre>
   <p>Note that both increasing and decreasing the number of non-zero elements in
a sparse matrix is expensive as it involves memory reallocation.  Also as
parts of the matrix, though not its entirety, exist as old and new copies
at the same time, additional memory is needed.  Therefore, if possible this
should be avoided.

   </body></html>

