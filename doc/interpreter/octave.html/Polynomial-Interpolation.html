<html lang="en">
<head>
<title>Polynomial Interpolation - GNU Octave</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Octave">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Polynomial-Manipulations.html#Polynomial-Manipulations" title="Polynomial Manipulations">
<link rel="prev" href="Derivatives-_002f-Integrals-_002f-Transforms.html#Derivatives-_002f-Integrals-_002f-Transforms" title="Derivatives / Integrals / Transforms">
<link rel="next" href="Miscellaneous-Functions.html#Miscellaneous-Functions" title="Miscellaneous Functions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Polynomial-Interpolation"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Miscellaneous-Functions.html#Miscellaneous-Functions">Miscellaneous Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Derivatives-_002f-Integrals-_002f-Transforms.html#Derivatives-_002f-Integrals-_002f-Transforms">Derivatives / Integrals / Transforms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Polynomial-Manipulations.html#Polynomial-Manipulations">Polynomial Manipulations</a>
<hr>
</div>

<h3 class="section">28.5 Polynomial Interpolation</h3>

<p>Octave comes with good support for various kinds of interpolation,
most of which are described in <a href="Interpolation.html#Interpolation">Interpolation</a>.  One simple alternative
to the functions described in the aforementioned chapter, is to fit
a single polynomial, or a piecewise polynomial (spline) to some given
data points.  To avoid a highly fluctuating polynomial, one most often
wants to fit a low-order polynomial to data.  This usually means that it
is necessary to fit the polynomial in a least-squares sense, which just
is what the <code>polyfit</code> function does.

<!-- polyfit scripts/polynomial/polyfit.m -->
   <p><a name="doc_002dpolyfit"></a>

<div class="defun">
&mdash; Function File: <var>p</var> = <b>polyfit</b> (<var>x, y, n</var>)<var><a name="index-polyfit-2936"></a></var><br>
&mdash; Function File: [<var>p</var>, <var>s</var>] = <b>polyfit</b> (<var>x, y, n</var>)<var><a name="index-polyfit-2937"></a></var><br>
&mdash; Function File: [<var>p</var>, <var>s</var>, <var>mu</var>] = <b>polyfit</b> (<var>x, y, n</var>)<var><a name="index-polyfit-2938"></a></var><br>
<blockquote><p>Return the coefficients of a polynomial <var>p</var>(<var>x</var>) of degree
<var>n</var> that minimizes the least-squares-error of the fit to the points
<code>[</code><var>x</var><code>, </code><var>y</var><code>]</code>.  If <var>n</var> is a logical vector, it is used
as a mask to selectively force the corresponding polynomial
coefficients to be used or ignored.

        <p>The polynomial coefficients are returned in a row vector.

        <p>The optional output <var>s</var> is a structure containing the following fields:

          <dl>
<dt>&lsquo;<samp><span class="samp">R</span></samp>&rsquo;<dd>Triangular factor R from the QR&nbsp;decomposition.

          <br><dt>&lsquo;<samp><span class="samp">X</span></samp>&rsquo;<dd>The Vandermonde matrix used to compute the polynomial coefficients.

          <br><dt>&lsquo;<samp><span class="samp">C</span></samp>&rsquo;<dd>The unscaled covariance matrix, formally equal to the inverse of
<var>x'</var>*<var>x</var>, but computed in a way minimizing roundoff error
propagation.

          <br><dt>&lsquo;<samp><span class="samp">df</span></samp>&rsquo;<dd>The degrees of freedom.

          <br><dt>&lsquo;<samp><span class="samp">normr</span></samp>&rsquo;<dd>The norm of the residuals.

          <br><dt>&lsquo;<samp><span class="samp">yf</span></samp>&rsquo;<dd>The values of the polynomial for each value of <var>x</var>. 
</dl>

        <p>The second output may be used by <code>polyval</code> to calculate the
statistical error limits of the predicted values.  In particular, the
standard deviation of <var>p</var> coefficients is given by <br>
<code>sqrt (diag (s.C)/s.df)*s.normr</code>.

        <p>When the third output, <var>mu</var>, is present the
coefficients, <var>p</var>, are associated with a polynomial in
<var>xhat</var> = (<var>x</var>-<var>mu</var>(1))/<var>mu</var>(2). 
Where <var>mu</var>(1) = mean (<var>x</var>), and <var>mu</var>(2) = std (<var>x</var>). 
This linear transformation of <var>x</var> improves the numerical
stability of the fit.

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dpolyval.html#doc_002dpolyval">polyval</a>, <a href="doc_002dpolyaffine.html#doc_002dpolyaffine">polyaffine</a>, <a href="doc_002droots.html#doc_002droots">roots</a>, <a href="doc_002dvander.html#doc_002dvander">vander</a>, <a href="doc_002dzscore.html#doc_002dzscore">zscore</a>. 
</p></blockquote></div>

   <p>In situations where a single polynomial isn't good enough, a solution
is to use several polynomials pieced together.  The function
<code>splinefit</code> fits a peicewise polynomial (spline) to a set of
data.

<!-- splinefit scripts/polynomial/splinefit.m -->
   <p><a name="doc_002dsplinefit"></a>

<div class="defun">
&mdash; Function File: <var>pp</var> = <b>splinefit</b> (<var>x, y, breaks</var>)<var><a name="index-splinefit-2939"></a></var><br>
&mdash; Function File: <var>pp</var> = <b>splinefit</b> (<var>x, y, p</var>)<var><a name="index-splinefit-2940"></a></var><br>
&mdash; Function File: <var>pp</var> = <b>splinefit</b> (<var><small class="dots">...</small>, "periodic", periodic</var>)<var><a name="index-splinefit-2941"></a></var><br>
&mdash; Function File: <var>pp</var> = <b>splinefit</b> (<var><small class="dots">...</small>, "robust", robust</var>)<var><a name="index-splinefit-2942"></a></var><br>
&mdash; Function File: <var>pp</var> = <b>splinefit</b> (<var><small class="dots">...</small>, "beta", beta</var>)<var><a name="index-splinefit-2943"></a></var><br>
&mdash; Function File: <var>pp</var> = <b>splinefit</b> (<var><small class="dots">...</small>, "order", order</var>)<var><a name="index-splinefit-2944"></a></var><br>
&mdash; Function File: <var>pp</var> = <b>splinefit</b> (<var><small class="dots">...</small>, "constraints", constraints</var>)<var><a name="index-splinefit-2945"></a></var><br>
<blockquote>
        <p>Fit a piecewise cubic spline with breaks (knots) <var>breaks</var> to the
noisy data, <var>x</var> and <var>y</var>.  <var>x</var> is a vector, and <var>y</var>
is a vector or N-D array.  If <var>y</var> is an N-D array, then <var>x</var>(j)
is matched to <var>y</var>(:,<small class="dots">...</small>,:,j).

        <p>The fitted spline is returned as a piecewise polynomial, <var>pp</var>, and
may be evaluated using <code>ppval</code>.

        <p><var>p</var> is a positive integer defining the number of intervals along <var>x</var>,
and <var>p</var>+1 is the number of breaks.  The number of points in each interval
differ by no more than 1.

        <p>The optional property <var>periodic</var> is a logical value which specifies
whether a periodic boundary condition is applied to the spline.  The
length of the period is <code>max (</code><var>breaks</var><code>) - min (</code><var>breaks</var><code>)</code>. 
The default value is <code>false</code>.

        <p>The optional property <var>robust</var> is a logical value which specifies
if robust fitting is to be applied to reduce the influence of outlying
data points.  Three iterations of weighted least squares are performed. 
Weights are computed from previous residuals.  The sensitivity of outlier
identification is controlled by the property <var>beta</var>.  The value of
<var>beta</var> is stricted to the range, 0 &lt; <var>beta</var> &lt; 1.  The default
value is <var>beta</var> = 1/2.  Values close to 0 give all data equal
weighting.  Increasing values of <var>beta</var> reduce the influence of
outlying data.  Values close to unity may cause instability or rank
deficiency.

        <p>The splines are constructed of polynomials with degree <var>order</var>. 
The default is a cubic, <var>order</var>=3.  A spline with P pieces has
P+<var>order</var> degrees of freedom.  With periodic boundary conditions
the degrees of freedom are reduced to P.

        <p>The optional property, <var>constaints</var>, is a structure specifying
linear constraints on the fit.  The structure has three fields, "xc",
"yc", and "cc".

          <dl>
<dt>"xc"<dd>Vector of the x-locations of the constraints.

          <br><dt>"yc"<dd>Constraining values at the locations <var>xc</var>. 
The default is an array of zeros.

          <br><dt>"cc"<dd>Coefficients (matrix).  The default is an array of ones.  The number of
rows is limited to the order of the piecewise polynomials, <var>order</var>. 
</dl>

        <p>Constraints are linear combinations of derivatives of order 0 to
<var>order</var>-1 according to

     <pre class="example">          cc(1,j) * y(xc(j)) + cc(2,j) * y'(xc(j)) + ... = yc(:,...,:,j).
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="doc_002dinterp1.html#doc_002dinterp1">interp1</a>, <a href="doc_002dunmkpp.html#doc_002dunmkpp">unmkpp</a>, <a href="doc_002dppval.html#doc_002dppval">ppval</a>, <a href="doc_002dspline.html#doc_002dspline">spline</a>, <a href="doc_002dpchip.html#doc_002dpchip">pchip</a>, <a href="doc_002dppder.html#doc_002dppder">ppder</a>, <a href="doc_002dppint.html#doc_002dppint">ppint</a>, <a href="doc_002dppjumps.html#doc_002dppjumps">ppjumps</a>. 
</p></blockquote></div>

   <p>The number of <var>breaks</var> (or knots) used to construct the piecewise
polynomial is a significant factor in suppressing the noise present in
the input data, <var>x</var> and <var>y</var>.  This is demonstrated by the example
below.

<pre class="example">     x = 2 * pi * rand (1, 200);
     y = sin (x) + sin (2 * x) + 0.2 * randn (size (x));
     ## Uniform breaks
     breaks = linspace (0, 2 * pi, 41); % 41 breaks, 40 pieces
     pp1 = splinefit (x, y, breaks);
     ## Breaks interpolated from data
     pp2 = splinefit (x, y, 10);  % 11 breaks, 10 pieces
     ## Plot
     xx = linspace (0, 2 * pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
     plot (x, y, ".", xx, [y1; y2])
     axis tight
     ylim auto
     legend ({"data", "41 breaks, 40 pieces", "11 breaks, 10 pieces"})
</pre>
   <p class="noindent">The result of which can be seen in <a href="fig_003asplinefit1.html#fig_003asplinefit1">fig:splinefit1</a>.

   <div class="float">
<a name="fig_003asplinefit1"></a><div align="center"><img src="splinefit1.png" alt="splinefit1.png"></div>
   <p><strong class="float-caption">Figure 28.1: Comparison of a fitting a piecewise polynomial with 41 breaks to one
with 11 breaks.  The fit with the large number of breaks exhibits a fast ripple
that is not present in the underlying function.</strong></p></div>

   <p>The piecewise polynomial fit, provided by <code>splinefit</code>, has
continuous derivatives up to the <var>order</var>-1.  For example, a cubic fit
has continuous first and second derivatives.  This is demonstrated by
the code

<pre class="example">     ## Data (200 points)
     x = 2 * pi * rand (1, 200);
     y = sin (x) + sin (2 * x) + 0.1 * randn (size (x));
     ## Piecewise constant
     pp1 = splinefit (x, y, 8, "order", 0);
     ## Piecewise linear
     pp2 = splinefit (x, y, 8, "order", 1);
     ## Piecewise quadratic
     pp3 = splinefit (x, y, 8, "order", 2);
     ## Piecewise cubic
     pp4 = splinefit (x, y, 8, "order", 3);
     ## Piecewise quartic
     pp5 = splinefit (x, y, 8, "order", 4);
     ## Plot
     xx = linspace (0, 2 * pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
     y3 = ppval (pp3, xx);
     y4 = ppval (pp4, xx);
     y5 = ppval (pp5, xx);
     plot (x, y, ".", xx, [y1; y2; y3; y4; y5])
     axis tight
     ylim auto
     legend ({"data", "order 0", "order 1", "order 2", "order 3", "order 4"})
</pre>
   <p class="noindent">The result of which can be seen in <a href="fig_003asplinefit2.html#fig_003asplinefit2">fig:splinefit2</a>.

   <div class="float">
<a name="fig_003asplinefit2"></a><div align="center"><img src="splinefit2.png" alt="splinefit2.png"></div>
   <p><strong class="float-caption">Figure 28.2: Comparison of a piecewise constant, linear, quadratic, cubic, and
quartic polynomials with 8 breaks to noisy data.  The higher order solutions
more accurately represent the underlying function, but come with the
expense of computational complexity.</strong></p></div>

   <p>When the underlying function to provide a fit to is periodic, <code>splinefit</code>
is able to apply the boundary conditions needed to manifest a periodic fit. 
This is demonstrated by the code below.

<pre class="example">     ## Data (100 points)
     x = 2 * pi * [0, (rand (1, 98)), 1];
     y = sin (x) - cos (2 * x) + 0.2 * randn (size (x));
     ## No constraints
     pp1 = splinefit (x, y, 10, "order", 5);
     ## Periodic boundaries
     pp2 = splinefit (x, y, 10, "order", 5, "periodic", true);
     ## Plot
     xx = linspace (0, 2 * pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
     plot (x, y, ".", xx, [y1; y2])
     axis tight
     ylim auto
     legend ({"data", "no constraints", "periodic"})
</pre>
   <p class="noindent">The result of which can be seen in <a href="fig_003asplinefit3.html#fig_003asplinefit3">fig:splinefit3</a>.

   <div class="float">
<a name="fig_003asplinefit3"></a><div align="center"><img src="splinefit3.png" alt="splinefit3.png"></div>
   <p><strong class="float-caption">Figure 28.3: Comparison of piecewise polynomial fits to a noisy periodic
function with, and without, periodic boundary conditions.</strong></p></div>

   <p>More complex constraints may be added as well.  For example, the code below
illustrates a periodic fit with values that have been clamped at the endpoints,
and a second periodic fit which is hinged at the endpoints.

<pre class="example">     ## Data (200 points)
     x = 2 * pi * rand (1, 200);
     y = sin (2 * x) + 0.1 * randn (size (x));
     ## Breaks
     breaks = linspace (0, 2 * pi, 10);
     ## Clamped endpoints, y = y' = 0
     xc = [0, 0, 2*pi, 2*pi];
     cc = [(eye (2)), (eye (2))];
     con = struct ("xc", xc, "cc", cc);
     pp1 = splinefit (x, y, breaks, "constraints", con);
     ## Hinged periodic endpoints, y = 0
     con = struct ("xc", 0);
     pp2 = splinefit (x, y, breaks, "constraints", con, "periodic", true);
     ## Plot
     xx = linspace (0, 2 * pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
     plot (x, y, ".", xx, [y1; y2])
     axis tight
     ylim auto
     legend ({"data", "clamped", "hinged periodic"})
</pre>
   <p class="noindent">The result of which can be seen in <a href="fig_003asplinefit4.html#fig_003asplinefit4">fig:splinefit4</a>.

   <div class="float">
<a name="fig_003asplinefit4"></a><div align="center"><img src="splinefit4.png" alt="splinefit4.png"></div>
   <p><strong class="float-caption">Figure 28.4: Comparison of two periodic piecewise cubic fits to a noisy periodic
signal.  One fit has its endpoints clamped and the second has its endpoints
hinged.</strong></p></div>

   <p>The <code>splinefit</code> function also provides the convenience of a <var>robust</var>
fitting, where the effect of outlying data is reduced.  In the example below,
three different fits are provided.  Two with differing levels of outlier
suppression and a third illustrating the non-robust solution.

<pre class="example">     ## Data
     x = linspace (0, 2*pi, 200);
     y = sin (x) + sin (2 * x) + 0.05 * randn (size (x));
     ## Add outliers
     x = [x, linspace(0,2*pi,60)];
     y = [y, -ones(1,60)];
     ## Fit splines with hinged conditions
     con = struct ("xc", [0, 2*pi]);
     ## Robust fitting, beta = 0.25
     pp1 = splinefit (x, y, 8, "constraints", con, "beta", 0.25);
     ## Robust fitting, beta = 0.75
     pp2 = splinefit (x, y, 8, "constraints", con, "beta", 0.75);
     ## No robust fitting
     pp3 = splinefit (x, y, 8, "constraints", con);
     ## Plot
     xx = linspace (0, 2*pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
     y3 = ppval (pp3, xx);
     plot (x, y, ".", xx, [y1; y2; y3])
     legend ({"data with outliers","robust, beta = 0.25", ...
              "robust, beta = 0.75", "no robust fitting"})
     axis tight
     ylim auto
</pre>
   <p class="noindent">The result of which can be seen in <a href="fig_003asplinefit6.html#fig_003asplinefit6">fig:splinefit6</a>.

   <div class="float">
<a name="fig_003asplinefit6"></a><div align="center"><img src="splinefit6.png" alt="splinefit6.png"></div>
   <p><strong class="float-caption">Figure 28.5: Comparison of two different levels of robust fitting (<var>beta</var> = 0.25 and 0.75) to noisy data combined with outlying data.  A conventional fit, without
robust fitting (<var>beta</var> = 0) is also included.</strong></p></div>

   <p>The function, <code>ppval</code>, evaluates the piecewise polynomials, created
by <code>mkpp</code> or other means, and <code>unmkpp</code> returns detailed
information about the piecewise polynomial.

   <p>The following example shows how to combine two linear functions and a
quadratic into one function.  Each of these functions is expressed
on adjoined intervals.

<pre class="example">     x = [-2, -1, 1, 2];
     p = [ 0,  1, 0;
           1, -2, 1;
           0, -1, 1 ];
     pp = mkpp (x, p);
     xi = linspace (-2, 2, 50);
     yi = ppval (pp, xi);
     plot (xi, yi);
</pre>
   <!-- mkpp scripts/polynomial/mkpp.m -->
   <p><a name="doc_002dmkpp"></a>

<div class="defun">
&mdash; Function File: <var>pp</var> = <b>mkpp</b> (<var>breaks, coefs</var>)<var><a name="index-mkpp-2946"></a></var><br>
&mdash; Function File: <var>pp</var> = <b>mkpp</b> (<var>breaks, coefs, d</var>)<var><a name="index-mkpp-2947"></a></var><br>
<blockquote>
        <p>Construct a piecewise polynomial (pp) structure from sample points
<var>breaks</var> and coefficients <var>coefs</var>.  <var>breaks</var> must be a vector of
strictly increasing values.  The number of intervals is given by
<var>ni</var><code> = length (</code><var>breaks</var><code>) - 1</code>. 
When <var>m</var> is the polynomial order <var>coefs</var> must be of
size: <var>ni</var> x <var>m</var> + 1.

        <p>The i-th row of <var>coefs</var>,
<var>coefs</var><code> (</code><var>i</var><code>,:)</code>, contains the coefficients for the polynomial
over the <var>i</var>-th interval, ordered from highest (<var>m</var>) to
lowest (<var>0</var>).

        <p><var>coefs</var> may also be a multi-dimensional array, specifying a vector-valued
or array-valued polynomial.  In that case the polynomial order is defined
by the length of the last dimension of <var>coefs</var>. 
The size of first dimension(s) are given by the scalar or
vector <var>d</var>.  If <var>d</var> is not given it is set to <code>1</code>. 
In any case <var>coefs</var> is reshaped to a 2-D matrix of
size <code>[</code><var>ni</var><code>*prod(</code><var>d</var> <var>m</var><code>)] </code>

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dunmkpp.html#doc_002dunmkpp">unmkpp</a>, <a href="doc_002dppval.html#doc_002dppval">ppval</a>, <a href="doc_002dspline.html#doc_002dspline">spline</a>, <a href="doc_002dpchip.html#doc_002dpchip">pchip</a>, <a href="doc_002dppder.html#doc_002dppder">ppder</a>, <a href="doc_002dppint.html#doc_002dppint">ppint</a>, <a href="doc_002dppjumps.html#doc_002dppjumps">ppjumps</a>. 
</p></blockquote></div>

<!-- unmkpp scripts/polynomial/unmkpp.m -->
   <p><a name="doc_002dunmkpp"></a>

<div class="defun">
&mdash; Function File: [<var>x</var>, <var>p</var>, <var>n</var>, <var>k</var>, <var>d</var>] = <b>unmkpp</b> (<var>pp</var>)<var><a name="index-unmkpp-2948"></a></var><br>
<blockquote>
        <p>Extract the components of a piecewise polynomial structure <var>pp</var>. 
The components are:

          <dl>
<dt><var>x</var><dd>Sample points.

          <br><dt><var>p</var><dd>Polynomial coefficients for points in sample interval.  <var>p</var><code>
(</code><var>i</var><code>, :)</code> contains the coefficients for the polynomial over
interval <var>i</var> ordered from highest to lowest.  If <var>d</var><code> &gt;
1</code>, <var>p</var><code> (</code><var>r</var><code>, </code><var>i</var><code>, :)</code> contains the coefficients for
the r-th polynomial defined on interval <var>i</var>.

          <br><dt><var>n</var><dd>Number of polynomial pieces.

          <br><dt><var>k</var><dd>Order of the polynomial plus 1.

          <br><dt><var>d</var><dd>Number of polynomials defined for each interval. 
</dl>

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dmkpp.html#doc_002dmkpp">mkpp</a>, <a href="doc_002dppval.html#doc_002dppval">ppval</a>, <a href="doc_002dspline.html#doc_002dspline">spline</a>, <a href="doc_002dpchip.html#doc_002dpchip">pchip</a>. 
</p></blockquote></div>

<!-- ppval scripts/polynomial/ppval.m -->
   <p><a name="doc_002dppval"></a>

<div class="defun">
&mdash; Function File: <var>yi</var> = <b>ppval</b> (<var>pp, xi</var>)<var><a name="index-ppval-2949"></a></var><br>
<blockquote><p>Evaluate the piecewise polynomial structure <var>pp</var> at the points <var>xi</var>. 
If <var>pp</var> describes a scalar polynomial function, the result is an
array of the same shape as <var>xi</var>. 
Otherwise, the size of the result is <code>[pp.dim, length(</code><var>xi</var><code>)]</code> if
<var>xi</var> is a vector, or <code>[pp.dim, size(</code><var>xi</var><code>)]</code> if it is a
multi-dimensional array.

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dmkpp.html#doc_002dmkpp">mkpp</a>, <a href="doc_002dunmkpp.html#doc_002dunmkpp">unmkpp</a>, <a href="doc_002dspline.html#doc_002dspline">spline</a>, <a href="doc_002dpchip.html#doc_002dpchip">pchip</a>. 
</p></blockquote></div>

<!-- ppder scripts/polynomial/ppder.m -->
   <p><a name="doc_002dppder"></a>

<div class="defun">
&mdash; Function File: ppd = <b>ppder</b> (<var>pp</var>)<var><a name="index-ppder-2950"></a></var><br>
&mdash; Function File: ppd = <b>ppder</b> (<var>pp, m</var>)<var><a name="index-ppder-2951"></a></var><br>
<blockquote><p>Compute the piecewise <var>m</var>-th derivative of a piecewise polynomial
struct <var>pp</var>.  If <var>m</var> is omitted the first derivative is calculated.

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dmkpp.html#doc_002dmkpp">mkpp</a>, <a href="doc_002dppval.html#doc_002dppval">ppval</a>, <a href="doc_002dppint.html#doc_002dppint">ppint</a>. 
</p></blockquote></div>

<!-- ppint scripts/polynomial/ppint.m -->
   <p><a name="doc_002dppint"></a>

<div class="defun">
&mdash; Function File: <var>ppi</var> = <b>ppint</b> (<var>pp</var>)<var><a name="index-ppint-2952"></a></var><br>
&mdash; Function File: <var>ppi</var> = <b>ppint</b> (<var>pp, c</var>)<var><a name="index-ppint-2953"></a></var><br>
<blockquote><p>Compute the integral of the piecewise polynomial struct <var>pp</var>. 
<var>c</var>, if given, is the constant of integration.

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dmkpp.html#doc_002dmkpp">mkpp</a>, <a href="doc_002dppval.html#doc_002dppval">ppval</a>, <a href="doc_002dppder.html#doc_002dppder">ppder</a>. 
</p></blockquote></div>

<!-- ppjumps scripts/polynomial/ppjumps.m -->
   <p><a name="doc_002dppjumps"></a>

<div class="defun">
&mdash; Function File: <var>jumps</var> = <b>ppjumps</b> (<var>pp</var>)<var><a name="index-ppjumps-2954"></a></var><br>
<blockquote><p>Evaluate the boundary jumps of a piecewise polynomial. 
If there are n intervals, and the dimensionality of <var>pp</var> is
d, the resulting array has dimensions <code>[d, n-1]</code>.

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dmkpp.html#doc_002dmkpp">mkpp</a>. 
</p></blockquote></div>

   </body></html>

