@c DO NOT EDIT!  Generated automatically by munge-texi.

@c Copyright (C) 1996, 1997, 2007, 2008, 2009 John W. Eaton
@c
@c This file is part of Octave.
@c
@c Octave is free software; you can redistribute it and/or modify it
@c under the terms of the GNU General Public License as published by the
@c Free Software Foundation; either version 3 of the License, or (at
@c your option) any later version.
@c 
@c Octave is distributed in the hope that it will be useful, but WITHOUT
@c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
@c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
@c for more details.
@c 
@c You should have received a copy of the GNU General Public License
@c along with Octave; see the file COPYING.  If not, see
@c <http://www.gnu.org/licenses/>.

@node Image Processing
@chapter Image Processing

Since an image basically is a matrix Octave is a very powerful
environment for processing and analyzing images.  To illustrate
how easy it is to do image processing in Octave, the following
example will load an image, smooth it by a 5-by-5 averaging filter,
and compute the gradient of the smoothed image.

@example
@group
I = imread ("myimage.jpg");
S = conv2 (I, ones (5, 5) / 25, "same");
[Dx, Dy] = gradient (S);
@end group
@end example

@noindent
In this example @code{S} contains the smoothed image, and @code{Dx}
and @code{Dy} contains the partial spatial derivatives of the image.

@menu
* Loading and Saving Images::   
* Displaying Images::           
* Representing Images::         
* Plotting on top of Images::   
* Color Conversion::            
@end menu

@node Loading and Saving Images
@section Loading and Saving Images

The first step in most image processing tasks is to load an image
into Octave.  This is done using the @code{imread} function, which uses the
@code{GraphicsMagick} library for reading.  This means a vast number of image
formats is supported.  The @code{imwrite} function is the corresponding function
for writing images to the disk.

In summary, most image processing code will follow the structure of this code

@example
@group
I = imread ("my_input_image.img");
J = process_my_image (I);
imwrite ("my_output_image.img", J);
@end group
@end example

@c ./image/imread.m
@anchor{doc-imread}
@deftypefn {Function File} {[@var{img}, @var{map}, @var{alpha}] =} imread (@var{filename})
Read images from various file formats.

The size and numeric class of the output depends on the
format of the image.  A color image is returned as an
MxNx3 matrix.  Grey-level and black-and-white images are
of size MxN.
The color depth of the image determines the numeric
class of the output: "uint8" or "uint16" for grey
and color, and "logical" for black and white.

@seealso{@ref{doc-imwrite,,imwrite}, @ref{doc-imfinfo,,imfinfo}}
@end deftypefn


@c ./image/imwrite.m
@anchor{doc-imwrite}
@deftypefn {Function File} {} imwrite (@var{img}, @var{filename}, @var{fmt}, @var{p1}, @var{v1}, @dots{})
@deftypefnx {Function File} {} imwrite (@var{img}, @var{map}, @var{filename}, @var{fmt}, @var{p1}, @var{v1}, @dots{})
Write images in various file formats.

If @var{fmt} is missing, the file extension (if any) of
@var{filename} is used to determine the format.

The parameter-value pairs (@var{p1}, @var{v1}, @dots{}) are optional.  Currently
the following options are supported for @t{JPEG} images

@table @samp
@item Quality
Sets the quality of the compression.  The corresponding value should be an
integer between 0 and 100, with larger values meaning higher visual quality
and less compression.
@end table

@seealso{@ref{doc-imread,,imread}, @ref{doc-imfinfo,,imfinfo}}
@end deftypefn


@c defaults.cc
@anchor{doc-IMAGE_PATH}
@deftypefn {Built-in Function} {@var{val} =} IMAGE_PATH ()
@deftypefnx {Built-in Function} {@var{old_val} =} IMAGE_PATH (@var{new_val})
Query or set the internal variable that specifies a colon separated
list of directories in which to search for image files.
@end deftypefn


It is possible to get information about an image file on disk, without actually
reading it into Octave.  This is done using the @code{imfinfo} function which
provides read access to many of the parameters stored in the header of the image
file.

@c ./image/imfinfo.m
@anchor{doc-imfinfo}
@deftypefn  {Function File} {@var{info} =} imfinfo (@var{filename})
@deftypefnx {Function File} {@var{info} =} imfinfo (@var{url})
Read image information from a file.

@code{imfinfo} returns a structure containing information about the image
stored in the file @var{filename}.  The output structure contains the
following fields.

@table @samp
@item Filename
The full name of the image file.
@item FileSize
Number of bytes of the image on disk
@item FileModDate
Date of last modification to the file.
@item Height
Image height in pixels.
@item Width
Image Width in pixels.
@item BitDepth
Number of bits per channel per pixel.
@item Format
Image format (e.g., @code{"jpeg"}).
@item LongFormat
Long form image format description.
@item XResolution
X resolution of the image.
@item YResolution
Y resolution of the image.
@item TotalColors
Number of unique colors in the image.
@item TileName
Tile name.
@item AnimationDelay
Time in 1/100ths of a second (0 to 65535) which must expire before displaying
the next image in an animated sequence.
@item AnimationIterations
Number of iterations to loop an animation (e.g., Netscape loop extension) for.
@item ByteOrder
Endian option for formats that support it.  Is either @code{"little-endian"},
@code{"big-endian"}, or @code{"undefined"}.
@item Gamma
Gamma level of the image.  The same color image displayed on two different
workstations may look different due to differences in the display monitor.
@item Matte
@code{true} if the image has transparency.
@item ModulusDepth
Image modulus depth (minimum number of bits required to support red/green/blue
components without loss of accuracy).
@item Quality
JPEG/MIFF/PNG compression level.
@item QuantizeColors
Preferred number of colors in the image.
@item ResolutionUnits
Units of image resolution.  Is either @code{"pixels per inch"},
@code{"pixels per centimeter"}, or @code{"undefined"}.
@item ColorType
Image type.  Is either @code{"grayscale"}, @code{"indexed"}, @code{"truecolor"},
or @code{"undefined"}.
@item View
FlashPix viewing parameters.
@end table

@seealso{@ref{doc-imread,,imread}, @ref{doc-imwrite,,imwrite}}
@end deftypefn


@node Displaying Images
@section Displaying Images

A natural part of image processing is visualization of an image.
The most basic function for this is the @code{imshow} function that
shows the image given in the first input argument.  This function uses
an external program to show the image.  If gnuplot 4.2 or later is 
available it will be used to display the image, otherwise the
@code{display}, @code{xv}, or @code{xloadimage} program is used.  The
actual program can be selected with the @code{image_viewer} function.

@c ./image/imshow.m
@anchor{doc-imshow}
@deftypefn {Function File} {} imshow (@var{im})
@deftypefnx {Function File} {} imshow (@var{im}, @var{limits})
@deftypefnx {Function File} {} imshow (@var{im}, @var{map})
@deftypefnx {Function File} {} imshow (@var{rgb}, @dots{})
@deftypefnx {Function File} {} imshow (@var{filename})
@deftypefnx {Function File} {} imshow (@dots{}, @var{string_param1}, @var{value1}, @dots{})
Display the image @var{im}, where @var{im} can be a 2-dimensional
(gray-scale image) or a 3-dimensional (RGB image) matrix.

If @var{limits} is a 2-element vector @code{[@var{low}, @var{high}]},
the image is shown using a display range between @var{low} and
@var{high}.  If an empty matrix is passed for @var{limits}, the
display range is computed as the range between the minimal and the
maximal value in the image.

If @var{map} is a valid color map, the image will be shown as an indexed
image using the supplied color map.

If a file name is given instead of an image, the file will be read and
shown.

If given, the parameter @var{string_param1} has value
@var{value1}.  @var{string_param1} can be any of the following:
@table @samp
@item "displayrange"
@var{value1} is the display range as described above.
@end table
@seealso{@ref{doc-image,,image}, @ref{doc-imagesc,,imagesc}, @ref{doc-colormap,,colormap}, @ref{doc-gray2ind,,gray2ind}, @ref{doc-rgb2ind,,rgb2ind}}
@end deftypefn


@c ./image/image.m
@anchor{doc-image}
@deftypefn {Function File} {} image (@var{img})
@deftypefnx {Function File} {} image (@var{x}, @var{y}, @var{img})
Display a matrix as a color image.  The elements of @var{x} are indices
into the current colormap, and the colormap will be scaled so that the
extremes of @var{x} are mapped to the extremes of the colormap.

It first tries to use @code{gnuplot}, then @code{display} from 
@code{ImageMagick}, then @code{xv}, and then @code{xloadimage}.
The actual program used can be changed using the @code{image_viewer}
function.

The axis values corresponding to the matrix elements are specified in
@var{x} and @var{y}.  If you're not using gnuplot 4.2 or later, these
variables are ignored.
@seealso{@ref{doc-imshow,,imshow}, @ref{doc-imagesc,,imagesc}, @ref{doc-colormap,,colormap}, @ref{doc-image_viewer,,image_viewer}}
@end deftypefn


@c ./image/imagesc.m
@anchor{doc-imagesc}
@deftypefn {Function File} {} imagesc (@var{a})
@deftypefnx {Function File} {} imagesc (@var{x}, @var{y}, @var{a})
@deftypefnx {Function File} {} imagesc (@dots{}, @var{limits})
@deftypefnx {Function File} {} imagesc (@var{h}, @dots{})
@deftypefnx {Function File} {@var{h} =} imagesc (@dots{})
Display a scaled version of the matrix @var{a} as a color image.  The
colormap is scaled so that the entries of the matrix occupy the entire
colormap.  If @var{limits} = [@var{lo}, @var{hi}] are given, then that
range is set to the 'clim' of the current axes.

The axis values corresponding to the matrix elements are specified in
@var{x} and @var{y}, either as pairs giving the minimum and maximum
values for the respective axes, or as values for each row and column
of the matrix @var{a}.

@seealso{@ref{doc-image,,image}, @ref{doc-imshow,,imshow}, @ref{doc-caxis,,caxis}}
@end deftypefn


@c ./image/image_viewer.m
@anchor{doc-image_viewer}
@deftypefn {Function File} {[@var{fcn}, @var{default_zoom}] =} image_viewer (@var{fcn}, @var{default_zoom})
Change the program or function used for viewing images and return the
previous values.

When the @code{image} or @code{imshow} function is called it will
launch an external program to display the image.  The default behavior
is to use gnuplot if the installed version supports image viewing,
and otherwise try the programs @code{display}, @code{xv}, and
@code{xloadimage}.  Using this function it is possible to change that
behavior.

When called with one input argument images will be displayed by saving
the image to a file and the system command @var{command} will be called
to view the image.  The @var{command} must be a string containing
@code{%s} and possibly @code{%f}.  The @code{%s} will be replaced by
the filename of the image, and the @code{%f} will (if present) be
replaced by the zoom factor given to the @code{image} function.
For example,
@example
image_viewer ("eog %s");
@end example
changes the image viewer to the @code{eog} program.

With two input arguments, images will be displayed by calling
the function @var{function_handle}.  For example,
@example
image_viewer (data, @@my_image_viewer);
@end example
sets the image viewer function to @code{my_image_viewer}.  The image
viewer function is called with
@example
my_image_viewer (@var{x}, @var{y}, @var{im}, @var{zoom}, @var{data})
@end example
where @var{x} and @var{y} are the axis of the image, @var{im} is the image
variable, and @var{data} is extra user-supplied data to be passed to
the viewer function.

With three input arguments it is possible to change the zooming.
Some programs (like @code{xloadimage}) require the zoom factor to be
between 0 and 100, and not 0 and 1 like Octave assumes.  This is
solved by setting the third argument to 100.

@seealso{@ref{doc-image,,image}, @ref{doc-imshow,,imshow}}
@end deftypefn


@node Representing Images
@section Representing Images

In general Octave supports four different kinds of images, gray-scale
images, RGB images, binary images, and indexed images.  A gray-scale
image is represented with an M-by-N matrix in which each
element corresponds to the intensity of a pixel.  An RGB image is
represented with an M-by-N-by-3 array where each
3-vector corresponds to the red, green, and blue intensities of each
pixel.

The actual meaning of the value of a pixel in a gray-scale or RGB
image depends on the class of the matrix.  If the matrix is of class
@code{double} pixel intensities are between 0 and 1, if it is of class
@code{uint8} intensities are between 0 and 255, and if it is of class
@code{uint16} intensities are between 0 and 65535.

A binary image is an M-by-N matrix of class @code{logical}.
A pixel in a binary image is black if it is @code{false} and white
if it is @code{true}.

An indexed image consists of an M-by-N matrix of integers
and a C-by-3 color map.  Each integer corresponds to an
index in the color map, and each row in the color map corresponds to
an RGB color.  The color map must be of class @code{double} with values
between 0 and 1.

@c ./image/gray2ind.m
@anchor{doc-gray2ind}
@deftypefn {Function File} {[@var{img}, @var{map}] =} gray2ind (@var{I}, @var{n})
Convert a gray scale intensity image to an Octave indexed image.
The indexed image will consist of @var{n} different intensity values.  If not
given @var{n} will default to 64.
@end deftypefn


@c ./image/ind2gray.m
@anchor{doc-ind2gray}
@deftypefn {Function File} {} ind2gray (@var{x}, @var{map})
Convert an Octave indexed image to a gray scale intensity image.
If @var{map} is omitted, the current colormap is used to determine the
intensities.
@seealso{@ref{doc-gray2ind,,gray2ind}, @ref{doc-rgb2ntsc,,rgb2ntsc}, @ref{doc-image,,image}, @ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/rgb2ind.m
@anchor{doc-rgb2ind}
@deftypefn  {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{rgb})
@deftypefnx {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{r}, @var{g}, @var{b})
Convert an RGB image to an Octave indexed image.
@seealso{@ref{doc-ind2rgb,,ind2rgb}, @ref{doc-rgb2ntsc,,rgb2ntsc}}
@end deftypefn


@c ./image/ind2rgb.m
@anchor{doc-ind2rgb}
@deftypefn {Function File} {@var{rgb} =} ind2rgb (@var{x}, @var{map})
@deftypefnx {Function File} {[@var{r}, @var{g}, @var{b}] =} ind2rgb (@var{x}, @var{map})
Convert an indexed image to red, green, and blue color components.
If the colormap doesn't contain enough colors, pad it with the
last color in the map.
If @var{map} is omitted, the current colormap is used for the conversion.
@seealso{@ref{doc-rgb2ind,,rgb2ind}, @ref{doc-image,,image}, @ref{doc-imshow,,imshow}, @ref{doc-ind2gray,,ind2gray}, @ref{doc-gray2ind,,gray2ind}}
@end deftypefn


@c ./image/colormap.m
@anchor{doc-colormap}
@deftypefn {Function File} {} colormap (@var{map})
@deftypefnx {Function File} {} colormap ("default")
Set the current colormap.

@code{colormap (@var{map})} sets the current colormap to @var{map}.  The
color map should be an @var{n} row by 3 column matrix.  The columns
contain red, green, and blue intensities respectively.  All entries
should be between 0 and 1 inclusive.  The new colormap is returned.

@code{colormap ("default")} restores the default colormap (the
@code{jet} map with 64 entries).  The default colormap is returned.

With no arguments, @code{colormap} returns the current color map.
@seealso{@ref{doc-jet,,jet}}
@end deftypefn


@c ./image/brighten.m
@anchor{doc-brighten}
@deftypefn {Function File} {@var{map_out} =} brighten (@var{map}, @var{beta})
@deftypefnx {Function File} {@var{map_out} =} brighten (@var{h}, @var{beta})
@deftypefnx {Function File} {@var{map_out} =} brighten (@var{beta})
Darkens or brightens the given colormap.  If the @var{map} argument 
is omitted, the function is applied to the current colormap.  The first
argument can also be a valid graphics handle @var{h}, in which case 
@code{brighten} is applied to the colormap associated with this handle.

Should the resulting colormap @var{map_out} not be assigned, it will be
written to the current colormap.

The argument @var{beta} should be a scalar between -1 and 1,
where a negative value darkens and a positive value brightens
the colormap.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/autumn.m
@anchor{doc-autumn}
@deftypefn {Function File} {} autumn (@var{n})
Create color colormap.  This colormap is red through orange to yellow.
The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/bone.m
@anchor{doc-bone}
@deftypefn {Function File} {} bone (@var{n})
Create color colormap.  This colormap is a gray colormap with a light 
blue tone.  The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/cool.m
@anchor{doc-cool}
@deftypefn {Function File} {} cool (@var{n})
Create color colormap.  The colormap is cyan to magenta.  The argument 
@var{n} should be a scalar.  If it is omitted, the length of the current
colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/copper.m
@anchor{doc-copper}
@deftypefn {Function File} {} copper (@var{n})
Create color colormap.  This colormap is black to a light copper tone.
The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/flag.m
@anchor{doc-flag}
@deftypefn {Function File} {} flag (@var{n})
Create color colormap.  This colormap cycles through red, white, blue 
and black.  The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/gray.m
@anchor{doc-gray}
@deftypefn {Function File} {} gray (@var{n})
Return a gray colormap with @var{n} entries corresponding to values from
0 to @var{n}-1.  The argument @var{n} should be a scalar.  If it is
omitted, the length of the current colormap or 64 is assumed.
@end deftypefn


@c ./image/hot.m
@anchor{doc-hot}
@deftypefn {Function File} {} hot (@var{n})
Create color colormap.  This colormap is black through dark red, red, 
orange, yellow to white.  The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/hsv.m
@anchor{doc-hsv}
@deftypefn {Function File} {} hsv (@var{n})
Create color colormap.  This colormap is red through yellow, green,
cyan, blue, magenta to red.  It is obtained by linearly varying the
hue through all possible values while keeping constant maximum
saturation and value and is equivalent to
@code{hsv2rgb ([linspace(0,1,N)', ones(N,2)])}.

The argument @var{n} should be a scalar.  If it is omitted, the
length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/jet.m
@anchor{doc-jet}
@deftypefn {Function File} {} jet (@var{n})
Create color colormap.  This colormap is dark blue through blue, cyan, 
green, yellow, red to dark red.  The argument @var{n} should be a scalar. 
If it is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/ocean.m
@anchor{doc-ocean}
@deftypefn {Function File} {} ocean (@var{n})
Create color colormap.  The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@end deftypefn


@c ./image/pink.m
@anchor{doc-pink}
@deftypefn {Function File} {} pink (@var{n})
Create color colormap.  This colormap gives a sepia tone on black and
white images.  The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/prism.m
@anchor{doc-prism}
@deftypefn {Function File} {} prism (@var{n})
Create color colormap.  This colormap cycles trough red, orange, yellow,
green, blue and violet.  The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/rainbow.m
@anchor{doc-rainbow}
@deftypefn {Function File} {} rainbow (@var{n})
Create color colormap.  This colormap is red through orange, yellow, green, 
blue to violet.  The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/spring.m
@anchor{doc-spring}
@deftypefn {Function File} {} spring (@var{n})
Create color colormap.  This colormap is magenta to yellow.
The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/summer.m
@anchor{doc-summer}
@deftypefn {Function File} {} summer (@var{n})
Create color colormap.  This colormap is green to yellow.
The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/white.m
@anchor{doc-white}
@deftypefn {Function File} {} white (@var{n})
Create color colormap.  This colormap is completely white.
The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/winter.m
@anchor{doc-winter}
@deftypefn {Function File} {} winter (@var{n})
Create color colormap.  This colormap is blue to green.
The argument @var{n} should be a scalar.  If it
is omitted, the length of the current colormap or 64 is assumed.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


@c ./image/contrast.m
@anchor{doc-contrast}
@deftypefn {Function File} {} contrast (@var{x}, @var{n})
Return a gray colormap that maximizes the contrast in an image.  The
returned colormap will have @var{n} rows.  If @var{n} is not defined
then the size of the current colormap is used instead.
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


An additional colormap is @code{gmap40}.  This code map contains only
colors with integer values of the red, green and blue components.  This
is a workaround for a limitation of gnuplot 4.0, that does not allow the color of
line or patch objects to be set, and so @code{gmap40} is useful for
gnuplot 4.0 users, and in particular in conjunction with the @var{bar},
@var{barh} or @var{contour} functions.

@c ./image/gmap40.m
@anchor{doc-gmap40}
@deftypefn {Function File} {} gmap40 (@var{n})
Create a color colormap.  The colormap is red, green, blue, yellow,
magenta and cyan.  These are the colors that are allowed with patch
objects using gnuplot 4.0, and so this colormap function is specially
designed for users of gnuplot 4.0.  The argument @var{n} should be 
a scalar.  If it is omitted, a length of 6 is assumed.  Larger values
of @var{n} result in a repetition of the above colors
@seealso{@ref{doc-colormap,,colormap}}
@end deftypefn


You may use the @code{spinmap} function to cycle through the colors in
the current colormap, displaying the changes for the current figure.

@c ./plot/spinmap.m
@anchor{doc-spinmap}
@deftypefn {Function File} {} spinmap (@var{t}, @var{inc})
Cycle the colormap for @var{t} seconds with an increment
of @var{inc}.  Both parameters are optional.  The default cycle time
is 5 seconds and the default increment is 2.

A higher value of @var{inc} causes a faster cycle through the
colormap.
@seealso{@ref{doc-gca,,gca}, @ref{doc-colorbar,,colorbar}}
@end deftypefn


@node Plotting on top of Images
@section Plotting on top of Images

If gnuplot is being used to display images it is possible to plot on
top of images.  Since an image is a matrix it is indexed by row and
column values.  The plotting system is, however, based on the 
traditional @math{(x, y)} system.  To minimize the difference between
the two systems Octave places the origin of the coordinate system in
the point corresponding to the pixel at @math{(1, 1)}.  So, to plot
points given by row and column values on top of an image, one should
simply call @code{plot} with the column values as the first argument
and the row values as the second.  As an example the following code
generates an image with random intensities between 0 and 1, and shows
the image with red circles over pixels with an intensity above 
@math{0.99}.

@example
@group
I = rand (100, 100);
[row, col] = find (I > 0.99);
hold ("on");
imshow (I);
plot (col, row, "ro");
hold ("off");
@end group
@end example

@node Color Conversion
@section Color Conversion

Octave supports conversion from the RGB color system to NTSC and HSV
and vice versa. 

@c ./image/rgb2hsv.m
@anchor{doc-rgb2hsv}
@deftypefn {Function File} {@var{hsv_map} =} rgb2hsv (@var{rgb_map})
Transform a colormap or image from the rgb space to the hsv space.

A color n the RGB space consists of the red, green and blue intensities.

In the HSV space each color is represented by their hue, saturation
and value (brightness).  Value gives the amount of light in the color.
Hue describes the dominant wavelength. 
Saturation is the amount of Hue mixed into the color.
@seealso{@ref{doc-hsv2rgb,,hsv2rgb}}
@end deftypefn


@c ./image/hsv2rgb.m
@anchor{doc-hsv2rgb}
@deftypefn {Function File} {@var{rgb_map} =} hsv2rgb (@var{hsv_map})
Transform a colormap or image from the hsv space to the rgb space. 
@seealso{@ref{doc-rgb2hsv,,rgb2hsv}}
@end deftypefn


@c ./image/rgb2ntsc.m
@anchor{doc-rgb2ntsc}
@deftypefn {Function File} {} rgb2ntsc (@var{rgb})
Transform a colormap or image from RGB to NTSC.
@seealso{@ref{doc-ntsc2rgb,,ntsc2rgb}}
@end deftypefn


@c ./image/ntsc2rgb.m
@anchor{doc-ntsc2rgb}
@deftypefn {Function File} {} ntsc2rgb (@var{yiq})
Transform a colormap or image from NTSC to RGB.
@seealso{@ref{doc-rgb2ntsc,,rgb2ntsc}}
@end deftypefn



