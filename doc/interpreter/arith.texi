@c DO NOT EDIT!  Generated automatically by munge-texi.

@c Copyright (C) 1996, 1997, 1999, 2000, 2001, 2002, 2007, 2008,
@c               2009 John W. Eaton
@c
@c This file is part of Octave.
@c
@c Octave is free software; you can redistribute it and/or modify it
@c under the terms of the GNU General Public License as published by the
@c Free Software Foundation; either version 3 of the License, or (at
@c your option) any later version.
@c 
@c Octave is distributed in the hope that it will be useful, but WITHOUT
@c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
@c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
@c for more details.
@c 
@c You should have received a copy of the GNU General Public License
@c along with Octave; see the file COPYING.  If not, see
@c <http://www.gnu.org/licenses/>.

@node Arithmetic
@chapter Arithmetic

Unless otherwise noted, all of the functions described in this chapter
will work for real and complex scalar, vector, or matrix arguments.  Functions
described as @dfn{mapping functions} apply the given operation individually to 
each element when given a matrix argument.  For example,

@example
@group
sin ([1, 2; 3, 4])
     @result{}  0.84147   0.90930
         0.14112  -0.75680
@end group
@end example

@menu
* Exponents and Logarithms::
* Complex Arithmetic::          
* Trigonometry::                
* Sums and Products::           
* Utility Functions::           
* Special Functions::           
* Coordinate Transformations::
* Mathematical Constants::      
@end menu

@node Exponents and Logarithms
@section Exponents and Logarithms

@c mappers.cc
@anchor{doc-exp}
@deftypefn {Mapping Function} {} exp (@var{x})
Compute
@tex
$e^{x}$
@end tex
@ifnottex
@code{e^x}
@end ifnottex
for each element of @var{x}.  To compute the matrix
exponential, see @ref{Linear Algebra}.
@seealso{@ref{doc-log,,log}}
@end deftypefn


@c mappers.cc
@anchor{doc-expm1}
@deftypefn {Mapping Function} {} expm1 (@var{x})
Compute
@tex
$ e^{x} - 1 $
@end tex
@ifnottex
@code{exp (@var{x}) - 1}
@end ifnottex
accurately in the neighborhood of zero.
@seealso{@ref{doc-exp,,exp}}
@end deftypefn


@c mappers.cc
@anchor{doc-log}
@deftypefn {Mapping Function} {} log (@var{x})
Compute the natural logarithm,
@tex
$\ln{(x)},$
@end tex
@ifnottex
@code{ln (@var{x})},
@end ifnottex
for each element of @var{x}.  To compute the
matrix logarithm, see @ref{Linear Algebra}.
@seealso{@ref{doc-exp,,exp}, @ref{doc-log1p,,log1p}, @ref{doc-log2,,log2}, @ref{doc-log10,,log10}, @ref{doc-logspace,,logspace}}
@end deftypefn


@c mappers.cc
@anchor{doc-log1p}
@deftypefn {Mapping Function} {} log1p (@var{x})
Compute
@tex
$\ln{(1 + x)}$
@end tex
@ifnottex
@code{log (1 + @var{x})}
@end ifnottex
accurately in the neighborhood of zero.
@seealso{@ref{doc-log,,log}, @ref{doc-exp,,exp}, @ref{doc-expm1,,expm1}}
@end deftypefn


@c mappers.cc
@anchor{doc-log10}
@deftypefn {Mapping Function} {} log10 (@var{x})
Compute the base-10 logarithm of each element of @var{x}.
@seealso{@ref{doc-log,,log}, @ref{doc-log2,,log2}, @ref{doc-logspace,,logspace}, @ref{doc-exp,,exp}}
@end deftypefn


@c data.cc
@anchor{doc-log2}
@deftypefn {Mapping Function} {} log2 (@var{x})
@deftypefnx {Mapping Function} {[@var{f}, @var{e}] =} log2 (@var{x})
Compute the base-2 logarithm of each element of @var{x}.

If called with two output arguments, split @var{x} into
binary mantissa and exponent so that
@tex
${1 \over 2} \le \left| f \right| < 1$
@end tex
@ifnottex
@code{1/2 <= abs(f) < 1}
@end ifnottex
and @var{e} is an integer.  If
@tex
$x = 0$, $f = e = 0$.
@end tex
@ifnottex
@code{x = 0}, @code{f = e = 0}.
@end ifnottex
@seealso{@ref{doc-pow2,,pow2}, @ref{doc-log,,log}, @ref{doc-log10,,log10}, @ref{doc-exp,,exp}}
@end deftypefn


@c ./general/nextpow2.m
@anchor{doc-nextpow2}
@deftypefn {Function File} {} nextpow2 (@var{x})
If @var{x} is a scalar, return the first integer @var{n} such that
@tex
$2^n \ge |x|$.
@end tex
@ifnottex
2^n >= abs (x).
@end ifnottex

If @var{x} is a vector, return @code{nextpow2 (length (@var{x}))}.
@seealso{@ref{doc-pow2,,pow2}, @ref{doc-log2,,log2}}
@end deftypefn


@c ./general/nthroot.m
@anchor{doc-nthroot}
@deftypefn {Function File} {} nthroot (@var{x}, @var{n})

Compute the n-th root of @var{x}, returning real results for real 
components of @var{x}.  For example

@example
@group
nthroot (-1, 3)
@result{} -1
(-1) ^ (1 / 3)
@result{} 0.50000 - 0.86603i
@end group
@end example

@end deftypefn


@c ./specfun/pow2.m
@anchor{doc-pow2}
@deftypefn {Mapping Function} {} pow2 (@var{x})
@deftypefnx {Mapping Function} {} pow2 (@var{f}, @var{e})
With one argument, computes
@tex
$2^x$
@end tex
@ifnottex
2 .^ x
@end ifnottex
for each element of @var{x}.

With two arguments, returns
@tex
$f \cdot 2^e$.
@end tex
@ifnottex
f .* (2 .^ e).
@end ifnottex
@seealso{@ref{doc-log2,,log2}, @ref{doc-nextpow2,,nextpow2}}
@end deftypefn


@c ./specfun/reallog.m
@anchor{doc-reallog}
@deftypefn {Function File} {} reallog (@var{x})
Return the real-valued natural logarithm of each element of @var{x}.  Report 
an error if any element results in a complex return value.
@seealso{@ref{doc-log,,log}, @ref{doc-realpow,,realpow}, @ref{doc-realsqrt,,realsqrt}}
@end deftypefn


@c ./specfun/realpow.m
@anchor{doc-realpow}
@deftypefn {Function File} {} realpow (@var{x}, @var{y})
Compute the real-valued, element-by-element power operator.  This is 
equivalent to @w{@code{@var{x} .^ @var{y}}}, except that @code{realpow}
reports an error if any return value is complex.
@seealso{@ref{doc-reallog,,reallog}, @ref{doc-realsqrt,,realsqrt}}
@end deftypefn


@c ./specfun/realsqrt.m
@anchor{doc-realsqrt}
@deftypefn {Function File} {} realsqrt (@var{x})
Return the real-valued square root of each element of @var{x}.  Report an
error if any element results in a complex return value.
@seealso{@ref{doc-sqrt,,sqrt}, @ref{doc-realpow,,realpow}, @ref{doc-reallog,,reallog}}
@end deftypefn


@c mappers.cc
@anchor{doc-sqrt}
@deftypefn {Mapping Function} {} sqrt (@var{x})
Compute the square root of each element of @var{x}.  If @var{x} is negative,
a complex result is returned.  To compute the matrix square root, see
@ref{Linear Algebra}.
@seealso{@ref{doc-realsqrt,,realsqrt}}
@end deftypefn


@node Complex Arithmetic
@section Complex Arithmetic

In the descriptions of the following functions,
@tex
$z$ is the complex number $x + iy$, where $i$ is defined as
$\sqrt{-1}$.
@end tex
@ifinfo
@var{z} is the complex number @var{x} + @var{i}@var{y}, where @var{i} is
defined as @code{sqrt (-1)}.
@end ifinfo

@c mappers.cc
@anchor{doc-abs}
@deftypefn {Mapping Function} {} abs (@var{z})
Compute the magnitude of @var{z}, defined as
@tex
$|z| = \sqrt{x^2 + y^2}$.
@end tex
@ifnottex
|@var{z}| = @code{sqrt (x^2 + y^2)}.
@end ifnottex

For example,

@example
@group
abs (3 + 4i)
     @result{} 5
@end group
@end example
@end deftypefn


@c mappers.cc
@anchor{doc-arg}
@deftypefn {Mapping Function} {} arg (@var{z})
@deftypefnx {Mapping Function} {} angle (@var{z})
Compute the argument of @var{z}, defined as,
@tex
$\theta = atan2 (y, x),$
@end tex
@ifnottex
@var{theta} = @code{atan2 (@var{y}, @var{x})},
@end ifnottex
in radians.

For example,

@example
@group
arg (3 + 4i)
     @result{} 0.92730
@end group
@end example
@end deftypefn


@c mappers.cc
@anchor{doc-conj}
@deftypefn {Mapping Function} {} conj (@var{z})
Return the complex conjugate of @var{z}, defined as
@tex
$\bar{z} = x - iy$.
@end tex
@ifnottex
@code{conj (@var{z})} = @var{x} - @var{i}@var{y}.
@end ifnottex
@seealso{@ref{doc-real,,real}, @ref{doc-imag,,imag}}
@end deftypefn


@c ./general/cplxpair.m
@anchor{doc-cplxpair}
@deftypefn  {Function File} {} cplxpair (@var{z})
@deftypefnx {Function File} {} cplxpair (@var{z}, @var{tol})
@deftypefnx {Function File} {} cplxpair (@var{z}, @var{tol}, @var{dim})
Sort the numbers @var{z} into complex conjugate pairs ordered by 
increasing real part.  Place the negative imaginary complex number
first within each pair.  Place all the real numbers (those with
@code{abs (imag (@var{z}) / @var{z}) < @var{tol})}) after the
complex pairs.

If @var{tol} is unspecified the default value is 100*@code{eps}.

By default the complex pairs are sorted along the first non-singleton
dimension of @var{z}.  If @var{dim} is specified, then the complex
pairs are sorted along this dimension.

Signal an error if some complex numbers could not be paired.  Signal an
error if all complex numbers are not exact conjugates (to within
@var{tol}).  Note that there is no defined order for pairs with identical
real parts but differing imaginary parts.

@c Set example in small font to prevent overfull line
@smallexample
cplxpair (exp(2i*pi*[0:4]'/5)) == exp(2i*pi*[3; 2; 4; 1; 0]/5)
@end smallexample
@end deftypefn


@c mappers.cc
@anchor{doc-imag}
@deftypefn {Mapping Function} {} imag (@var{z})
Return the imaginary part of @var{z} as a real number.
@seealso{@ref{doc-real,,real}, @ref{doc-conj,,conj}}
@end deftypefn


@c mappers.cc
@anchor{doc-real}
@deftypefn {Mapping Function} {} real (@var{z})
Return the real part of @var{z}.
@seealso{@ref{doc-imag,,imag}, @ref{doc-conj,,conj}}
@end deftypefn


@node Trigonometry
@section Trigonometry

Octave provides the following trigonometric functions where angles are
specified in radians.  To convert from degrees to radians multiply by
@tex
$\pi/180$
@end tex
@ifnottex
@code{pi/180}
@end ifnottex
(e.g., @code{sin (30 * pi/180)} returns the sine of 30 degrees).  As
an alternative, Octave provides a number of trigonometric functions
which work directly on an argument specified in degrees.  These functions
are named after the base trigonometric function with a @samp{d} suffix.  For
example, @code{sin} expects an angle in radians while @code{sind} expects an
angle in degrees.

@c mappers.cc
@anchor{doc-sin}
@deftypefn {Mapping Function} {} sin (@var{x})
Compute the sine for each element of @var{x} in radians.
@seealso{@ref{doc-asin,,asin}, @ref{doc-sind,,sind}, @ref{doc-sinh,,sinh}}
@end deftypefn

@c mappers.cc
@anchor{doc-cos}
@deftypefn {Mapping Function} {} cos (@var{x})
Compute the cosine for each element of @var{x} in radians.
@seealso{@ref{doc-acos,,acos}, @ref{doc-cosd,,cosd}, @ref{doc-cosh,,cosh}}
@end deftypefn

@c mappers.cc
@anchor{doc-tan}
@deftypefn {Mapping Function} {} tan (@var{z})
Compute the tangent for each element of @var{x} in radians.
@seealso{@ref{doc-atan,,atan}, @ref{doc-tand,,tand}, @ref{doc-tanh,,tanh}}
@end deftypefn

@c ./elfun/sec.m
@anchor{doc-sec}
@deftypefn {Mapping Function} {} sec (@var{x})
Compute the secant for each element of @var{x} in radians.
@seealso{@ref{doc-asec,,asec}, @ref{doc-secd,,secd}, @ref{doc-sech,,sech}}
@end deftypefn

@c ./elfun/csc.m
@anchor{doc-csc}
@deftypefn {Mapping Function} {} csc (@var{x})
Compute the cosecant for each element of @var{x} in radians.
@seealso{@ref{doc-acsc,,acsc}, @ref{doc-cscd,,cscd}, @ref{doc-csch,,csch}}
@end deftypefn

@c ./elfun/cot.m
@anchor{doc-cot}
@deftypefn {Mapping Function} {} cot (@var{x})
Compute the cotangent for each element of @var{x} in radians.
@seealso{@ref{doc-acot,,acot}, @ref{doc-cotd,,cotd}, @ref{doc-coth,,coth}}
@end deftypefn


@c mappers.cc
@anchor{doc-asin}
@deftypefn {Mapping Function} {} asin (@var{x})
Compute the inverse sine in radians for each element of @var{x}.
@seealso{@ref{doc-sin,,sin}, @ref{doc-asind,,asind}}
@end deftypefn

@c mappers.cc
@anchor{doc-acos}
@deftypefn {Mapping Function} {} acos (@var{x})
Compute the inverse cosine in radians for each element of @var{x}.
@seealso{@ref{doc-cos,,cos}, @ref{doc-acosd,,acosd}}
@end deftypefn

@c mappers.cc
@anchor{doc-atan}
@deftypefn {Mapping Function} {} atan (@var{x})
Compute the inverse tangent in radians for each element of @var{x}.
@seealso{@ref{doc-tan,,tan}, @ref{doc-atand,,atand}}
@end deftypefn

@c ./elfun/asec.m
@anchor{doc-asec}
@deftypefn {Mapping Function} {} asec (@var{x})
Compute the inverse secant in radians for each element of @var{x}.
@seealso{@ref{doc-sec,,sec}, @ref{doc-asecd,,asecd}}
@end deftypefn

@c ./elfun/acsc.m
@anchor{doc-acsc}
@deftypefn {Mapping Function} {} acsc (@var{x})
Compute the inverse cosecant in radians for each element of @var{x}.
@seealso{@ref{doc-csc,,csc}, @ref{doc-acscd,,acscd}}
@end deftypefn

@c ./elfun/acot.m
@anchor{doc-acot}
@deftypefn {Mapping Function} {} acot (@var{x})
Compute the inverse cotangent in radians for each element of @var{x}.
@seealso{@ref{doc-cot,,cot}, @ref{doc-acotd,,acotd}}
@end deftypefn


@c mappers.cc
@anchor{doc-sinh}
@deftypefn {Mapping Function} {} sinh (@var{x})
Compute the hyperbolic sine for each element of @var{x}.
@seealso{@ref{doc-asinh,,asinh}, @ref{doc-cosh,,cosh}, @ref{doc-tanh,,tanh}}
@end deftypefn

@c mappers.cc
@anchor{doc-cosh}
@deftypefn {Mapping Function} {} cosh (@var{x})
Compute the hyperbolic cosine for each element of @var{x}.
@seealso{@ref{doc-acosh,,acosh}, @ref{doc-sinh,,sinh}, @ref{doc-tanh,,tanh}}
@end deftypefn

@c mappers.cc
@anchor{doc-tanh}
@deftypefn {Mapping Function} {} tanh (@var{x})
Compute hyperbolic tangent for each element of @var{x}.
@seealso{@ref{doc-atanh,,atanh}, @ref{doc-sinh,,sinh}, @ref{doc-cosh,,cosh}}
@end deftypefn

@c ./elfun/sech.m
@anchor{doc-sech}
@deftypefn {Mapping Function} {} sech (@var{x})
Compute the hyperbolic secant of each element of @var{x}.
@seealso{@ref{doc-asech,,asech}}
@end deftypefn

@c ./elfun/csch.m
@anchor{doc-csch}
@deftypefn {Mapping Function} {} csch (@var{x})
Compute the hyperbolic cosecant of each element of @var{x}.
@seealso{@ref{doc-acsch,,acsch}}
@end deftypefn

@c ./elfun/coth.m
@anchor{doc-coth}
@deftypefn {Mapping Function} {} coth (@var{x})
Compute the hyperbolic cotangent of each element of @var{x}.
@seealso{@ref{doc-acoth,,acoth}}
@end deftypefn


@c mappers.cc
@anchor{doc-asinh}
@deftypefn {Mapping Function} {} asinh (@var{x})
Compute the inverse hyperbolic sine for each element of @var{x}.
@seealso{@ref{doc-sinh,,sinh}}
@end deftypefn

@c mappers.cc
@anchor{doc-acosh}
@deftypefn {Mapping Function} {} acosh (@var{x})
Compute the inverse hyperbolic cosine for each element of @var{x}.
@seealso{@ref{doc-cosh,,cosh}}
@end deftypefn

@c mappers.cc
@anchor{doc-atanh}
@deftypefn {Mapping Function} {} atanh (@var{x})
Compute the inverse hyperbolic tangent for each element of @var{x}.
@seealso{@ref{doc-tanh,,tanh}}
@end deftypefn

@c ./elfun/asech.m
@anchor{doc-asech}
@deftypefn {Mapping Function} {} asech (@var{x})
Compute the inverse hyperbolic secant of each element of @var{x}.
@seealso{@ref{doc-sech,,sech}}
@end deftypefn

@c ./elfun/acsch.m
@anchor{doc-acsch}
@deftypefn {Mapping Function} {} acsch (@var{x})
Compute the inverse hyperbolic cosecant of each element of @var{x}.
@seealso{@ref{doc-csch,,csch}}
@end deftypefn

@c ./elfun/acoth.m
@anchor{doc-acoth}
@deftypefn {Mapping Function} {} acoth (@var{x})
Compute the inverse hyperbolic cotangent of each element of @var{x}.
@seealso{@ref{doc-coth,,coth}}
@end deftypefn


@c data.cc
@anchor{doc-atan2}
@deftypefn {Mapping Function} {} atan2 (@var{y}, @var{x})
Compute atan (@var{y} / @var{x}) for corresponding elements of @var{y}
and @var{x}.  Signal an error if @var{y} and @var{x} do not match in size
and orientation.
@end deftypefn


Octave provides the following trigonometric functions where angles are
specified in degrees.  These functions produce true zeros at the appropriate
intervals rather than the small roundoff error that occurs when using
radians.  For example:
@example
@group
cosd (90)
     @result{} 0
cos (pi/2)
     @result{} 6.1230e-17
@end group
@end example

@c ./elfun/sind.m
@anchor{doc-sind}
@deftypefn {Function File} {} sind (@var{x})
Compute the sine for each element of @var{x} in degrees.  Returns zero 
for elements where @code{@var{x}/180} is an integer.
@seealso{@ref{doc-asind,,asind}, @ref{doc-sin,,sin}}
@end deftypefn

@c ./elfun/cosd.m
@anchor{doc-cosd}
@deftypefn {Function File} {} cosd (@var{x})
Compute the cosine for each element of @var{x} in degrees.  Returns zero 
for elements where @code{(@var{x}-90)/180} is an integer.
@seealso{@ref{doc-acosd,,acosd}, @ref{doc-cos,,cos}}
@end deftypefn

@c ./elfun/tand.m
@anchor{doc-tand}
@deftypefn {Function File} {} tand (@var{x})
Compute the tangent for each element of @var{x} in degrees.  Returns zero 
for elements where @code{@var{x}/180} is an integer and @code{Inf} for
elements where @code{(@var{x}-90)/180} is an integer.
@seealso{@ref{doc-atand,,atand}, @ref{doc-tan,,tan}}
@end deftypefn

@c ./elfun/secd.m
@anchor{doc-secd}
@deftypefn {Function File} {} secd (@var{x})
Compute the secant for each element of @var{x} in degrees.
@seealso{@ref{doc-asecd,,asecd}, @ref{doc-sec,,sec}}
@end deftypefn

@c ./elfun/cscd.m
@anchor{doc-cscd}
@deftypefn {Function File} {} cscd (@var{x})
Compute the cosecant for each element of @var{x} in degrees.
@seealso{@ref{doc-acscd,,acscd}, @ref{doc-csc,,csc}}
@end deftypefn

@c ./elfun/cotd.m
@anchor{doc-cotd}
@deftypefn {Function File} {} cotd (@var{x})
Compute the cotangent for each element of @var{x} in degrees.
@seealso{@ref{doc-acotd,,acotd}, @ref{doc-cot,,cot}}
@end deftypefn


@c ./elfun/asind.m
@anchor{doc-asind}
@deftypefn {Function File} {} asind (@var{x})
Compute the inverse sine in degrees for each element of @var{x}.
@seealso{@ref{doc-sind,,sind}, @ref{doc-asin,,asin}}
@end deftypefn

@c ./elfun/acosd.m
@anchor{doc-acosd}
@deftypefn {Function File} {} acosd (@var{x})
Compute the inverse cosine in degrees for each element of @var{x}.
@seealso{@ref{doc-cosd,,cosd}, @ref{doc-acos,,acos}}
@end deftypefn

@c ./elfun/atand.m
@anchor{doc-atand}
@deftypefn {Function File} {} atand (@var{x})
Compute the inverse tangent in degrees for each element of @var{x}.
@seealso{@ref{doc-tand,,tand}, @ref{doc-atan,,atan}}
@end deftypefn

@c ./elfun/asecd.m
@anchor{doc-asecd}
@deftypefn {Function File} {} asecd (@var{x})
Compute the inverse secant in degrees for each element of @var{x}.
@seealso{@ref{doc-secd,,secd}, @ref{doc-asec,,asec}}
@end deftypefn

@c ./elfun/acscd.m
@anchor{doc-acscd}
@deftypefn {Function File} {} acscd (@var{x})
Compute the inverse cosecant in degrees for each element of @var{x}.
@seealso{@ref{doc-cscd,,cscd}, @ref{doc-acsc,,acsc}}
@end deftypefn

@c ./elfun/acotd.m
@anchor{doc-acotd}
@deftypefn {Function File} {} acotd (@var{x})
Compute the inverse cotangent in degrees for each element of @var{x}.
@seealso{@ref{doc-cotd,,cotd}, @ref{doc-acot,,acot}}
@end deftypefn


@node Sums and Products
@section Sums and Products

@c data.cc
@anchor{doc-sum}
@deftypefn  {Built-in Function} {} sum (@var{x})
@deftypefnx {Built-in Function} {} sum (@var{x}, @var{dim})
@deftypefnx {Built-in Function} {} sum (@dots{}, 'native')
Sum of elements along dimension @var{dim}.  If @var{dim} is
omitted, it defaults to 1 (column-wise sum).

As a special case, if @var{x} is a vector and @var{dim} is omitted,
return the sum of the elements.

If the optional argument 'native' is given, then the sum is performed
in the same type as the original argument, rather than in the default
double type.  For example

@example
@group
sum ([true, true])
  @result{} 2
sum ([true, true], 'native')
  @result{} true
@end group
@end example
@seealso{@ref{doc-cumsum,,cumsum}, @ref{doc-sumsq,,sumsq}, @ref{doc-prod,,prod}}
@end deftypefn


@c data.cc
@anchor{doc-prod}
@deftypefn  {Built-in Function} {} prod (@var{x})
@deftypefnx {Built-in Function} {} prod (@var{x}, @var{dim})
Product of elements along dimension @var{dim}.  If @var{dim} is
omitted, it defaults to 1 (column-wise products).

As a special case, if @var{x} is a vector and @var{dim} is omitted,
return the product of the elements.
@seealso{@ref{doc-cumprod,,cumprod}, @ref{doc-sum,,sum}}
@end deftypefn


@c data.cc
@anchor{doc-cumsum}
@deftypefn  {Built-in Function} {} cumsum (@var{x})
@deftypefnx {Built-in Function} {} cumsum (@var{x}, @var{dim})
@deftypefnx {Built-in Function} {} cumsum (@dots{}, 'native')
Cumulative sum of elements along dimension @var{dim}.  If @var{dim}
is omitted, it defaults to 1 (column-wise cumulative sums).

As a special case, if @var{x} is a vector and @var{dim} is omitted,
return the cumulative sum of the elements as a vector with the
same orientation as @var{x}.

The "native" argument implies the summation is performed in native type.
 See @code{sum} for a complete description and example of the use of
"native".
@seealso{@ref{doc-sum,,sum}, @ref{doc-cumprod,,cumprod}}
@end deftypefn


@c data.cc
@anchor{doc-cumprod}
@deftypefn  {Built-in Function} {} cumprod (@var{x})
@deftypefnx {Built-in Function} {} cumprod (@var{x}, @var{dim})
Cumulative product of elements along dimension @var{dim}.  If
@var{dim} is omitted, it defaults to 1 (column-wise cumulative
products).

As a special case, if @var{x} is a vector and @var{dim} is omitted,
return the cumulative product of the elements as a vector with the
same orientation as @var{x}.
@seealso{@ref{doc-prod,,prod}, @ref{doc-cumsum,,cumsum}}
@end deftypefn


@c data.cc
@anchor{doc-sumsq}
@deftypefn  {Built-in Function} {} sumsq (@var{x})
@deftypefnx {Built-in Function} {} sumsq (@var{x}, @var{dim})
Sum of squares of elements along dimension @var{dim}.  If @var{dim}
is omitted, it defaults to 1 (column-wise sum of squares).

As a special case, if @var{x} is a vector and @var{dim} is omitted,
return the sum of squares of the elements.

This function is conceptually equivalent to computing
@example
sum (x .* conj (x), dim)
@end example
but it uses less memory and avoids calling @code{conj} if @var{x} is real.
@seealso{@ref{doc-sum,,sum}}
@end deftypefn


@c ./general/accumarray.m
@anchor{doc-accumarray}
@deftypefn {Function File} {} accumarray (@var{subs}, @var{vals}, @var{sz}, @var{func}, @var{fillval}, @var{issparse})
@deftypefnx {Function File} {} accumarray (@var{csubs}, @var{vals}, @dots{})

Create an array by accumulating the elements of a vector into the
positions defined by their subscripts.  The subscripts are defined by
the rows of the matrix @var{subs} and the values by @var{vals}.  Each row
of @var{subs} corresponds to one of the values in @var{vals}.

The size of the matrix will be determined by the subscripts themselves.
However, if @var{sz} is defined it determines the matrix size.  The length
of @var{sz} must correspond to the number of columns in @var{subs}.

The default action of @code{accumarray} is to sum the elements with the
same subscripts.  This behavior can be modified by defining the @var{func}
function.  This should be a function or function handle that accepts a 
column vector and returns a scalar.  The result of the function should not
depend on the order of the subscripts.

The elements of the returned array that have no subscripts associated with
them are set to zero.  Defining @var{fillval} to some other value allows
these values to be defined.

By default @code{accumarray} returns a full matrix.  If @var{issparse} is
logically true, then a sparse matrix is returned instead.

An example of the use of @code{accumarray} is:

@example
@group
accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2], 101:105)
@result{} ans(:,:,1) = [101, 0, 0; 0, 0, 0]
   ans(:,:,2) = [0, 0, 0; 206, 0, 208]
@end group
@end example
@end deftypefn


@node Utility Functions
@section Utility Functions

@c mappers.cc
@anchor{doc-ceil}
@deftypefn {Mapping Function} {} ceil (@var{x})
Return the smallest integer not less than @var{x}.  This is equivalent to
rounding towards positive infinity.  If @var{x} is
complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.
@example
@group
ceil ([-2.7, 2.7])
   @result{}  -2   3
@end group
@end example
@seealso{@ref{doc-floor,,floor}, @ref{doc-round,,round}, @ref{doc-fix,,fix}}
@end deftypefn


@c ./linear-algebra/cross.m
@anchor{doc-cross}
@deftypefn  {Function File} {} cross (@var{x}, @var{y})
@deftypefnx {Function File} {} cross (@var{x}, @var{y}, @var{dim})
Compute the vector cross product of two 3-dimensional vectors
@var{x} and @var{y}.

@example
@group
cross ([1,1,0], [0,1,1])
     @result{} [ 1; -1; 1 ]
@end group
@end example

If @var{x} and @var{y} are matrices, the cross product is applied 
along the first dimension with 3 elements.  The optional argument 
@var{dim} forces the cross product to be calculated along
the specified dimension.
@seealso{@ref{doc-dot,,dot}}
@end deftypefn


@c ./general/del2.m
@anchor{doc-del2}
@deftypefn  {Function File} {@var{d} =} del2 (@var{m})
@deftypefnx {Function File} {@var{d} =} del2 (@var{m}, @var{h})
@deftypefnx {Function File} {@var{d} =} del2 (@var{m}, @var{dx}, @var{dy}, @dots{})

Calculate the discrete Laplace
@tex
operator $( \nabla^2 )$.
@end tex
@ifnottex
operator.
@end ifnottex
For a 2-dimensional matrix @var{m} this is defined as

@tex
$$d = {1 \over 4} \left( {d^2 \over dx^2} M(x,y) + {d^2 \over dy^2} M(x,y) \right)$$
@end tex
@ifnottex
@example
@group
      1    / d^2            d^2         \
D  = --- * | ---  M(x,y) +  ---  M(x,y) | 
      4    \ dx^2           dy^2        /
@end group
@end example
@end ifnottex

For N-dimensional arrays the sum in parentheses is expanded to include second derivatives 
over the additional higher dimensions.

The spacing between evaluation points may be defined by @var{h}, which is a
scalar defining the equidistant spacing in all dimensions.  Alternatively, 
the spacing in each dimension may be defined separately by @var{dx}, @var{dy},
etc.  A scalar spacing argument defines equidistant spacing, whereas a vector
argument can be used to specify variable spacing.  The length of the spacing vectors
must match the respective dimension of @var{m}.  The default spacing value
is 1.

At least 3 data points are needed for each dimension.  Boundary points are
calculated from the linear extrapolation of interior points.

@seealso{@ref{doc-gradient,,gradient}, @ref{doc-diff,,diff}}
@end deftypefn


@c ./specfun/factor.m
@anchor{doc-factor}
@deftypefn  {Function File} {@var{p} =} factor (@var{q})
@deftypefnx {Function File} {[@var{p}, @var{n}] =} factor (@var{q})

Return prime factorization of @var{q}.  That is, @code{prod (@var{p})
== @var{q}} and every element of @var{p} is a prime number.  If
@code{@var{q} == 1}, returns 1. 

With two output arguments, return the unique primes @var{p} and
their multiplicities.  That is, @code{prod (@var{p} .^ @var{n}) ==
@var{q}}.
@seealso{@ref{doc-gcd,,gcd}, @ref{doc-lcm,,lcm}}
@end deftypefn


@c ./specfun/factorial.m
@anchor{doc-factorial}
@deftypefn {Function File} {} factorial (@var{n})
Return the factorial of @var{n} where @var{n} is a positive integer.  If
@var{n} is a scalar, this is equivalent to @code{prod (1:@var{n})}.  For
vector or matrix arguments, return the factorial of each element in the
array.  For non-integers see the generalized factorial function
@code{gamma}.
@seealso{@ref{doc-prod,,prod}, @ref{doc-gamma,,gamma}}
@end deftypefn


@c mappers.cc
@anchor{doc-fix}
@deftypefn {Mapping Function} {} fix (@var{x})
Truncate fractional portion of @var{x} and return the integer portion.  This
is equivalent to rounding towards zero.  If @var{x} is complex, return
@code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.
@example
@group
fix ([-2.7, 2.7])
   @result{} -2   2
@end group
@end example
@seealso{@ref{doc-ceil,,ceil}, @ref{doc-floor,,floor}, @ref{doc-round,,round}}
@end deftypefn


@c mappers.cc
@anchor{doc-floor}
@deftypefn {Mapping Function} {} floor (@var{x})
Return the largest integer not greater than @var{x}.  This is equivalent to
rounding towards negative infinity.  If @var{x} is
complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.
@example
@group
floor ([-2.7, 2.7])
     @result{} -3   2
@end group
@end example
@seealso{@ref{doc-ceil,,ceil}, @ref{doc-round,,round}, @ref{doc-fix,,fix}}
@end deftypefn


@c data.cc
@anchor{doc-fmod}
@deftypefn {Mapping Function} {} fmod (@var{x}, @var{y})
Compute the floating point remainder of dividing @var{x} by @var{y}
using the C library function @code{fmod}.  The result has the same
sign as @var{x}.  If @var{y} is zero, the result is implementation-dependent.
@seealso{@ref{doc-mod,,mod}, @ref{doc-rem,,rem}}
@end deftypefn


@c ./DLD-FUNCTIONS/gcd.cc
@anchor{doc-gcd}
@deftypefn  {Loadable Function} {@var{g} =} gcd (@var{a})
@deftypefnx {Loadable Function} {@var{g} =} gcd (@var{a1}, @var{a2}, @dots{})
@deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})

Compute the greatest common divisor of the elements of @var{a}.  If more
than one argument is given all arguments must be the same size or scalar.
  In this case the greatest common divisor is calculated for each element
individually.  All elements must be integers.  For example,

@example
@group
gcd ([15, 20])
    @result{}  5
@end group
@end example

@noindent
and

@example
@group
gcd ([15, 9], [20, 18])
    @result{}  5  9
@end group
@end example

Optional return arguments @var{v1}, etc., contain integer vectors such
that,

@tex
$g = v_1 a_1 + v_2 a_2 + \cdots$
@end tex
@ifnottex
@example
@var{g} = @var{v1} .* @var{a1} + @var{v2} .* @var{a2} + @dots{}
@end example
@end ifnottex

For backward compatibility with previous versions of this function, when
all arguments are scalar, a single return argument @var{v1} containing
all of the values of @var{v1}, @dots{} is acceptable.
@seealso{@ref{doc-lcm,,lcm}, @ref{doc-factor,,factor}}
@end deftypefn


@c ./general/gradient.m
@anchor{doc-gradient}
@deftypefn {Function File} {@var{dx} =} gradient (@var{m})
@deftypefnx {Function File} {[@var{dx}, @var{dy}, @var{dz}, @dots{}] =} gradient (@var{m})
@deftypefnx {Function File} {[@dots{}] =} gradient (@var{m}, @var{s})
@deftypefnx {Function File} {[@dots{}] =} gradient (@var{m}, @var{x}, @var{y}, @var{z}, @dots{})
@deftypefnx {Function File} {[@dots{}] =} gradient (@var{f}, @var{x0})
@deftypefnx {Function File} {[@dots{}] =} gradient (@var{f}, @var{x0}, @var{s})
@deftypefnx {Function File} {[@dots{}] =} gradient (@var{f}, @var{x0}, @var{x}, @var{y}, @dots{})

Calculate the gradient of sampled data or a function.  If @var{m}
is a vector, calculate the one-dimensional gradient of @var{m}.  If
@var{m} is a matrix the gradient is calculated for each dimension.

@code{[@var{dx}, @var{dy}] = gradient (@var{m})} calculates the one
dimensional gradient for @var{x} and @var{y} direction if @var{m} is a
matrix.  Additional return arguments can be use for multi-dimensional
matrices.

A constant spacing between two points can be provided by the
@var{s} parameter.  If @var{s} is a scalar, it is assumed to be the spacing
for all dimensions. 
Otherwise, separate values of the spacing can be supplied by
the @var{x}, @dots{} arguments.  Scalar values specify an equidistant spacing.
Vector values for the @var{x}, @dots{} arguments specify the coordinate for that
dimension.  The length must match their respective dimension of @var{m}.

At boundary points a linear extrapolation is applied.  Interior points
are calculated with the first approximation of the numerical gradient

@example
y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).
@end example

If the first argument @var{f} is a function handle, the gradient of the
function at the points in @var{x0} is approximated using central
difference.  For example, @code{gradient (@@cos, 0)} approximates the
gradient of the cosine function in the point @math{x0 = 0}.  As with
sampled data, the spacing values between the points from which the
gradient is estimated can be set via the @var{s} or @var{dx},
@var{dy}, @dots{} arguments.  By default a spacing of 1 is used.
@seealso{@ref{doc-diff,,diff}, @ref{doc-del2,,del2}}
@end deftypefn


@c data.cc
@anchor{doc-hypot}
@deftypefn {Built-in Function} {} hypot (@var{x}, @var{y})
Compute the element-by-element square root of the sum of the squares of
@var{x} and @var{y}.  This is equivalent to
@code{sqrt (@var{x}.^2 + @var{y}.^2)}, but calculated in a manner that
avoids overflows for large values of @var{x} or @var{y}.
@end deftypefn


@c ./elfun/lcm.m
@anchor{doc-lcm}
@deftypefn  {Mapping Function} {} lcm (@var{x})
@deftypefnx {Mapping Function} {} lcm (@var{x}, @dots{})
Compute the least common multiple of the elements of @var{x}, or
of the list of all arguments.  For example,

@example
lcm (a1, @dots{}, ak)
@end example

@noindent
is the same as

@example
lcm ([a1, @dots{}, ak]).
@end example

All elements must be the same size or scalar.
@seealso{@ref{doc-factor,,factor}, @ref{doc-gcd,,gcd}}
@end deftypefn


@c ./miscellaneous/list_primes.m
@anchor{doc-list_primes}
@deftypefn {Function File} {} list_primes (@var{n})
List the first @var{n} primes.  If @var{n} is unspecified, the first
25 primes are listed.

The algorithm used is from page 218 of the @TeX{}book.
@seealso{@ref{doc-primes,,primes}, @ref{doc-isprime,,isprime}}
@end deftypefn


@c ./DLD-FUNCTIONS/max.cc
@anchor{doc-max}
@deftypefn  {Loadable Function} {} max (@var{x})
@deftypefnx {Loadable Function} {} max (@var{x}, @var{y})
@deftypefnx {Loadable Function} {} max (@var{x}, @var{y}, @var{dim})
@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} max (@var{x})
For a vector argument, return the maximum value.  For a matrix
argument, return the maximum value from each column, as a row
vector, or over the dimension @var{dim} if defined.  For two matrices
(or a matrix and scalar), return the pair-wise maximum.
Thus,

@example
max (max (@var{x}))
@end example

@noindent
returns the largest element of the matrix @var{x}, and

@example
@group
max (2:5, pi)
    @result{}  3.1416  3.1416  4.0000  5.0000
@end group
@end example
@noindent
compares each element of the range @code{2:5} with @code{pi}, and
returns a row vector of the maximum values.

For complex arguments, the magnitude of the elements are used for
comparison.

If called with one input and two output arguments,
@code{max} also returns the first index of the
maximum value(s).  Thus,

@example
@group
[x, ix] = max ([1, 3, 5, 2, 5])
    @result{}  x = 5
        ix = 3
@end group
@end example
@seealso{@ref{doc-min,,min}, @ref{doc-cummax,,cummax}, @ref{doc-cummin,,cummin}}
@end deftypefn


@c ./DLD-FUNCTIONS/max.cc
@anchor{doc-min}
@deftypefn  {Loadable Function} {} min (@var{x})
@deftypefnx {Loadable Function} {} min (@var{x}, @var{y})
@deftypefnx {Loadable Function} {} min (@var{x}, @var{y}, @var{dim})
@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} min (@var{x})
For a vector argument, return the minimum value.  For a matrix
argument, return the minimum value from each column, as a row
vector, or over the dimension @var{dim} if defined.  For two matrices
(or a matrix and scalar), return the pair-wise minimum.
Thus,

@example
min (min (@var{x}))
@end example

@noindent
returns the smallest element of @var{x}, and

@example
@group
min (2:5, pi)
    @result{}  2.0000  3.0000  3.1416  3.1416
@end group
@end example
@noindent
compares each element of the range @code{2:5} with @code{pi}, and
returns a row vector of the minimum values.

For complex arguments, the magnitude of the elements are used for
comparison.

If called with one input and two output arguments,
@code{min} also returns the first index of the
minimum value(s).  Thus,

@example
@group
[x, ix] = min ([1, 3, 0, 2, 0])
    @result{}  x = 0
        ix = 3
@end group
@end example
@seealso{@ref{doc-max,,max}, @ref{doc-cummin,,cummin}, @ref{doc-cummax,,cummax}}
@end deftypefn


@c ./DLD-FUNCTIONS/max.cc
@anchor{doc-cummax}
@deftypefn  {Loadable Function} {} cummax (@var{x})
@deftypefnx {Loadable Function} {} cummax (@var{x}, @var{dim})
@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummax (@var{x})
Return the cumulative maximum values along dimension @var{dim}.  If @var{dim}
is unspecified it defaults to column-wise operation.  For example,

@example
@group
cummax ([1 3 2 6 4 5])
    @result{}  1  3  3  6  6  6
@end group
@end example

The call
@example
[w, iw] = cummax (x, dim)
@end example

@noindent
is equivalent to the following code:
@example
@group
w = iw = zeros (size (x));
idxw = idxx = repmat (@{':'@}, 1, ndims (x));
for i = 1:size (x, dim)
  idxw@{dim@} = i; idxx@{dim@} = 1:i;
  [w(idxw@{:@}), iw(idxw@{:@})] = max(x(idxx@{:@}), [], dim);
endfor
@end group
@end example

@noindent
but computed in a much faster manner.
@seealso{@ref{doc-cummin,,cummin}, @ref{doc-max,,max}, @ref{doc-min,,min}}
@end deftypefn


@c ./DLD-FUNCTIONS/max.cc
@anchor{doc-cummin}
@deftypefn  {Loadable Function} {} cummin (@var{x})
@deftypefnx {Loadable Function} {} cummin (@var{x}, @var{dim})
@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummin (@var{x})
Return the cumulative minimum values along dimension @var{dim}.  If @var{dim}
is unspecified it defaults to column-wise operation.  For example,

@example
@group
cummin ([5 4 6 2 3 1])
    @result{}  5  4  4  2  2  1
@end group
@end example


The call
@example
  [w, iw] = cummin (x, dim)
@end example

@noindent
is equivalent to the following code:
@example
@group
w = iw = zeros (size (x));
idxw = idxx = repmat (@{':'@}, 1, ndims (x));
for i = 1:size (x, dim)
  idxw@{dim@} = i; idxx@{dim@} = 1:i;
  [w(idxw@{:@}), iw(idxw@{:@})] = min(x(idxx@{:@}), [], dim);
endfor
@end group
@end example

@noindent
but computed in a much faster manner.
@seealso{@ref{doc-cummax,,cummax}, @ref{doc-min,,min}, @ref{doc-max,,max}}
@end deftypefn


@c ./general/mod.m
@anchor{doc-mod}
@deftypefn {Mapping Function} {} mod (@var{x}, @var{y})
Compute the modulo of @var{x} and @var{y}.  Conceptually this is given by

@example
x - y .* floor (x ./ y)
@end example

and is written such that the correct modulus is returned for
integer types.  This function handles negative values correctly.  That
is, @code{mod (-1, 3)} is 2, not -1, as @code{rem (-1, 3)} returns.
@code{mod (@var{x}, 0)} returns @var{x}.

An error results if the dimensions of the arguments do not agree, or if
either of the arguments is complex.
@seealso{@ref{doc-rem,,rem}, @ref{doc-fmod,,fmod}}
@end deftypefn


@c ./specfun/primes.m
@anchor{doc-primes}
@deftypefn {Function File} {} primes (@var{n})

Return all primes up to @var{n}.  

The algorithm used is the Sieve of Erastothenes.

Note that if you need a specific number of primes you can use the
fact the distance from one prime to the next is, on average,
proportional to the logarithm of the prime.  Integrating, one finds
that there are about @math{k} primes less than
@tex
$k \log (5 k)$.
@end tex
@ifnottex
k*log(5*k).
@end ifnottex
@seealso{@ref{doc-list_primes,,list_primes}, @ref{doc-isprime,,isprime}}
@end deftypefn


@c ./general/rem.m
@anchor{doc-rem}
@deftypefn {Mapping Function} {} rem (@var{x}, @var{y})
Return the remainder of the division @code{@var{x} / @var{y}}, computed 
using the expression

@example
x - y .* fix (x ./ y)
@end example

An error message is printed if the dimensions of the arguments do not
agree, or if either of the arguments is complex.
@seealso{@ref{doc-mod,,mod}, @ref{doc-fmod,,fmod}}
@end deftypefn


@c mappers.cc
@anchor{doc-round}
@deftypefn {Mapping Function} {} round (@var{x})
Return the integer nearest to @var{x}.  If @var{x} is complex, return
@code{round (real (@var{x})) + round (imag (@var{x})) * I}.
@example
@group
round ([-2.7, 2.7])
     @result{} -3   3
@end group
@end example
@seealso{@ref{doc-ceil,,ceil}, @ref{doc-floor,,floor}, @ref{doc-fix,,fix}}
@end deftypefn


@c mappers.cc
@anchor{doc-roundb}
@deftypefn {Mapping Function} {} roundb (@var{x})
Return the integer nearest to @var{x}.  If there are two nearest
integers, return the even one (banker's rounding).  If @var{x} is complex,
return @code{roundb (real (@var{x})) + roundb (imag (@var{x})) * I}.
@seealso{@ref{doc-round,,round}}
@end deftypefn


@c mappers.cc
@anchor{doc-sign}
@deftypefn {Mapping Function} {} sign (@var{x})
Compute the @dfn{signum} function, which is defined as
@tex
$$
{\rm sign} (@var{x}) = \cases{1,&$x>0$;\cr 0,&$x=0$;\cr -1,&$x<0$.\cr}
$$
@end tex
@ifnottex

@example
@group
           -1, x < 0;
sign (x) =  0, x = 0;
            1, x > 0.
@end group
@end example
@end ifnottex

For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.
@end deftypefn


@node Special Functions
@section Special Functions

@c ./DLD-FUNCTIONS/besselj.cc
@anchor{doc-airy}
@deftypefn {Loadable Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})
Compute Airy functions of the first and second kind, and their
derivatives.

@example
@group
 K   Function   Scale factor (if 'opt' is supplied)
---  --------   ---------------------------------------
 0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
 1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
 2   Bi (Z)     exp (-abs (real ((2/3) * Z *sqrt (Z))))
 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z *sqrt (Z))))
@end group
@end example

The function call @code{airy (@var{z})} is equivalent to
@code{airy (0, @var{z})}.

The result is the same size as @var{z}.

If requested, @var{ierr} contains the following status information and
is the same size as the result.

@enumerate 0
@item
Normal return.
@item
Input error, return @code{NaN}.
@item
Overflow, return @code{Inf}.
@item
Loss of significance by argument reduction results in less than half
 of machine accuracy.
@item
Complete loss of significance by argument reduction, return @code{NaN}.
@item
Error---no computation, algorithm termination condition not met,
return @code{NaN}.
@end enumerate
@end deftypefn


@c ./DLD-FUNCTIONS/besselj.cc
@anchor{doc-besselj}
@deftypefn {Loadable Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})
@deftypefnx {Loadable Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})
@deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})
@deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})
@deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})
Compute Bessel or Hankel functions of various kinds:

@table @code
@item besselj
Bessel functions of the first kind.  If the argument @var{opt} is supplied, 
the result is multiplied by @code{exp(-abs(imag(x)))}.
@item bessely
Bessel functions of the second kind.  If the argument @var{opt} is supplied,
the result is multiplied by @code{exp(-abs(imag(x)))}.
@item besseli
Modified Bessel functions of the first kind.  If the argument @var{opt} is supplied,
the result is multiplied by @code{exp(-abs(real(x)))}.
@item besselk
Modified Bessel functions of the second kind.  If the argument @var{opt} is supplied,
the result is multiplied by @code{exp(x)}.
@item besselh
Compute Hankel functions of the first (@var{k} = 1) or second (@var{k}
= 2) kind.  If the argument @var{opt} is supplied, the result is multiplied by
@code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for
@var{k} = 2.
@end table

If @var{alpha} is a scalar, the result is the same size as @var{x}.
If @var{x} is a scalar, the result is the same size as @var{alpha}.
If @var{alpha} is a row vector and @var{x} is a column vector, the
result is a matrix with @code{length (@var{x})} rows and
@code{length (@var{alpha})} columns.  Otherwise, @var{alpha} and
@var{x} must conform and the result will be the same size.

The value of @var{alpha} must be real.  The value of @var{x} may be
complex.

If requested, @var{ierr} contains the following status information
and is the same size as the result.

@enumerate 0
@item
Normal return.
@item
Input error, return @code{NaN}.
@item
Overflow, return @code{Inf}.
@item
Loss of significance by argument reduction results in less than
half of machine accuracy.
@item
Complete loss of significance by argument reduction, return @code{NaN}.
@item
Error---no computation, algorithm termination condition not met,
return @code{NaN}.
@end enumerate
@end deftypefn


@c ./specfun/beta.m
@anchor{doc-beta}
@deftypefn {Mapping Function} {} beta (@var{a}, @var{b})
For real inputs, return the Beta function,
@tex
$$
 B (a, b) = {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
$$
@end tex
@ifnottex

@example
beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
@end example
@end ifnottex
@end deftypefn


@c ./DLD-FUNCTIONS/betainc.cc
@anchor{doc-betainc}
@deftypefn {Mapping Function} {} betainc (@var{x}, @var{a}, @var{b})
Return the incomplete Beta function,
@iftex
@tex
$$
 \beta (x, a, b) = B (a, b)^{-1} \int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.
$$
@end tex
@end iftex
@ifnottex

@c Set example in small font to prevent overfull line
@smallexample
                                      x
                                     /
betainc (x, a, b) = beta (a, b)^(-1) | t^(a-1) (1-t)^(b-1) dt.
                                     /
                                  t=0
@end smallexample
@end ifnottex

If x has more than one component, both @var{a} and @var{b} must be
scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of
compatible dimensions.
@end deftypefn


@c ./specfun/betaln.m
@anchor{doc-betaln}
@deftypefn {Mapping Function} {} betaln (@var{a}, @var{b})
Return the log of the Beta function,
@tex
$$
 B (a, b) = \log {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
$$
@end tex
@ifnottex

@example
betaln (a, b) = gammaln (a) + gammaln (b) - gammaln (a + b)
@end example
@end ifnottex
@seealso{@ref{doc-beta,,beta}, @ref{doc-betainc,,betainc}, @ref{doc-gammaln,,gammaln}}
@end deftypefn


@c ./miscellaneous/bincoeff.m
@anchor{doc-bincoeff}
@deftypefn {Mapping Function} {} bincoeff (@var{n}, @var{k})
Return the binomial coefficient of @var{n} and @var{k}, defined as
@tex
$$
 {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
$$
@end tex
@ifnottex

@example
@group
 /   \
 | n |    n (n-1) (n-2) @dots{} (n-k+1)
 |   |  = -------------------------
 | k |               k!
 \   /
@end group
@end example
@end ifnottex

For example,

@example
@group
bincoeff (5, 2)
     @result{} 10
@end group
@end example

In most cases, the @code{nchoosek} function is faster for small
scalar integer arguments.  It also warns about loss of precision for
big arguments.

@seealso{@ref{doc-nchoosek,,nchoosek}}
@end deftypefn


@c ./linear-algebra/commutation_matrix.m
@anchor{doc-commutation_matrix}
@deftypefn {Function File} {} commutation_matrix (@var{m}, @var{n})
Return the commutation matrix
@tex
 $K_{m,n}$
@end tex
@ifnottex
 K(m,n)
@end ifnottex
 which is the unique
@tex
 $m n \times m n$
@end tex
@ifnottex
@var{m}*@var{n} by @var{m}*@var{n}
@end ifnottex
 matrix such that
@tex
 $K_{m,n} \cdot {\rm vec} (A) = {\rm vec} (A^T)$
@end tex
@ifnottex
@math{K(m,n) * vec(A) = vec(A')}
@end ifnottex
 for all
@tex
 $m\times n$
@end tex
@ifnottex
@math{m} by @math{n}
@end ifnottex
 matrices
@tex
 $A$.
@end tex
@ifnottex
@math{A}.
@end ifnottex

If only one argument @var{m} is given,
@tex
 $K_{m,m}$
@end tex
@ifnottex
@math{K(m,m)}
@end ifnottex
 is returned.

See Magnus and Neudecker (1988), Matrix differential calculus with
applications in statistics and econometrics.
@end deftypefn


@c ./linear-algebra/duplication_matrix.m
@anchor{doc-duplication_matrix}
@deftypefn {Function File} {} duplication_matrix (@var{n})
Return the duplication matrix
@tex
 $D_n$
@end tex
@ifnottex
@math{Dn}
@end ifnottex
 which is the unique
@tex
 $n^2 \times n(n+1)/2$
@end tex
@ifnottex
@math{n^2} by @math{n*(n+1)/2}
@end ifnottex
 matrix such that
@tex
 $D_n * {\rm vech} (A) = {\rm vec} (A)$
@end tex
@ifnottex
@math{Dn vech (A) = vec (A)}
@end ifnottex
 for all symmetric
@tex
 $n \times n$
@end tex
@ifnottex
@math{n} by @math{n}
@end ifnottex
 matrices
@tex
 $A$.
@end tex
@ifnottex
@math{A}.
@end ifnottex

See Magnus and Neudecker (1988), Matrix differential calculus with
applications in statistics and econometrics.
@end deftypefn


@c mappers.cc
@anchor{doc-erf}
@deftypefn {Mapping Function} {} erf (@var{z})
Computes the error function,
@iftex
@tex
$$
 {\rm erf} (z) = {2 \over \sqrt{\pi}}\int_0^z e^{-t^2} dt
$$
@end tex
@end iftex
@ifnottex

@example
@group
                         z
                        /
erf (z) = (2/sqrt (pi)) | e^(-t^2) dt
                        /
                     t=0
@end group
@end example
@end ifnottex
@seealso{@ref{doc-erfc,,erfc}, @ref{doc-erfinv,,erfinv}}
@end deftypefn


@c mappers.cc
@anchor{doc-erfc}
@deftypefn {Mapping Function} {} erfc (@var{z})
Computes the complementary error function,
@iftex
@tex
$1 - {\rm erf} (z)$.
@end tex
@end iftex
@ifnottex
@code{1 - erf (@var{z})}.
@end ifnottex
@seealso{@ref{doc-erf,,erf}, @ref{doc-erfinv,,erfinv}}
@end deftypefn


@c ./specfun/erfinv.m
@anchor{doc-erfinv}
@deftypefn {Mapping Function} {} erfinv (@var{z})
Computes the inverse of the error function.
@seealso{@ref{doc-erf,,erf}, @ref{doc-erfc,,erfc}}
@end deftypefn


@c mappers.cc
@anchor{doc-gamma}
@deftypefn {Mapping Function} {} gamma (@var{z})
Computes the Gamma function,
@iftex
@tex
$$
 \Gamma (z) = \int_0^\infty t^{z-1} e^{-t} dt.
$$
@end tex
@end iftex
@ifnottex

@example
@group
            infinity
            /
gamma (z) = | t^(z-1) exp (-t) dt.
            /
         t=0
@end group
@end example
@end ifnottex
@seealso{@ref{doc-gammainc,,gammainc}, @ref{doc-lgamma,,lgamma}}
@end deftypefn


@c ./DLD-FUNCTIONS/gammainc.cc
@anchor{doc-gammainc}
@deftypefn {Mapping Function} {} gammainc (@var{x}, @var{a})
Compute the normalized incomplete gamma function,
@iftex
@tex
$$
 \gamma (x, a) = {\displaystyle\int_0^x e^{-t} t^{a-1} dt \over \Gamma (a)}
$$
@end tex
@end iftex
@ifnottex

@smallexample
                                x
                      1        /
gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                  gamma (a)    /
                            t=0
@end smallexample

@end ifnottex
with the limiting value of 1 as @var{x} approaches infinity.
The standard notation is @math{P(a,x)}, e.g., Abramowitz and Stegun (6.5.1).

If @var{a} is scalar, then @code{gammainc (@var{x}, @var{a})} is returned
for each element of @var{x} and vice versa.

If neither @var{x} nor @var{a} is scalar, the sizes of @var{x} and
@var{a} must agree, and @var{gammainc} is applied element-by-element.
@seealso{@ref{doc-gamma,,gamma}, @ref{doc-lgamma,,lgamma}}
@end deftypefn


@c ./specfun/legendre.m
@anchor{doc-legendre}
@deftypefn {Function File} {@var{l} =} legendre (@var{n}, @var{x})
@deftypefnx {Function File} {@var{l} =} legendre (@var{n}, @var{x}, @var{normalization})
Compute the Legendre function of degree @var{n} and order 
@var{m} = 0 @dots{} N.  The optional argument, @var{normalization}, 
may be one of @code{"unnorm"}, @code{"sch"}, or @code{"norm"}.
The default is @code{"unnorm"}.  The value of @var{n} must be a 
non-negative scalar integer.  

If the optional argument @var{normalization} is missing or is
@code{"unnorm"}, compute the Legendre function of degree @var{n} and
order @var{m} and return all values for @var{m} = 0 @dots{} @var{n}.
The return value has one dimension more than @var{x}.

The Legendre Function of degree @var{n} and order @var{m}:

@example
@group
 m        m       2  m/2   d^m
P(x) = (-1) * (1-x  )    * ----  P (x)
 n                         dx^m   n
@end group
@end example

@noindent
with Legendre polynomial of degree @var{n}:

@example
@group
          1     d^n   2    n
P (x) = ------ [----(x - 1)  ]
 n      2^n n!  dx^n
@end group
@end example

@noindent
@code{legendre (3, [-1.0, -0.9, -0.8])} returns the matrix:

@example
@group
 x  |   -1.0   |   -0.9   |  -0.8
------------------------------------
m=0 | -1.00000 | -0.47250 | -0.08000
m=1 |  0.00000 | -1.99420 | -1.98000
m=2 |  0.00000 | -2.56500 | -4.32000
m=3 |  0.00000 | -1.24229 | -3.24000 
@end group
@end example

If the optional argument @code{normalization} is @code{"sch"}, 
compute the Schmidt semi-normalized associated Legendre function.
The Schmidt semi-normalized associated Legendre function is related
to the unnormalized Legendre functions by the following:

For Legendre functions of degree n and order 0:

@example
@group
  0       0
SP (x) = P (x)
  n       n
@end group
@end example

For Legendre functions of degree n and order m:

@example
@group
  m       m          m    2(n-m)! 0.5
SP (x) = P (x) * (-1)  * [-------]
  n       n               (n+m)!
@end group
@end example

If the optional argument @var{normalization} is @code{"norm"}, 
compute the fully normalized associated Legendre function.
The fully normalized associated Legendre function is related
to the unnormalized Legendre functions by the following:

For Legendre functions of degree @var{n} and order @var{m}

@example
@group
  m       m          m    (n+0.5)(n-m)! 0.5
NP (x) = P (x) * (-1)  * [-------------]
  n       n                   (n+m)!    
@end group
@end example
@end deftypefn


@anchor{doc-gammaln}
@c mappers.cc
@anchor{doc-lgamma}
@deftypefn {Mapping Function} {} lgamma (@var{x})
@deftypefnx {Mapping Function} {} gammaln (@var{x})
Return the natural logarithm of the gamma function of @var{x}.
@seealso{@ref{doc-gamma,,gamma}, @ref{doc-gammainc,,gammainc}}
@end deftypefn


@node Coordinate Transformations
@section Coordinate Transformations

@c ./general/cart2pol.m
@anchor{doc-cart2pol}
@deftypefn  {Function File} {[@var{theta}, @var{r}] =} cart2pol (@var{x}, @var{y})
@deftypefnx {Function File} {[@var{theta}, @var{r}, @var{z}] =} cart2pol (@var{x}, @var{y}, @var{z})
Transform Cartesian to polar or cylindrical coordinates.
@var{x}, @var{y} (and @var{z}) must be the same shape, or scalar.
@var{theta} describes the angle relative to the positive x-axis.
@var{r} is the distance to the z-axis (0, 0, z).
@seealso{@ref{doc-pol2cart,,pol2cart}, @ref{doc-cart2sph,,cart2sph}, @ref{doc-sph2cart,,sph2cart}}
@end deftypefn


@c ./general/pol2cart.m
@anchor{doc-pol2cart}
@deftypefn {Function File} {[@var{x}, @var{y}] =} pol2cart (@var{theta}, @var{r})
@deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} pol2cart (@var{theta}, @var{r}, @var{z})
Transform polar or cylindrical to Cartesian coordinates.
@var{theta}, @var{r} (and @var{z}) must be the same shape, or scalar.
@var{theta} describes the angle relative to the positive x-axis.
@var{r} is the distance to the z-axis (0, 0, z).
@seealso{@ref{doc-cart2pol,,cart2pol}, @ref{doc-cart2sph,,cart2sph}, @ref{doc-sph2cart,,sph2cart}}
@end deftypefn


@c ./general/cart2sph.m
@anchor{doc-cart2sph}
@deftypefn {Function File} {[@var{theta}, @var{phi}, @var{r}] =} cart2sph (@var{x}, @var{y}, @var{z})
Transform Cartesian to spherical coordinates.
@var{x}, @var{y} and @var{z} must be the same shape, or scalar.
@var{theta} describes the angle relative to the positive x-axis.
@var{phi} is the angle relative to the xy-plane.
@var{r} is the distance to the origin (0, 0, 0).
@seealso{@ref{doc-pol2cart,,pol2cart}, @ref{doc-cart2pol,,cart2pol}, @ref{doc-sph2cart,,sph2cart}}
@end deftypefn


@c ./general/sph2cart.m
@anchor{doc-sph2cart}
@deftypefn {Function File} {[@var{x}, @var{y}, @var{z}] =} sph2cart (@var{theta}, @var{phi}, @var{r})
Transform spherical to Cartesian coordinates.
@var{x}, @var{y} and @var{z} must be the same shape, or scalar.
@var{theta} describes the angle relative to the positive x-axis.
@var{phi} is the angle relative to the xy-plane.
@var{r} is the distance to the origin (0, 0, 0).
@seealso{@ref{doc-pol2cart,,pol2cart}, @ref{doc-cart2pol,,cart2pol}, @ref{doc-cart2sph,,cart2sph}}
@end deftypefn


@node Mathematical Constants
@section Mathematical Constants

@c data.cc
@anchor{doc-e}
@deftypefn  {Built-in Function} {} e
@deftypefnx {Built-in Function} {} e (@var{n})
@deftypefnx {Built-in Function} {} e (@var{n}, @var{m})
@deftypefnx {Built-in Function} {} e (@var{n}, @var{m}, @var{k}, @dots{})
@deftypefnx {Built-in Function} {} e (@dots{}, @var{class})
Return a scalar, matrix, or N-dimensional array whose elements are all equal
to the base of natural logarithms.  The constant
@tex
$e$ satisfies the equation $\log (e) = 1$.
@end tex
@ifnottex
@samp{e} satisfies the equation @code{log} (e) = 1.
@end ifnottex

When called with no arguments, return a scalar with the value @math{e}.  When
called with a single argument, return a square matrix with the dimension
specified.  When called with more than one scalar argument the first two
arguments are taken as the number of rows and columns and any further
arguments specify additional matrix dimensions.
The optional argument @var{class} specifies the return type and may be
either "double" or "single".
@end deftypefn


@c data.cc
@anchor{doc-pi}
@deftypefn  {Built-in Function} {} pi
@deftypefnx {Built-in Function} {} pi (@var{n})
@deftypefnx {Built-in Function} {} pi (@var{n}, @var{m})
@deftypefnx {Built-in Function} {} pi (@var{n}, @var{m}, @var{k}, @dots{})
@deftypefnx {Built-in Function} {} pi (@dots{}, @var{class})
Return a scalar, matrix, or N-dimensional array whose elements are all equal
to the ratio of the circumference of a circle to its
@tex
diameter($\pi$).
@end tex
@ifnottex
diameter.
@end ifnottex
Internally, @code{pi} is computed as @samp{4.0 * atan (1.0)}.

When called with no arguments, return a scalar with the value of
@tex
$\pi$.
@end tex
@ifnottex
pi.
@end ifnottex
When called with a single argument, return a square matrix with the dimension
specified.  When called with more than one scalar argument the first two
arguments are taken as the number of rows and columns and any further
arguments specify additional matrix dimensions.
The optional argument @var{class} specifies the return type and may be
either "double" or "single".
@end deftypefn


@c data.cc
@anchor{doc-I}
@deftypefn  {Built-in Function} {} I
@deftypefnx {Built-in Function} {} I (@var{n})
@deftypefnx {Built-in Function} {} I (@var{n}, @var{m})
@deftypefnx {Built-in Function} {} I (@var{n}, @var{m}, @var{k}, @dots{})
@deftypefnx {Built-in Function} {} I (@dots{}, @var{class})
Return a scalar, matrix, or N-dimensional array whose elements are all equal
to the pure imaginary unit, defined as
@tex
$\sqrt{-1}$.
@end tex
@ifnottex
@code{sqrt (-1)}.
@end ifnottex
 I, and its equivalents i, J, and j, are functions so any of the names may
be reused for other purposes (such as i for a counter variable).

When called with no arguments, return a scalar with the value @math{i}.  When
called with a single argument, return a square matrix with the dimension
specified.  When called with more than one scalar argument the first two
arguments are taken as the number of rows and columns and any further
arguments specify additional matrix dimensions.
The optional argument @var{class} specifies the return type and may be
either "double" or "single".
@end deftypefn


@c data.cc
@anchor{doc-Inf}
@deftypefn  {Built-in Function} {} Inf
@deftypefnx {Built-in Function} {} Inf (@var{n})
@deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m})
@deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m}, @var{k}, @dots{})
@deftypefnx {Built-in Function} {} Inf (@dots{}, @var{class})
Return a scalar, matrix or N-dimensional array whose elements are all equal
to the IEEE representation for positive infinity.

Infinity is produced when results are too large to be represented using the
the IEEE floating point format for numbers.  Two common examples which
produce infinity are division by zero and overflow.
@example
@group
[1/0 e^800]
@result{}
Inf   Inf
@end group
@end example

When called with no arguments, return a scalar with the value @samp{Inf}.
When called with a single argument, return a square matrix with the dimension
specified.  When called with more than one scalar argument the first two
arguments are taken as the number of rows and columns and any further
arguments specify additional matrix dimensions.
The optional argument @var{class} specifies the return type and may be
either "double" or "single".
@seealso{@ref{doc-isinf,,isinf}}
@end deftypefn


@c data.cc
@anchor{doc-NaN}
@deftypefn  {Built-in Function} {} NaN
@deftypefnx {Built-in Function} {} NaN (@var{n})
@deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m})
@deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m}, @var{k}, @dots{})
@deftypefnx {Built-in Function} {} NaN (@dots{}, @var{class})
Return a scalar, matrix, or N-dimensional array whose elements are all equal
to the IEEE symbol NaN (Not a Number).
NaN is the result of operations which do not produce a well defined numerical
result.  Common operations which produce a NaN are arithmetic with infinity
@tex
($\infty - \infty$), zero divided by zero ($0/0$),
@end tex
@ifnottex
(Inf - Inf), zero divided by zero (0/0),
@end ifnottex
and any operation involving another NaN value (5 + NaN).

Note that NaN always compares not equal to NaN (NaN != NaN).  This behavior
is specified by the IEEE standard for floating point arithmetic.  To
find NaN values, use the @code{isnan} function.

When called with no arguments, return a scalar with the value @samp{NaN}.
When called with a single argument, return a square matrix with the dimension
specified.  When called with more than one scalar argument the first two
arguments are taken as the number of rows and columns and any further
arguments specify additional matrix dimensions.
The optional argument @var{class} specifies the return type and may be
either "double" or "single".
@seealso{@ref{doc-isnan,,isnan}}
@end deftypefn


@c data.cc
@anchor{doc-eps}
@deftypefn  {Built-in Function} {} eps
@deftypefnx {Built-in Function} {} eps (@var{x})
@deftypefnx {Built-in Function} {} eps (@var{n}, @var{m})
@deftypefnx {Built-in Function} {} eps (@var{n}, @var{m}, @var{k}, @dots{})
@deftypefnx {Built-in Function} {} eps (@dots{}, @var{class})
Return a scalar, matrix or N-dimensional array whose elements are all eps,
the machine precision.  More precisely, @code{eps} is the relative spacing
between any two adjacent numbers in the machine's floating point system.
This number is obviously system dependent.  On machines that support IEEE
floating point arithmetic, @code{eps} is approximately
@tex
$2.2204\times10^{-16}$ for double precision and $1.1921\times10^{-7}$
@end tex
@ifnottex
2.2204e-16 for double precision and 1.1921e-07
@end ifnottex
for single precision.

When called with no arguments, return a scalar with the value
@code{eps(1.0)}.
Given a single argument @var{x}, return the distance between @var{x} and
the next largest value.
When called with more than one argument the first two arguments are taken as
the number of rows and columns and any further
arguments specify additional matrix dimensions.
The optional argument @var{class} specifies the return type and may be
either "double" or "single".
@end deftypefn


@c data.cc
@anchor{doc-realmax}
@deftypefn  {Built-in Function} {} realmax
@deftypefnx {Built-in Function} {} realmax (@var{n})
@deftypefnx {Built-in Function} {} realmax (@var{n}, @var{m})
@deftypefnx {Built-in Function} {} realmax (@var{n}, @var{m}, @var{k}, @dots{})
@deftypefnx {Built-in Function} {} realmax (@dots{}, @var{class})
Return a scalar, matrix or N-dimensional array whose elements are all equal
to the largest floating point number that is representable.  The actual
value is system dependent.  On machines that support IEEE
floating point arithmetic, @code{realmax} is approximately
@tex
$1.7977\times10^{308}$ for double precision and $3.4028\times10^{38}$
@end tex
@ifnottex
1.7977e+308 for double precision and 3.4028e+38
@end ifnottex
for single precision.

When called with no arguments, return a scalar with the value
@code{realmax("double")}.
When called with a single argument, return a square matrix with the dimension
specified.  When called with more than one scalar argument the first two
arguments are taken as the number of rows and columns and any further
arguments specify additional matrix dimensions.
The optional argument @var{class} specifies the return type and may be
either "double" or "single".
@seealso{@ref{doc-realmin,,realmin}, @ref{doc-intmax,,intmax}, @ref{doc-bitmax,,bitmax}}
@end deftypefn


@c data.cc
@anchor{doc-realmin}
@deftypefn  {Built-in Function} {} realmin
@deftypefnx {Built-in Function} {} realmin (@var{n})
@deftypefnx {Built-in Function} {} realmin (@var{n}, @var{m})
@deftypefnx {Built-in Function} {} realmin (@var{n}, @var{m}, @var{k}, @dots{})
@deftypefnx {Built-in Function} {} realmin (@dots{}, @var{class})
Return a scalar, matrix or N-dimensional array whose elements are all equal
to the smallest normalized floating point number that is representable.
The actual value is system dependent.  On machines that support
IEEE floating point arithmetic, @code{realmin} is approximately
@tex
$2.2251\times10^{-308}$ for double precision and $1.1755\times10^{-38}$
@end tex
@ifnottex
2.2251e-308 for double precision and 1.1755e-38
@end ifnottex
for single precision.

When called with no arguments, return a scalar with the value
@code{realmin("double")}.
When called with a single argument, return a square matrix with the dimension
specified.  When called with more than one scalar argument the first two
arguments are taken as the number of rows and columns and any further
arguments specify additional matrix dimensions.
The optional argument @var{class} specifies the return type and may be
either "double" or "single".
@seealso{@ref{doc-realmax,,realmax}, @ref{doc-intmin,,intmin}}
@end deftypefn

