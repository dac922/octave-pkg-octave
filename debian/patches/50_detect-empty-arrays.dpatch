#! /bin/sh /usr/share/dpatch/dpatch-run
## 50_detect-empty-arrays.dpatch by Rafael Laboissiere <rafael@debian.org>
##
## DP: Correctly detect empty arrays.  If array is empty, return/produce
## DP: value is same size as array. 

@DPATCH@

--- octave2.9-2.9.7.orig/liboctave/mx-inlines.cc	10 Feb 2006 21:30:42 -0000	1.48
+++ octave2.9-2.9.7/iboctave/mx-inlines.cc	22 Aug 2006 18:24:17 -0000
@@ -372,24 +372,17 @@
   dim_vector dv = this->dims (); \
   int nd = this->ndims (); \
  \
-  int empty = true; \
+  int empty = false; \
  \
   for (int i = 0; i < nd; i++) \
     { \
-      if (dv(i) > 0) \
+      if (dv(i) == 0) \
         { \
-          empty = false; \
+          empty = true; \
           break; \
         } \
     } \
  \
-  if (empty) \
-    { \
-      dim_vector retval_dv (1, 1); \
-      retval.resize (retval_dv, INIT_VAL); \
-      return retval; \
-    } \
- \
   /* We need to find first non-singleton dim.  */ \
  \
   if (dim == -1) \
@@ -435,36 +428,39 @@
  \
   retval.resize (dv, INIT_VAL); \
  \
-  octave_idx_type nel = dv.numel (); \
- \
-  octave_idx_type k = 1; \
- \
-  for (octave_idx_type result_idx = 0; result_idx < nel; result_idx++) \
+  if (! empty) \
     { \
-      OCTAVE_QUIT; \
+      octave_idx_type nel = dv.numel (); \
  \
-      for (octave_idx_type j = 0; j < n_elts; j++) \
+      octave_idx_type k = 1; \
+ \
+      for (octave_idx_type result_idx = 0; result_idx < nel; result_idx++) \
 	{ \
-          OCTAVE_QUIT; \
+	  OCTAVE_QUIT; \
  \
-	  EVAL_EXPR; \
+          for (octave_idx_type j = 0; j < n_elts; j++) \
+	    { \
+              OCTAVE_QUIT; \
  \
-	  iter_idx += incr; \
-	} \
+	      EVAL_EXPR; \
  \
-      if (k == reset_at) \
-        { \
-	  base = next_base; \
-	  next_base += base_incr; \
-	  iter_idx = base; \
-	  k = 1; \
-        } \
-      else \
-	{ \
-	  base++; \
-	  iter_idx = base; \
-	  k++; \
-         } \
+	      iter_idx += incr; \
+	    } \
+ \
+          if (k == reset_at) \
+	    { \
+	      base = next_base; \
+	      next_base += base_incr; \
+	      iter_idx = base; \
+	      k = 1; \
+	    } \
+	  else \
+	    { \
+	      base++; \
+	      iter_idx = base; \
+	      k++; \
+	     } \
+	} \
     } \
  \
   retval.chop_trailing_singletons (); \
@@ -487,24 +483,17 @@
   dim_vector dv = this->dims (); \
   int nd = this->ndims (); \
  \
-  int empty = true; \
+  bool empty = false; \
  \
   for (int i = 0; i < nd; i++) \
     { \
-      if (dv(i) > 0) \
+      if (dv(i) == 0) \
         { \
-          empty = false; \
+          empty = true; \
           break; \
         } \
     } \
  \
-  if (empty) \
-    { \
-      dim_vector retval_dv (1, 1); \
-      retval.resize (retval_dv, INIT_VAL); \
-      return retval; \
-    } \
- \
   /* We need to find first non-singleton dim.  */ \
  \
   if (dim == -1) \
@@ -548,47 +537,50 @@
  \
   retval.resize (dv, INIT_VAL); \
  \
-  octave_idx_type nel = dv.numel () / n_elts; \
- \
-  octave_idx_type k = 1; \
- \
-  for (octave_idx_type i = 0; i < nel; i++) \
+  if (! empty) \
     { \
-      OCTAVE_QUIT; \
+      octave_idx_type nel = dv.numel () / n_elts; \
  \
-      ACC_TYPE prev_val = INIT_VAL; \
+      octave_idx_type k = 1; \
  \
-      for (octave_idx_type j = 0; j < n_elts; j++) \
+      for (octave_idx_type i = 0; i < nel; i++) \
 	{ \
-          OCTAVE_QUIT; \
+	  OCTAVE_QUIT; \
  \
-	  if (j == 0) \
+          ACC_TYPE prev_val = INIT_VAL; \
+ \
+	  for (octave_idx_type j = 0; j < n_elts; j++) \
 	    { \
-	      retval(iter_idx) = elem (iter_idx); \
-	      prev_val = retval(iter_idx); \
+	      OCTAVE_QUIT; \
+ \
+	      if (j == 0) \
+		{ \
+		  retval(iter_idx) = elem (iter_idx); \
+		  prev_val = retval(iter_idx); \
+		} \
+	      else \
+		{ \
+		  prev_val = prev_val OP elem (iter_idx); \
+		  retval(iter_idx) = prev_val; \
+		} \
+ \
+	      iter_idx += incr; \
 	    } \
-	  else \
+ \
+	  if (k == reset_at) \
 	    { \
-	      prev_val = prev_val OP elem (iter_idx); \
-	      retval(iter_idx) = prev_val; \
+	      base = next_base; \
+	      next_base += base_incr; \
+	      iter_idx = base; \
+	      k = 1; \
 	    } \
- \
-	  iter_idx += incr; \
+	  else \
+	    { \
+	      base++; \
+	      iter_idx = base; \
+	      k++; \
+	     } \
 	} \
- \
-      if (k == reset_at) \
-        { \
-	  base = next_base; \
-	  next_base += base_incr; \
-	  iter_idx = base; \
-	  k = 1; \
-        } \
-      else \
-	{ \
-	  base++; \
-	  iter_idx = base; \
-	  k++; \
-         } \
     } \
  \
   retval.chop_trailing_singletons (); \
