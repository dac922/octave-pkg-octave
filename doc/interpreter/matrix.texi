@c DO NOT EDIT!  Generated automatically by munge-texi.

@c Copyright (C) 1996, 1997, 2007, 2008, 2009 John W. Eaton
@c
@c This file is part of Octave.
@c
@c Octave is free software; you can redistribute it and/or modify it
@c under the terms of the GNU General Public License as published by the
@c Free Software Foundation; either version 3 of the License, or (at
@c your option) any later version.
@c 
@c Octave is distributed in the hope that it will be useful, but WITHOUT
@c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
@c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
@c for more details.
@c 
@c You should have received a copy of the GNU General Public License
@c along with Octave; see the file COPYING.  If not, see
@c <http://www.gnu.org/licenses/>.

@node Matrix Manipulation
@chapter Matrix Manipulation

There are a number of functions available for checking to see if the
elements of a matrix meet some condition, and for rearranging the
elements of a matrix.  For example, Octave can easily tell you if all
the elements of a matrix are finite, or are less than some specified
value.  Octave can also rotate the elements, extract the upper- or
lower-triangular parts, or sort the columns of a matrix.

@menu
* Finding Elements and Checking Conditions::  
* Rearranging Matrices::        
* Applying a Function to an Array::
* Special Utility Matrices::    
* Famous Matrices::             
@end menu

@node Finding Elements and Checking Conditions
@section Finding Elements and Checking Conditions

The functions @code{any} and @code{all} are useful for determining
whether any or all of the elements of a matrix satisfy some condition.
The @code{find} function is also useful in determining which elements of
a matrix meet a specified condition.

@c data.cc
@anchor{doc-any}
@deftypefn {Built-in Function} {} any (@var{x}, @var{dim})
For a vector argument, return 1 if any element of the vector is
nonzero.

For a matrix argument, return a row vector of ones and
zeros with each element indicating whether any of the elements of the
corresponding column of the matrix are nonzero.  For example,

@example
@group
any (eye (2, 4))
     @result{} [ 1, 1, 0, 0 ]
@end group
@end example

If the optional argument @var{dim} is supplied, work along dimension
@var{dim}.  For example,

@example
@group
any (eye (2, 4), 2)
     @result{} [ 1; 1 ]
@end group
@end example
@end deftypefn


@c data.cc
@anchor{doc-all}
@deftypefn {Built-in Function} {} all (@var{x}, @var{dim})
The function @code{all} behaves like the function @code{any}, except
that it returns true only if all the elements of a vector, or all the
elements along dimension @var{dim} of a matrix, are nonzero.
@end deftypefn


Since the comparison operators (@pxref{Comparison Ops}) return matrices
of ones and zeros, it is easy to test a matrix for many things, not just
whether the elements are nonzero.  For example, 

@example
@group
all (all (rand (5) < 0.9))
     @result{} 0
@end group
@end example

@noindent
tests a random 5 by 5 matrix to see if all of its elements are less
than 0.9.

Note that in conditional contexts (like the test clause of @code{if} and
@code{while} statements) Octave treats the test as if you had typed
@code{all (all (condition))}.

@c ./miscellaneous/xor.m
@anchor{doc-xor}
@deftypefn {Mapping Function} {} xor (@var{x}, @var{y})
Return the `exclusive or' of the entries of @var{x} and @var{y}.
For boolean expressions @var{x} and @var{y},
@code{xor (@var{x}, @var{y})} is true if and only if @var{x} or @var{y}
is true, but not if both @var{x} and @var{y} are true.
@end deftypefn


@c ./general/is_duplicate_entry.m
@anchor{doc-is_duplicate_entry}
@deftypefn {Function File} {} is_duplicate_entry (@var{x})
Return non-zero if any entries in @var{x} are duplicates of one
another.
@end deftypefn


@c ./general/diff.m
@anchor{doc-diff}
@deftypefn {Function File} {} diff (@var{x}, @var{k}, @var{dim})
If @var{x} is a vector of length @var{n}, @code{diff (@var{x})} is the
vector of first differences
@tex
 $x_2 - x_1, \ldots{}, x_n - x_{n-1}$.
@end tex
@ifnottex
@var{x}(2) - @var{x}(1), @dots{}, @var{x}(n) - @var{x}(n-1).
@end ifnottex

If @var{x} is a matrix, @code{diff (@var{x})} is the matrix of column
differences along the first non-singleton dimension.

The second argument is optional.  If supplied, @code{diff (@var{x},
@var{k})}, where @var{k} is a non-negative integer, returns the
@var{k}-th differences.  It is possible that @var{k} is larger than
then first non-singleton dimension of the matrix.  In this case,
@code{diff} continues to take the differences along the next
non-singleton dimension.

The dimension along which to take the difference can be explicitly
stated with the optional variable @var{dim}.  In this case the 
@var{k}-th order differences are calculated along this dimension.
In the case where @var{k} exceeds @code{size (@var{x}, @var{dim})}
then an empty matrix is returned.
@end deftypefn


@c mappers.cc
@anchor{doc-isinf}
@deftypefn {Mapping Function} {} isinf (@var{x})
Return 1 for elements of @var{x} that are infinite and zero
otherwise.  For example,

@example
@group
isinf ([13, Inf, NA, NaN])
     @result{} [ 0, 1, 0, 0 ]
@end group
@end example
@end deftypefn


@c mappers.cc
@anchor{doc-isnan}
@deftypefn {Mapping Function} {} isnan (@var{x})
Return 1 for elements of @var{x} that are NaN values and zero
otherwise.  NA values are also considered NaN values.  For example,

@example
@group
isnan ([13, Inf, NA, NaN])
     @result{} [ 0, 0, 1, 1 ]
@end group
@end example
@seealso{@ref{doc-isna,,isna}}
@end deftypefn


@c mappers.cc
@anchor{doc-finite}
@deftypefn {Mapping Function} {} finite (@var{x})
Return 1 for elements of @var{x} that are finite values and zero
otherwise.  For example,

@example
@group
finite ([13, Inf, NA, NaN])
     @result{} [ 1, 0, 0, 0 ]
@end group
@end example
@end deftypefn


@c ./DLD-FUNCTIONS/find.cc
@anchor{doc-find}
@deftypefn {Loadable Function} {} find (@var{x})
@deftypefnx {Loadable Function} {} find (@var{x}, @var{n})
@deftypefnx {Loadable Function} {} find (@var{x}, @var{n}, @var{direction})
Return a vector of indices of nonzero elements of a matrix, as a row if
@var{x} is a row or as a column otherwise.  To obtain a single index for
each matrix element, Octave pretends that the columns of a matrix form one
long vector (like Fortran arrays are stored).  For example,

@example
@group
find (eye (2))
     @result{} [ 1; 4 ]
@end group
@end example

If two outputs are requested, @code{find} returns the row and column
indices of nonzero elements of a matrix.  For example,

@example
@group
[i, j] = find (2 * eye (2))
     @result{} i = [ 1; 2 ]
     @result{} j = [ 1; 2 ]
@end group
@end example

If three outputs are requested, @code{find} also returns a vector
containing the nonzero values.  For example,

@example
@group
[i, j, v] = find (3 * eye (2))
     @result{} i = [ 1; 2 ]
     @result{} j = [ 1; 2 ]
     @result{} v = [ 3; 3 ]
@end group
@end example

If two inputs are given, @var{n} indicates the maximum number of
elements to find from the beginning of the matrix or vector.

If three inputs are given, @var{direction} should be one of "first" or
"last", requesting only the first or last @var{n} indices, respectively.
However, the indices are always returned in ascending order.

Note that this function is particularly useful for sparse matrices, as
it extracts the non-zero elements as vectors, which can then be used to
create the original matrix.  For example,

@example
@group
sz = size(a);
[i, j, v] = find (a);
b = sparse(i, j, v, sz(1), sz(2));
@end group
@end example
@seealso{@ref{doc-sparse,,sparse}}
@end deftypefn

        
@c ./general/common_size.m
@anchor{doc-common_size}
@deftypefn {Function File} {[@var{err}, @var{y1}, @dots{}] =} common_size (@var{x1}, @dots{})
Determine if all input arguments are either scalar or of common
size.  If so, @var{err} is zero, and @var{yi} is a matrix of the
common size with all entries equal to @var{xi} if this is a scalar or
@var{xi} otherwise.  If the inputs cannot be brought to a common size,
errorcode is 1, and @var{yi} is @var{xi}.  For example,

@example
@group
[errorcode, a, b] = common_size ([1 2; 3 4], 5)
     @result{} errorcode = 0
     @result{} a = [ 1, 2; 3, 4 ]
     @result{} b = [ 5, 5; 5, 5 ]
@end group
@end example

@noindent
This is useful for implementing functions where arguments can either
be scalars or of common size.
@end deftypefn


@node Rearranging Matrices
@section Rearranging Matrices

@c ./general/fliplr.m
@anchor{doc-fliplr}
@deftypefn {Function File} {} fliplr (@var{x})
Return a copy of @var{x} with the order of the columns reversed.  For
example,

@example
@group
fliplr ([1, 2; 3, 4])
     @result{}  2  1
         4  3
@end group
@end example

Note that @code{fliplr} only work with 2-D arrays.  To flip N-d arrays
use @code{flipdim} instead.
@seealso{@ref{doc-flipud,,flipud}, @ref{doc-flipdim,,flipdim}, @ref{doc-rot90,,rot90}, @ref{doc-rotdim,,rotdim}}
@end deftypefn


@c ./general/flipud.m
@anchor{doc-flipud}
@deftypefn {Function File} {} flipud (@var{x})
Return a copy of @var{x} with the order of the rows reversed.  For
example,

@example
@group
flipud ([1, 2; 3, 4])
     @result{}  3  4
         1  2
@end group
@end example

Due to the difficulty of defining which axis about which to flip the 
matrix @code{flipud} only work with 2-d arrays.  To flip N-d arrays
use @code{flipdim} instead.
@seealso{@ref{doc-fliplr,,fliplr}, @ref{doc-flipdim,,flipdim}, @ref{doc-rot90,,rot90}, @ref{doc-rotdim,,rotdim}}
@end deftypefn


@c ./general/flipdim.m
@anchor{doc-flipdim}
@deftypefn {Function File} {} flipdim (@var{x}, @var{dim})
Return a copy of @var{x} flipped about the dimension @var{dim}.
For example

@example
@group
flipdim ([1, 2; 3, 4], 2)
     @result{}  2  1
         4  3
@end group
@end example
@seealso{@ref{doc-fliplr,,fliplr}, @ref{doc-flipud,,flipud}, @ref{doc-rot90,,rot90}, @ref{doc-rotdim,,rotdim}}
@end deftypefn


@c ./general/rot90.m
@anchor{doc-rot90}
@deftypefn {Function File} {} rot90 (@var{x}, @var{n})
Return a copy of @var{x} with the elements rotated counterclockwise in
90-degree increments.  The second argument is optional, and specifies
how many 90-degree rotations are to be applied (the default value is 1).
Negative values of @var{n} rotate the matrix in a clockwise direction.
For example,

@example
@group
rot90 ([1, 2; 3, 4], -1)
     @result{}  3  1
         4  2
@end group
@end example

@noindent
rotates the given matrix clockwise by 90 degrees.  The following are all
equivalent statements:

@example
@group
rot90 ([1, 2; 3, 4], -1)
rot90 ([1, 2; 3, 4], 3)
rot90 ([1, 2; 3, 4], 7)
@end group
@end example

Due to the difficulty of defining an axis about which to rotate the 
matrix @code{rot90} only work with 2-D arrays.  To rotate N-d arrays
use @code{rotdim} instead.
@seealso{@ref{doc-rotdim,,rotdim}, @ref{doc-flipud,,flipud}, @ref{doc-fliplr,,fliplr}, @ref{doc-flipdim,,flipdim}}
@end deftypefn


@c ./general/rotdim.m
@anchor{doc-rotdim}
@deftypefn {Function File} {} rotdim (@var{x}, @var{n}, @var{plane})
Return a copy of @var{x} with the elements rotated counterclockwise in
90-degree increments.  The second argument is optional, and specifies
how many 90-degree rotations are to be applied (the default value is 1).
The third argument is also optional and defines the plane of the
rotation.  As such @var{plane} is a two element vector containing two
different valid dimensions of the matrix.  If @var{plane} is not given
Then the first two non-singleton dimensions are used.

Negative values of @var{n} rotate the matrix in a clockwise direction.
For example,

@example
@group
rotdim ([1, 2; 3, 4], -1, [1, 2])
     @result{}  3  1
         4  2
@end group
@end example

@noindent
rotates the given matrix clockwise by 90 degrees.  The following are all
equivalent statements:

@example
@group
rotdim ([1, 2; 3, 4], -1, [1, 2])
rotdim ([1, 2; 3, 4], 3, [1, 2])
rotdim ([1, 2; 3, 4], 7, [1, 2])
@end group
@end example
@seealso{@ref{doc-rot90,,rot90}, @ref{doc-flipud,,flipud}, @ref{doc-fliplr,,fliplr}, @ref{doc-flipdim,,flipdim}}
@end deftypefn


@c data.cc
@anchor{doc-cat}
@deftypefn {Built-in Function} {} cat (@var{dim}, @var{array1}, @var{array2}, @dots{}, @var{arrayN})
Return the concatenation of N-d array objects, @var{array1},
@var{array2}, @dots{}, @var{arrayN} along dimension @var{dim}.

@example
@group
A = ones (2, 2);
B = zeros (2, 2);
cat (2, A, B)
@result{} ans =

     1 1 0 0
     1 1 0 0
@end group
@end example

Alternatively, we can concatenate @var{A} and @var{B} along the
second dimension the following way:

@example
@group
[A, B].
@end group
@end example

@var{dim} can be larger than the dimensions of the N-d array objects
and the result will thus have @var{dim} dimensions as the
following example shows:
@example
@group
cat (4, ones(2, 2), zeros (2, 2))
@result{} ans =

   ans(:,:,1,1) =

     1 1
     1 1

   ans(:,:,1,2) =
     0 0
     0 0
@end group
@end example
@seealso{@ref{doc-horzcat,,horzcat}, @ref{doc-vertcat,,vertcat}}
@end deftypefn


@c data.cc
@anchor{doc-horzcat}
@deftypefn {Built-in Function} {} horzcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})
Return the horizontal concatenation of N-d array objects, @var{array1},
@var{array2}, @dots{}, @var{arrayN} along dimension 2.
@seealso{@ref{doc-cat,,cat}, @ref{doc-vertcat,,vertcat}}
@end deftypefn


@c data.cc
@anchor{doc-vertcat}
@deftypefn {Built-in Function} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})
Return the vertical concatenation of N-d array objects, @var{array1},
@var{array2}, @dots{}, @var{arrayN} along dimension 1.
@seealso{@ref{doc-cat,,cat}, @ref{doc-horzcat,,horzcat}}
@end deftypefn


@c data.cc
@anchor{doc-permute}
@deftypefn {Built-in Function} {} permute (@var{a}, @var{perm})
Return the generalized transpose for an N-d array object @var{a}.
The permutation vector @var{perm} must contain the elements
@code{1:ndims(a)} (in any order, but each element must appear just once).
@seealso{@ref{doc-ipermute,,ipermute}}
@end deftypefn


@c data.cc
@anchor{doc-ipermute}
@deftypefn {Built-in Function} {} ipermute (@var{a}, @var{iperm})
The inverse of the @code{permute} function.  The expression

@example
ipermute (permute (a, perm), perm)
@end example
returns the original array @var{a}.
@seealso{@ref{doc-permute,,permute}}
@end deftypefn


@c data.cc
@anchor{doc-reshape}
@deftypefn {Built-in Function} {} reshape (@var{a}, @var{m}, @var{n}, @dots{})
@deftypefnx {Built-in Function} {} reshape (@var{a}, @var{size})
Return a matrix with the given dimensions whose elements are taken
from the matrix @var{a}.  The elements of the matrix are accessed in
column-major order (like Fortran arrays are stored).

For example,

@example
@group
reshape ([1, 2, 3, 4], 2, 2)
     @result{}  1  3
         2  4
@end group
@end example

@noindent
Note that the total number of elements in the original
matrix must match the total number of elements in the new matrix.

A single dimension of the return matrix can be unknown and is flagged
by an empty argument.
@end deftypefn


@c data.cc
@anchor{doc-resize}
@deftypefn {Built-in Function} {} resize (@var{x}, @var{m})
@deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n})
@deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n}, @dots{})
Resize @var{x} cutting off elements as necessary.

In the result, element with certain indices is equal to the corresponding
element of @var{x} if the indices are within the bounds of @var{x};
otherwise, the element is set to zero.

In other words, the statement

@example
  y = resize (x, dv);
@end example

@noindent
is equivalent to the following code:

@example
@group
  y = zeros (dv, class (x));
  sz = min (dv, size (x));
  for i = 1:length (sz), idx@{i@} = 1:sz(i); endfor
  y(idx@{:@}) = x(idx@{:@});
@end group
@end example

@noindent
but is performed more efficiently.

If only @var{m} is supplied and it is a scalar, the dimension of the
result is @var{m}-by-@var{m}.  If @var{m} is a vector, then the
dimensions of the result are given by the elements of @var{m}.
If both @var{m} and @var{n} are scalars, then the dimensions of
the result are @var{m}-by-@var{n}.

An object can be resized to more dimensions than it has;
in such case the missing dimensions are assumed to be 1.
Resizing an object to fewer dimensions is not possible.
@seealso{@ref{doc-reshape,,reshape}, @ref{doc-postpad,,postpad}}
@end deftypefn


@c ./general/circshift.m
@anchor{doc-circshift}
@deftypefn {Function File} {@var{y} =} circshift (@var{x}, @var{n})
Circularly shifts the values of the array @var{x}.  @var{n} must be
a vector of integers no longer than the number of dimensions in 
@var{x}.  The values of @var{n} can be either positive or negative,
which determines the direction in which the values or @var{x} are
shifted.  If an element of @var{n} is zero, then the corresponding
dimension of @var{x} will not be shifted.  For example

@example
@group
x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
circshift (x, 1)
@result{}  7, 8, 9
    1, 2, 3
    4, 5, 6
circshift (x, -2)
@result{}  7, 8, 9
    1, 2, 3
    4, 5, 6
circshift (x, [0,1])
@result{}  3, 1, 2
    6, 4, 5
    9, 7, 8
@end group
@end example
@seealso {permute, ipermute, shiftdim}
@end deftypefn


@c ./general/shiftdim.m
@anchor{doc-shiftdim}
@deftypefn {Function File} {@var{y} =} shiftdim (@var{x}, @var{n})
@deftypefnx {Function File} {[@var{y}, @var{ns}] =} shiftdim (@var{x})
Shifts the dimension of @var{x} by @var{n}, where @var{n} must be
an integer scalar.  When @var{n} is positive, the dimensions of
@var{x} are shifted to the left, with the leading dimensions
circulated to the end.  If @var{n} is negative, then the dimensions
of @var{x} are shifted to the right, with @var{n} leading singleton
dimensions added.

Called with a single argument, @code{shiftdim}, removes the leading
singleton dimensions, returning the number of dimensions removed
in the second output argument @var{ns}.

For example 

@example
@group
x = ones (1, 2, 3);
size (shiftdim (x, -1))
     @result{} [1, 1, 2, 3]
size (shiftdim (x, 1))
     @result{} [2, 3]
[b, ns] = shiftdim (x);
     @result{} b =  [1, 1, 1; 1, 1, 1]
     @result{} ns = 1
@end group
@end example
@seealso {reshape, permute, ipermute, circshift, squeeze}
@end deftypefn


@c ./general/shift.m
@anchor{doc-shift}
@deftypefn {Function File} {} shift (@var{x}, @var{b})
@deftypefnx {Function File} {} shift (@var{x}, @var{b}, @var{dim})
If @var{x} is a vector, perform a circular shift of length @var{b} of
the elements of @var{x}.

If @var{x} is a matrix, do the same for each column of @var{x}.
If the optional @var{dim} argument is given, operate along this 
dimension
@end deftypefn


@c data.cc
@anchor{doc-sort}
@deftypefn {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x})
@deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim})
@deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{mode})
@deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim}, @var{mode})
Return a copy of @var{x} with the elements arranged in increasing
order.  For matrices, @code{sort} orders the elements in each column.

For example,

@example
@group
sort ([1, 2; 2, 3; 3, 1])
     @result{}  1  1
         2  2
         3  3
@end group
@end example

The @code{sort} function may also be used to produce a matrix
containing the original row indices of the elements in the sorted
matrix.  For example,

@example
@group
[s, i] = sort ([1, 2; 2, 3; 3, 1])
     @result{} s = 1  1
            2  2
            3  3
     @result{} i = 1  3
            2  1
            3  2
@end group
@end example

If the optional argument @var{dim} is given, then the matrix is sorted
along the dimension defined by @var{dim}.  The optional argument @code{mode}
defines the order in which the values will be sorted.  Valid values of
@code{mode} are `ascend' or `descend'.

For equal elements, the indices are such that the equal elements are listed
in the order that appeared in the original list.

The @code{sort} function may also be used to sort strings and cell arrays
of strings, in which case the dictionary order of the strings is used.

The algorithm used in @code{sort} is optimized for the sorting of partially
ordered lists.
@end deftypefn


@c ./general/sortrows.m
@anchor{doc-sortrows}
@deftypefn {Function File} {} sortrows (@var{a}, @var{c})
Sort the rows of the matrix @var{a} according to the order of the
columns specified in @var{c}.  If @var{c} is omitted, a
lexicographical sort is used.  By default ascending order is used 
however if elements of @var{c} are negative then the corresponding  
column is sorted in descending order.
@end deftypefn


@c data.cc
@anchor{doc-issorted}
@deftypefn {Built-in Function} {} issorted (@var{a}, @var{rows})
Returns true if the array is sorted, ascending or descending.
NaNs are treated as by @code{sort}.  If @var{rows} is supplied and
has the value "rows", checks whether the array is sorted by rows
as if output by @code{sortrows} (with no options).

This function does not yet support sparse matrices.
@seealso{@ref{doc-sortrows,,sortrows}, @ref{doc-sort,,sort}}
@end deftypefn



Since the @code{sort} function does not allow sort keys to be specified,
it can't be used to order the rows of a matrix according to the values
of the elements in various columns@footnote{For example, to first sort
based on the values in column 1, and then, for any values that are
repeated in column 1, sort based on the values found in column 2, etc.}
in a single call.  Using the second output, however, it is possible to
sort all rows based on the values in a given column.  Here's an example
that sorts the rows of a matrix based on the values in the second
column.

@example
@group
a = [1, 2; 2, 3; 3, 1];
[s, i] = sort (a (:, 2));
a (i, :)
     @result{}  3  1
         1  2
         2  3
@end group
@end example

@anchor{doc-triu}
@c ./general/tril.m
@anchor{doc-tril}
@deftypefn {Function File} {} tril (@var{a}, @var{k})
@deftypefnx {Function File} {} triu (@var{a}, @var{k})
Return a new matrix formed by extracting the lower (@code{tril})
or upper (@code{triu}) triangular part of the matrix @var{a}, and
setting all other elements to zero.  The second argument is optional,
and specifies how many diagonals above or below the main diagonal should
also be set to zero.

The default value of @var{k} is zero, so that @code{triu} and
@code{tril} normally include the main diagonal as part of the result
matrix.

If the value of @var{k} is negative, additional elements above (for
@code{tril}) or below (for @code{triu}) the main diagonal are also
selected.

The absolute value of @var{k} must not be greater than the number of
sub- or super-diagonals.

For example,

@example
@group
tril (ones (3), -1)
     @result{}  0  0  0
         1  0  0
         1  1  0
@end group
@end example

@noindent
and

@example
@group
tril (ones (3), 1)
     @result{}  1  1  0
         1  1  1
         1  1  1
@end group
@end example
@seealso{@ref{doc-triu,,triu}, @ref{doc-diag,,diag}}
@end deftypefn


@c ./linear-algebra/vec.m
@anchor{doc-vec}
@deftypefn {Function File} {} vec (@var{x})
Return the vector obtained by stacking the columns of the matrix @var{x}
one above the other.
@end deftypefn


@c ./linear-algebra/vech.m
@anchor{doc-vech}
@deftypefn {Function File} {} vech (@var{x})
Return the vector obtained by eliminating all supradiagonal elements of
the square matrix @var{x} and stacking the result one column above the
other.
@end deftypefn


@anchor{doc-postpad}
@c ./general/prepad.m
@anchor{doc-prepad}
@deftypefn {Function File} {} prepad (@var{x}, @var{l}, @var{c})
@deftypefnx {Function File} {} prepad (@var{x}, @var{l}, @var{c}, @var{dim})
Prepend (append) the scalar value @var{c} to the vector @var{x}
until it is of length @var{l}.  If the third argument is not
supplied, a value of 0 is used.

If @code{length (@var{x}) > @var{l}}, elements from the beginning (end) of
@var{x} are removed until a vector of length @var{l} is obtained.

If @var{x} is a matrix, elements are prepended or removed from each row.

If the optional @var{dim} argument is given, then operate along this
dimension.
@seealso{@ref{doc-postpad,,postpad}}
@end deftypefn


@c data.cc
@anchor{doc-diag}
@deftypefn {Built-in Function} {} diag (@var{v}, @var{k})
Return a diagonal matrix with vector @var{v} on diagonal @var{k}.  The
second argument is optional.  If it is positive, the vector is placed on
the @var{k}-th super-diagonal.  If it is negative, it is placed on the
@var{-k}-th sub-diagonal.  The default value of @var{k} is 0, and the
vector is placed on the main diagonal.  For example,

@example
@group
diag ([1, 2, 3], 1)
     @result{}  0  1  0  0
         0  0  2  0
         0  0  0  3
         0  0  0  0
@end group
@end example

@noindent
Given a matrix argument, instead of a vector, @code{diag} extracts the
@var{k}-th diagonal of the matrix.
@end deftypefn


@c ./general/blkdiag.m
@anchor{doc-blkdiag}
@deftypefn {Function File} {} blkdiag (@var{a}, @var{b}, @var{c}, @dots{})
Build a block diagonal matrix from @var{a}, @var{b}, @var{c}, @dots{}.
All the arguments must be numeric and are two-dimensional matrices or
scalars.
@seealso{@ref{doc-diag,,diag}, @ref{doc-horzcat,,horzcat}, @ref{doc-vertcat,,vertcat}}
@end deftypefn


@node Applying a Function to an Array
@section Applying a Function to an Array

@c ./general/arrayfun.m
@anchor{doc-arrayfun}
@deftypefn  {Function File} {} arrayfun (@var{func}, @var{a})
@deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{a})
@deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{a}, @var{b}, @dots{})
@deftypefnx {Function File} {[@var{x}, @var{y}, @dots{}] =} arrayfun (@var{func}, @var{a}, @dots{})
@deftypefnx {Function File} {} arrayfun (@dots{}, "UniformOutput", @var{val})
@deftypefnx {Function File} {} arrayfun (@dots{}, "ErrorHandler", @var{errfunc})

Execute a function on each element of an array.  This is useful for
functions that do not accept array arguments.  If the function does
accept array arguments it is better to call the function directly.

The first input argument @var{func} can be a string, a function
handle, an inline function or an anonymous function.  The input
argument @var{a} can be a logic array, a numeric array, a string
array, a structure array or a cell array.  By a call of the function
@command{arrayfun} all elements of @var{a} are passed on to the named
function @var{func} individually.

The named function can also take more than two input arguments, with
the input arguments given as third input argument @var{b}, fourth
input argument @var{c}, @dots{}  If given more than one array input
argument then all input arguments must have the same sizes, for
example

@example
@group
arrayfun (@@atan2, [1, 0], [0, 1])
@result{} ans = [1.5708   0.0000]
@end group
@end example

If the parameter @var{val} after a further string input argument
"UniformOutput" is set @code{true} (the default), then the named
function @var{func} must return a single element which then will be
concatenated into the return value and is of type matrix.  Otherwise,
if that parameter is set to @code{false}, then the outputs are
concatenated in a cell array.  For example

@example
@group
arrayfun (@@(x,y) x:y, "abc", "def", "UniformOutput", false)
@result{} ans =
@{
  [1,1] = abcd
  [1,2] = bcde
  [1,3] = cdef
@}
@end group
@end example

If more than one output arguments are given then the named function
must return the number of return values that also are expected, for
example

@example
@group
[A, B, C] = arrayfun (@@find, [10; 0], "UniformOutput", false)
@result{}
A =
@{
  [1,1] =  1
  [2,1] = [](0x0)
@}
B =
@{
  [1,1] =  1
  [2,1] = [](0x0)
@}
C =
@{
  [1,1] =  10
  [2,1] = [](0x0)
@}
@end group
@end example

If the parameter @var{errfunc} after a further string input argument
"ErrorHandler" is another string, a function handle, an inline
function or an anonymous function, then @var{errfunc} defines a
function to call in the case that @var{func} generates an error.
The definition of the function must be of the form

@example
function [@dots{}] = errfunc (@var{s}, @dots{})
@end example

where there is an additional input argument to @var{errfunc}
relative to @var{func}, given by @var{s}.  This is a structure with
the elements "identifier", "message" and "index", giving
respectively the error identifier, the error message and the index of
the array elements that caused the error.  The size of the output
argument of @var{errfunc} must have the same size as the output
argument of @var{func}, otherwise a real error is thrown.  For
example

@example
@group
function y = ferr (s, x), y = "MyString"; endfunction
arrayfun (@@str2num, [1234], \
          "UniformOutput", false, "ErrorHandler", @@ferr)
@result{} ans =
@{
 [1,1] = MyString
@}
@end group
@end example

@seealso{@ref{doc-cellfun,,cellfun}, @ref{doc-spfun,,spfun}, @ref{doc-structfun,,structfun}}
@end deftypefn


@c ./DLD-FUNCTIONS/bsxfun.cc
@anchor{doc-bsxfun}
@deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{a}, @var{b})
Applies a binary function @var{f} element-wise to two matrix arguments
@var{a} and @var{b}.  The function @var{f} must be capable of accepting
two column vector arguments of equal length, or one column vector
argument and a scalar.

The dimensions of @var{a} and @var{b} must be equal or singleton.  The
singleton dimensions of the matrices will be expanded to the same
dimensionality as the other matrix.

@seealso{@ref{doc-arrayfun,,arrayfun}, @ref{doc-cellfun,,cellfun}}
@end deftypefn


@node Special Utility Matrices
@section Special Utility Matrices

@c data.cc
@anchor{doc-eye}
@deftypefn {Built-in Function} {} eye (@var{x})
@deftypefnx {Built-in Function} {} eye (@var{n}, @var{m})
@deftypefnx {Built-in Function} {} eye (@dots{}, @var{class})
Return an identity matrix.  If invoked with a single scalar argument,
@code{eye} returns a square matrix with the dimension specified.  If you
supply two scalar arguments, @code{eye} takes them to be the number of
rows and columns.  If given a vector with two elements, @code{eye} uses
the values of the elements as the number of rows and columns,
respectively.  For example,

@example
@group
eye (3)
     @result{}  1  0  0
         0  1  0
         0  0  1
@end group
@end example

The following expressions all produce the same result:

@example
@group
eye (2)
@equiv{}
eye (2, 2)
@equiv{}
eye (size ([1, 2; 3, 4])
@end group
@end example

The optional argument @var{class}, allows @code{eye} to return an array of
the specified type, like

@example
val = zeros (n,m, "uint8")
@end example

Calling @code{eye} with no arguments is equivalent to calling it
with an argument of 1.  This odd definition is for compatibility
with @sc{matlab}.
@end deftypefn


@c data.cc
@anchor{doc-ones}
@deftypefn {Built-in Function} {} ones (@var{x})
@deftypefnx {Built-in Function} {} ones (@var{n}, @var{m})
@deftypefnx {Built-in Function} {} ones (@var{n}, @var{m}, @var{k}, @dots{})
@deftypefnx {Built-in Function} {} ones (@dots{}, @var{class})
Return a matrix or N-dimensional array whose elements are all 1.
The arguments are handled the same as the arguments for @code{eye}.

If you need to create a matrix whose values are all the same, you should
use an expression like

@example
val_matrix = val * ones (n, m)
@end example

The optional argument @var{class}, allows @code{ones} to return an array of
the specified type, for example

@example
val = ones (n,m, "uint8")
@end example
@end deftypefn


@c data.cc
@anchor{doc-zeros}
@deftypefn {Built-in Function} {} zeros (@var{x})
@deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m})
@deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m}, @var{k}, @dots{})
@deftypefnx {Built-in Function} {} zeros (@dots{}, @var{class})
Return a matrix or N-dimensional array whose elements are all 0.
The arguments are handled the same as the arguments for @code{eye}.

The optional argument @var{class}, allows @code{zeros} to return an array of
the specified type, for example

@example
val = zeros (n,m, "uint8")
@end example
@end deftypefn


@c ./general/repmat.m
@anchor{doc-repmat}
@deftypefn {Function File} {} repmat (@var{A}, @var{m}, @var{n})
@deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n}])
@deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n} @var{p} @dots{}])
Form a block matrix of size @var{m} by @var{n}, with a copy of matrix
@var{A} as each element.  If @var{n} is not specified, form an 
@var{m} by @var{m} block matrix.
@end deftypefn


@c ./DLD-FUNCTIONS/rand.cc
@anchor{doc-rand}
@deftypefn {Loadable Function} {} rand (@var{x})
@deftypefnx {Loadable Function} {} rand (@var{n}, @var{m})
@deftypefnx {Loadable Function} {} rand ("state", @var{x})
@deftypefnx {Loadable Function} {} rand ("seed", @var{x})
Return a matrix with random elements uniformly distributed on the
interval (0, 1).  The arguments are handled the same as the arguments
for @code{eye}.

You can query the state of the random number generator using the
form

@example
v = rand ("state")
@end example

This returns a column vector @var{v} of length 625.  Later, you can
restore the random number generator to the state @var{v}
using the form

@example
rand ("state", v)
@end example

@noindent
You may also initialize the state vector from an arbitrary vector of
length <= 625 for @var{v}.  This new state will be a hash based on the
value of @var{v}, not @var{v} itself.

By default, the generator is initialized from @code{/dev/urandom} if it is
available, otherwise from cpu time, wall clock time and the current
fraction of a second.

To compute the pseudo-random sequence, @code{rand} uses the Mersenne
Twister with a period of @math{2^{19937}-1} (See M. Matsumoto and T. Nishimura,
@cite{Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator}, ACM Trans. on
Modeling and Computer Simulation Vol. 8, No. 1, January pp.3-30 1998,
@url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html}).
Do @strong{not} use for cryptography without securely hashing
several returned values together, otherwise the generator state
can be learned after reading 624 consecutive values.

Older versions of Octave used a different random number generator.
The new generator is used by default
as it is significantly faster than the old generator, and produces
random numbers with a significantly longer cycle time.  However, in
some circumstances it might be desirable to obtain the same random
sequences as used by the old generators.  To do this the keyword
"seed" is used to specify that the old generators should be use,
as in

@example
rand ("seed", val)
@end example

which sets the seed of the generator to @var{val}.  The seed of the
generator can be queried with

@example
s = rand ("seed")
@end example

However, it should be noted that querying the seed will not cause
@code{rand} to use the old generators, only setting the seed will.
To cause @code{rand} to once again use the new generators, the
keyword "state" should be used to reset the state of the @code{rand}.
@seealso{@ref{doc-randn,,randn}, @ref{doc-rande,,rande}, @ref{doc-randg,,randg}, @ref{doc-randp,,randp}}
@end deftypefn


@c ./DLD-FUNCTIONS/rand.cc
@anchor{doc-randn}
@deftypefn {Loadable Function} {} randn (@var{x})
@deftypefnx {Loadable Function} {} randn (@var{n}, @var{m})
@deftypefnx {Loadable Function} {} randn ("state", @var{x})
@deftypefnx {Loadable Function} {} randn ("seed", @var{x})
Return a matrix with normally distributed pseudo-random
elements having zero mean and variance one.  The arguments are
handled the same as the arguments for @code{rand}.

By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique'' to
transform from a uniform to a normal distribution.  (G. Marsaglia and
W.W. Tsang, @cite{Ziggurat method for generating random variables},
J. Statistical Software, vol 5, 2000,
@url{http://www.jstatsoft.org/v05/i08/})

@seealso{@ref{doc-rand,,rand}, @ref{doc-rande,,rande}, @ref{doc-randg,,randg}, @ref{doc-randp,,randp}}
@end deftypefn


@c ./DLD-FUNCTIONS/rand.cc
@anchor{doc-rande}
@deftypefn {Loadable Function} {} rande (@var{x})
@deftypefnx {Loadable Function} {} rande (@var{n}, @var{m})
@deftypefnx {Loadable Function} {} rande ("state", @var{x})
@deftypefnx {Loadable Function} {} rande ("seed", @var{x})
Return a matrix with exponentially distributed random elements.  The
arguments are handled the same as the arguments for @code{rand}.

By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique'' to
transform from a uniform to a exponential distribution.  (G. Marsaglia and
W.W. Tsang, @cite{Ziggurat method for generating random variables},
J. Statistical Software, vol 5, 2000,
@url{http://www.jstatsoft.org/v05/i08/})
@seealso{@ref{doc-rand,,rand}, @ref{doc-randn,,randn}, @ref{doc-randg,,randg}, @ref{doc-randp,,randp}}
@end deftypefn


@c ./DLD-FUNCTIONS/rand.cc
@anchor{doc-randp}
@deftypefn {Loadable Function} {} randp (@var{l}, @var{x})
@deftypefnx {Loadable Function} {} randp (@var{l}, @var{n}, @var{m})
@deftypefnx {Loadable Function} {} randp ("state", @var{x})
@deftypefnx {Loadable Function} {} randp ("seed", @var{x})
Return a matrix with Poisson distributed random elements with mean value parameter given by the first argument, @var{l}.  The arguments
are handled the same as the arguments for @code{rand}, except for the
argument @var{l}.

Five different algorithms are used depending on the range of @var{l}
and whether or not @var{l} is a scalar or a matrix.

@table @asis
@item For scalar @var{l} <= 12, use direct method.
Press, et al., 'Numerical Recipes in C', Cambridge University Press, 1992.
@item For scalar @var{l} > 12, use rejection method.[1]
Press, et al., 'Numerical Recipes in C', Cambridge University Press, 1992.
@item For matrix @var{l} <= 10, use inversion method.[2]
Stadlober E., et al., WinRand source code, available via FTP.
@item For matrix @var{l} > 10, use patchwork rejection method.
Stadlober E., et al., WinRand source code, available via FTP, or
H. Zechner, 'Efficient sampling from continuous and discrete
unimodal distributions', Doctoral Dissertation, 156pp., Technical
University Graz, Austria, 1994.
@item For @var{l} > 1e8, use normal approximation.
L. Montanet, et al., 'Review of Particle Properties', Physical Review
D 50 p1284, 1994
@end table
@seealso{@ref{doc-rand,,rand}, @ref{doc-randn,,randn}, @ref{doc-rande,,rande}, @ref{doc-randg,,randg}}
@end deftypefn


@c ./DLD-FUNCTIONS/rand.cc
@anchor{doc-randg}
@deftypefn {Loadable Function} {} randg (@var{a}, @var{x})
@deftypefnx {Loadable Function} {} randg (@var{a}, @var{n}, @var{m})
@deftypefnx {Loadable Function} {} randg ("state", @var{x})
@deftypefnx {Loadable Function} {} randg ("seed", @var{x})
Return a matrix with @code{gamma(@var{a},1)} distributed random elements.
The arguments are handled the same as the arguments for @code{rand},
except for the argument @var{a}.

This can be used to generate many distributions:

@table @asis
@item @code{gamma (a, b)} for @code{a > -1}, @code{b > 0}
@example
r = b * randg (a)
@end example
@item @code{beta (a, b)} for @code{a > -1}, @code{b > -1}
@example
@group
r1 = randg (a, 1)
r = r1 / (r1 + randg (b, 1))
@end group
@end example
@item @code{Erlang (a, n)}
@example
r = a * randg (n)
@end example
@item @code{chisq (df)} for @code{df > 0}
@example
r = 2 * randg (df / 2)
@end example
@item @code{t(df)} for @code{0 < df < inf} (use randn if df is infinite)
@example
r = randn () / sqrt (2 * randg (df / 2) / df)
@end example
@item @code{F (n1, n2)} for @code{0 < n1}, @code{0 < n2}
@example
@group
## r1 equals 1 if n1 is infinite
r1 = 2 * randg (n1 / 2) / n1
## r2 equals 1 if n2 is infinite
r2 = 2 * randg (n2 / 2) / n2
r = r1 / r2

@end group
@end example
@item negative @code{binomial (n, p)} for @code{n > 0}, @code{0 < p <= 1}
@example
r = randp ((1 - p) / p * randg (n))
@end example
@item non-central @code{chisq (df, L)}, for @code{df >= 0} and @code{L > 0}
(use chisq if @code{L = 0})
@example
@group
r = randp (L / 2)
r(r > 0) = 2 * randg (r(r > 0))
r(df > 0) += 2 * randg (df(df > 0)/2)
@end group
@end example
@item @code{Dirichlet (a1, @dots{} ak)}
@example
@group
r = (randg (a1), @dots{}, randg (ak))
r = r / sum (r)
@end group
@end example
@end table
@seealso{@ref{doc-rand,,rand}, @ref{doc-randn,,randn}, @ref{doc-rande,,rande}, @ref{doc-randp,,randp}}
@end deftypefn


The generators operate in the new or old style together, it is not
possible to mix the two.  Initializing any generator with
@code{"state"} or @code{"seed"} causes the others to switch to the
same style for future calls.

The state of each generator is independent and calls to different
generators can be interleaved without affecting the final result.  For
example,

@example
@group
rand ("state", [11, 22, 33]);
randn ("state", [44, 55, 66]);
u = rand (100, 1);
n = randn (100, 1);
@end group
@end example

@noindent
and

@example
@group
rand ("state", [11, 22, 33]);
randn ("state", [44, 55, 66]);
u = zeros (100, 1);
n = zeros (100, 1);
for i = 1:100
  u(i) = rand ();
  n(i) = randn ();
end
@end group
@end example

@noindent
produce equivalent results.  When the generators are initialized in
the old style with @code{"seed"} only @code{rand} and @code{randn} are
independent, because the old @code{rande}, @code{randg} and
@code{randp} generators make calls to @code{rand} and @code{randn}.

The generators are initialized with random states at start-up, so
that the sequences of random numbers are not the same each time you run
Octave.@footnote{The old versions of @code{rand} and @code{randn}
obtain their initial seeds from the system clock.} If you really do
need to reproduce a sequence of numbers exactly, you can set the state
or seed to a specific value.

If invoked without arguments, @code{rand} and @code{randn} return a
single element of a random sequence.

The original @code{rand} and @code{randn} functions use Fortran code from
@sc{Ranlib}, a library of fortran routines for random number generation,
compiled by Barry W. Brown and James Lovato of the Department of
Biomathematics at The University of Texas, M.D. Anderson Cancer Center,
Houston, TX 77030.

@c ./general/randperm.m
@anchor{doc-randperm}
@deftypefn {Function File} {} randperm (@var{n})
Return a row vector containing a random permutation of the
integers from 1 to @var{n}.
@end deftypefn


The functions @code{linspace} and @code{logspace} make it very easy to
create vectors with evenly or logarithmically spaced elements.
@xref{Ranges}.

@c data.cc
@anchor{doc-linspace}
@deftypefn {Built-in Function} {} linspace (@var{base}, @var{limit}, @var{n})
Return a row vector with @var{n} linearly spaced elements between
@var{base} and @var{limit}.  If the number of elements is greater than one,
then the @var{base} and @var{limit} are always included in
the range.  If @var{base} is greater than @var{limit}, the elements are
stored in decreasing order.  If the number of points is not specified, a
value of 100 is used.

The @code{linspace} function always returns a row vector.

For compatibility with @sc{matlab}, return the second argument if
fewer than two values are requested.
@end deftypefn


@c ./general/logspace.m
@anchor{doc-logspace}
@deftypefn {Function File} {} logspace (@var{base}, @var{limit}, @var{n})
Similar to @code{linspace} except that the values are logarithmically
spaced from
@tex
$10^{base}$ to $10^{limit}$.
@end tex
@ifnottex
10^base to 10^limit.
@end ifnottex

If @var{limit} is equal to
@tex
$\pi$,
@end tex
@ifnottex
pi,
@end ifnottex
the points are between
@tex
$10^{base}$ and $\pi$,
@end tex
@ifnottex
10^base and pi,
@end ifnottex
@emph{not}
@tex
$10^{base}$ and $10^{\pi}$,
@end tex
@ifnottex
10^base and 10^pi,
@end ifnottex
in order to be compatible with the corresponding @sc{matlab}
function.

Also for compatibility, return the second argument if fewer than two
values are requested.
@seealso{@ref{doc-linspace,,linspace}}
@end deftypefn


@node Famous Matrices
@section Famous Matrices

The following functions return famous matrix forms.

@c ./special-matrix/hadamard.m
@anchor{doc-hadamard}
@deftypefn {Function File} {} hadamard (@var{n})
Construct a Hadamard matrix @var{Hn} of size @var{n}-by-@var{n}.  The 
size @var{n} must be of the form @code{2 ^ @var{k} * @var{p}} in which
@var{p} is one of 1, 12, 20 or 28.  The returned matrix is normalized,
meaning @code{Hn(:,1) == 1} and @code{H(1,:) == 1}.

Some of the properties of Hadamard matrices are:

@itemize @bullet
@item
@code{kron (@var{Hm}, @var{Hn})} is a Hadamard matrix of size 
@var{m}-by-@var{n}.
@item
@code{Hn * Hn' == @var{n} * eye (@var{n})}.
@item
The rows of @var{Hn} are orthogonal.
@item
@code{det (@var{A}) <= abs(det (@var{Hn}))} for all @var{A} with
@code{abs (@var{A} (@var{i}, @var{j})) <= 1}.
@item
Multiply any row or column by -1 and still have a Hadamard matrix.
@end itemize

@end deftypefn


@c ./special-matrix/hankel.m
@anchor{doc-hankel}
@deftypefn {Function File} {} hankel (@var{c}, @var{r})
Return the Hankel matrix constructed given the first column @var{c}, and
(optionally) the last row @var{r}.  If the last element of @var{c} is
not the same as the first element of @var{r}, the last element of
@var{c} is used.  If the second argument is omitted, it is assumed to
be a vector of zeros with the same size as @var{c}.

A Hankel matrix formed from an m-vector @var{c}, and an n-vector
@var{r}, has the elements
@tex
$$
H (i, j) = \cases{c_{i+j-1},&$i+j-1\le m$;\cr r_{i+j-m},&otherwise.\cr}
$$
@end tex
@ifnottex

@example
@group
H(i,j) = c(i+j-1),  i+j-1 <= m;
H(i,j) = r(i+j-m),  otherwise
@end group
@end example
@end ifnottex
@seealso{@ref{doc-vander,,vander}, @ref{doc-sylvester_matrix,,sylvester_matrix}, @ref{doc-hilb,,hilb}, @ref{doc-invhilb,,invhilb}, @ref{doc-toeplitz,,toeplitz}}
@end deftypefn


@c ./special-matrix/hilb.m
@anchor{doc-hilb}
@deftypefn {Function File} {} hilb (@var{n})
Return the Hilbert matrix of order @var{n}.  The
@tex
$i,\,j$
@end tex
@ifnottex
i, j
@end ifnottex
element of a Hilbert matrix is defined as
@tex
$$
H (i, j) = {1 \over (i + j - 1)}
$$
@end tex
@ifnottex

@example
H (i, j) = 1 / (i + j - 1)
@end example
@end ifnottex
@seealso{@ref{doc-hankel,,hankel}, @ref{doc-vander,,vander}, @ref{doc-sylvester_matrix,,sylvester_matrix}, @ref{doc-invhilb,,invhilb}, @ref{doc-toeplitz,,toeplitz}}
@end deftypefn


@c ./special-matrix/invhilb.m
@anchor{doc-invhilb}
@deftypefn {Function File} {} invhilb (@var{n})
Return the inverse of a Hilbert matrix of order @var{n}.  This can be 
computed exactly using
@tex
$$\eqalign{
  A_{ij} &= -1^{i+j} (i+j-1)
             \left( \matrix{n+i-1 \cr n-j } \right)
             \left( \matrix{n+j-1 \cr n-i } \right)
             \left( \matrix{i+j-2 \cr i-2 } \right)^2 \cr
         &= { p(i)p(j) \over (i+j-1) }
}$$
where
$$
  p(k) = -1^k \left( \matrix{ k+n-1 \cr k-1 } \right)
              \left( \matrix{ n \cr k } \right)
$$
@end tex
@ifnottex
@example
@group

            (i+j)         /n+i-1\  /n+j-1\   /i+j-2\ 2
 A(i,j) = -1      (i+j-1)(       )(       ) (       )
                          \ n-j /  \ n-i /   \ i-2 /

        = p(i) p(j) / (i+j-1)

@end group
@end example
where
@example
@group
             k  /k+n-1\   /n\
    p(k) = -1  (       ) (   )
                \ k-1 /   \k/
@end group
@end example
@end ifnottex

The validity of this formula can easily be checked by expanding 
the binomial coefficients in both formulas as factorials.  It can 
be derived more directly via the theory of Cauchy matrices: 
see J. W. Demmel, Applied Numerical Linear Algebra, page 92.

Compare this with the numerical calculation of @code{inverse (hilb (n))},
which suffers from the ill-conditioning of the Hilbert matrix, and the
finite precision of your computer's floating point arithmetic.
@seealso{@ref{doc-hankel,,hankel}, @ref{doc-vander,,vander}, @ref{doc-sylvester_matrix,,sylvester_matrix}, @ref{doc-hilb,,hilb}, @ref{doc-toeplitz,,toeplitz}}
@end deftypefn


@c ./special-matrix/magic.m
@anchor{doc-magic}
@deftypefn {Function File} {} magic (@var{n})

Create an @var{n}-by-@var{n} magic square.  Note that @code{magic
(@var{2})} is undefined since there is no 2-by-2 magic square.

@end deftypefn


@c ./special-matrix/pascal.m
@anchor{doc-pascal}
@deftypefn {Function File} {} pascal (@var{n}, @var{t})

Return the Pascal matrix of order @var{n} if @code{@var{t} = 0}.
@var{t} defaults to 0. Return lower triangular Cholesky factor of 
the Pascal matrix if @code{@var{t} = 1}.  This matrix is its own
inverse, that is @code{pascal (@var{n}, 1) ^ 2 == eye (@var{n})}.
If @code{@var{t} = -1}, return its absolute value.  This is the
standard pascal triangle as a lower-triangular matrix.
If @code{@var{t} = 2}, return a transposed and permuted version of
@code{pascal (@var{n}, 1)}, which is the cube-root of the identity
matrix.  That is @code{pascal (@var{n}, 2) ^ 3 == eye (@var{n})}.

@seealso{@ref{doc-hankel,,hankel}, @ref{doc-vander,,vander}, @ref{doc-sylvester_matrix,,sylvester_matrix}, @ref{doc-hilb,,hilb}, @ref{doc-invhilb,,invhilb}, @ref{doc-toeplitz,,toeplitz}, @ref{doc-hadamard,,hadamard}, @ref{doc-wilkinson,,wilkinson}, @ref{doc-compan,,compan}, @ref{doc-rosser,,rosser}}
@end deftypefn


@c ./special-matrix/rosser.m
@anchor{doc-rosser}
@deftypefn {Function File} {} rosser ()

Returns the Rosser matrix.  This is a difficult test case used to test
eigenvalue algorithms.

@seealso{@ref{doc-hankel,,hankel}, @ref{doc-vander,,vander}, @ref{doc-sylvester_matrix,,sylvester_matrix}, @ref{doc-hilb,,hilb}, @ref{doc-invhilb,,invhilb}, @ref{doc-toeplitz,,toeplitz}, @ref{doc-hadamard,,hadamard}, @ref{doc-wilkinson,,wilkinson}, @ref{doc-compan,,compan}, @ref{doc-pascal,,pascal}}
@end deftypefn


@c ./special-matrix/sylvester_matrix.m
@anchor{doc-sylvester_matrix}
@deftypefn {Function File} {} sylvester_matrix (@var{k})
Return the Sylvester matrix of order
@tex
$n = 2^k$.
@end tex
@ifnottex
n = 2^k.
@end ifnottex
@seealso{@ref{doc-hankel,,hankel}, @ref{doc-vander,,vander}, @ref{doc-hilb,,hilb}, @ref{doc-invhilb,,invhilb}, @ref{doc-toeplitz,,toeplitz}}
@end deftypefn


@c ./special-matrix/toeplitz.m
@anchor{doc-toeplitz}
@deftypefn {Function File} {} toeplitz (@var{c}, @var{r})
Return the Toeplitz matrix constructed given the first column @var{c},
and (optionally) the first row @var{r}.  If the first element of @var{c}
is not the same as the first element of @var{r}, the first element of
@var{c} is used.  If the second argument is omitted, the first row is
taken to be the same as the first column.

A square Toeplitz matrix has the form:
@tex
$$
\left[\matrix{c_0    & r_1     & r_2      & \cdots & r_n\cr
              c_1    & c_0     & r_1      & \cdots & r_{n-1}\cr
              c_2    & c_1     & c_0      & \cdots & r_{n-2}\cr
              \vdots & \vdots  & \vdots   & \ddots & \vdots\cr
              c_n    & c_{n-1} & c_{n-2} & \ldots & c_0}\right]
$$
@end tex
@ifnottex

@example
@group
c(0)  r(1)   r(2)  @dots{}  r(n)
c(1)  c(0)   r(1)  @dots{} r(n-1)
c(2)  c(1)   c(0)  @dots{} r(n-2)
 .     ,      ,   .      .
 .     ,      ,     .    .
 .     ,      ,       .  .
c(n) c(n-1) c(n-2) @dots{}  c(0)
@end group
@end example
@end ifnottex
@seealso{@ref{doc-hankel,,hankel}, @ref{doc-vander,,vander}, @ref{doc-sylvester_matrix,,sylvester_matrix}, @ref{doc-hilb,,hilb}, @ref{doc-invhilb,,invhilb}}
@end deftypefn


@c ./special-matrix/vander.m
@anchor{doc-vander}
@deftypefn {Function File} {} vander (@var{c}, @var{n})
Return the Vandermonde matrix whose next to last column is @var{c}.
If @var{n} is specified, it determines the number of columns;
otherwise, @var{n} is taken to be equal to the length of @var{c}.

A Vandermonde matrix has the form:
@tex
$$
\left[\matrix{c_1^{n-1}  & \cdots & c_1^2  & c_1    & 1      \cr
              c_2^{n-1}  & \cdots & c_2^2  & c_2    & 1      \cr
              \vdots     & \ddots & \vdots & \vdots & \vdots \cr
              c_n^{n-1}  & \cdots & c_n^2  & c_n    & 1      }\right]
$$
@end tex
@ifnottex

@example
@group
c(1)^(n-1) @dots{} c(1)^2  c(1)  1
c(2)^(n-1) @dots{} c(2)^2  c(2)  1
    .     .      .      .    .
    .       .    .      .    .
    .         .  .      .    .
c(n)^(n-1) @dots{} c(n)^2  c(n)  1
@end group
@end example
@end ifnottex
@seealso{@ref{doc-hankel,,hankel}, @ref{doc-sylvester_matrix,,sylvester_matrix}, @ref{doc-hilb,,hilb}, @ref{doc-invhilb,,invhilb}, @ref{doc-toeplitz,,toeplitz}}
@end deftypefn


@c ./special-matrix/wilkinson.m
@anchor{doc-wilkinson}
@deftypefn {Function File} {} wilkinson (@var{n})

Return the Wilkinson matrix of order @var{n}.

@seealso{@ref{doc-hankel,,hankel}, @ref{doc-vander,,vander}, @ref{doc-sylvester_matrix,,sylvester_matrix}, @ref{doc-hilb,,hilb}, @ref{doc-invhilb,,invhilb}, @ref{doc-toeplitz,,toeplitz}, @ref{doc-hadamard,,hadamard}, @ref{doc-rosser,,rosser}, @ref{doc-compan,,compan}, @ref{doc-pascal,,pascal}}
@end deftypefn

