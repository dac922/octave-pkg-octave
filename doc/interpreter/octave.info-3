This is /home/jwe/src/octave/doc/interpreter/octave.info, produced by makeinfo version 4.13 from /home/jwe/src/octave/doc/interpreter/octave.texi.

START-INFO-DIR-ENTRY
* Octave: (octave).           Interactive language for numerical computations.

END-INFO-DIR-ENTRY

   Copyright (C) 1996, 1997, 1999, 2000, 2001, 2002, 2005, 2006, 2007,
2011 John W. Eaton.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: octave.info,  Node: Axis Configuration,  Next: Two-dimensional Function Plotting,  Up: Two-Dimensional Plots

15.2.1.1 Axis Configuration
...........................

The axis function may be used to change the axis limits of an existing
plot and various other axis properties, such as the aspect ratio and the
appearance of tic marks.

 -- Function File:  axis ()
 -- Function File:  axis ([X_lo X_hi])
 -- Function File:  axis ([X_lo X_hi Y_lo Y_hi])
 -- Function File:  axis ([X_lo X_hi Y_lo Y_hi Z_lo Z_hi])
 -- Function File:  axis (OPTION)
 -- Function File:  axis (..., OPTION)
 -- Function File:  axis (HAX, ...)
 -- Function File: LIMITS = axis ()
     Set axis limits and appearance.

     The argument LIMITS should be a 2-, 4-, or 6-element vector.  The
     first and second elements specify the lower and upper limits for
     the x-axis.  The third and fourth specify the limits for the
     y-axis, and the fifth and sixth specify the limits for the z-axis.

     Without any arguments, `axis' turns autoscaling on.

     With one output argument, `LIMITS = axis' returns the current axis
     limits.

     The vector argument specifying limits is optional, and additional
     string arguments may be used to specify various axis properties.
     For example,

          axis ([1, 2, 3, 4], "square");

     forces a square aspect ratio, and

          axis ("tic", "labely");

     turns tic marks on for all axes and tic mark labels on for the
     y-axis only.

     The following options control the aspect ratio of the axes.

    "square"
          Force a square aspect ratio.

    "equal"
          Force x distance to equal y-distance.

    "normal"
          Restore default aspect ratio.

     The following options control the way axis limits are interpreted.

    "auto"
          Set the specified axes to have nice limits around the data or
          all if no axes are specified.

    "manual"
          Fix the current axes limits.

    "tight"
          Fix axes to the limits of the data.

    "image"
          Equivalent to "tight" and "equal".

     The following options affect the appearance of tic marks.

    "on"
          Turn tic marks and labels on for all axes.

    "off"
          Turn tic marks off for all axes.

    "tic[xyz]"
          Turn tic marks on for all axes, or turn them on for the
          specified axes and off for the remainder.

    "label[xyz]"
          Turn tic labels on for all axes, or turn them on for the
          specified axes and off for the remainder.

    "nolabel"
          Turn tic labels off for all axes.

     Note, if there are no tic marks for an axis, there can be no
     labels.

     The following options affect the direction of increasing values on
     the axes.

    "ij"
          Reverse y-axis, so lower values are nearer the top.

    "xy"
          Restore y-axis, so higher values are nearer the top.

     If the first argument HAX is an axes handle, then operate on this
     axes rather than the current axes returned by `gca'.

     See also: *note xlim: XREFxlim, *note ylim: XREFylim, *note zlim:
     XREFzlim, *note daspect: XREFdaspect, *note pbaspect:
     XREFpbaspect, *note box: XREFbox, *note grid: XREFgrid.


   Similarly the axis limits of the colormap can be changed with the
caxis function.

 -- Function File:  caxis (LIMITS)
 -- Function File:  caxis ("auto")
 -- Function File:  caxis ("manual")
 -- Function File:  caxis (HAX, ...)
 -- Function File: LIMITS = caxis ()
     Query or set color axis limits for plots.

     The argument LIMITS should be a 2-element vector specifying the
     lower and upper limits to assign to the first and last value in the
     colormap.  Values outside this range are clamped to the first and
     last colormap entries.

     If LIMITS is "auto", then automatic colormap scaling is applied,
     whereas if LIMITS is "manual" the colormap scaling is set to
     manual.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by `gca'.

     Called without arguments the current color axis limits are
     returned.

     See also: *note colormap: XREFcolormap.


   The `xlim', `ylim', and `zlim' functions may be used to get or set
individual axis limits.  Each has the same form.

 -- Function File: XLIMITS = xlim ()
 -- Function File: XMODE = xlim ("mode")
 -- Function File:  xlim ([X_LO X_HI])
 -- Function File:  xlim ("auto")
 -- Function File:  xlim ("manual")
 -- Function File:  xlim (HAX, ...)
     Query or set the limits of the x-axis of the current plot.

     Called without arguments `xlim' returns the x-axis limits of the
     current plot.  With the input query "mode", return the current
     x-limit calculation mode which is either "auto" or "manual".

     If passed a 2-element vector [X_LO X_HI], the limits of the x-axis
     are set to these values.

     The current plotting mode can be set by passing either "auto" or
     "manual" as the argument.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by `gca'.

     See also: *note ylim: XREFylim, *note zlim: XREFzlim, *note axis:
     XREFaxis, *note set: XREFset, *note get: XREFget, *note gca:
     XREFgca.



File: octave.info,  Node: Two-dimensional Function Plotting,  Next: Two-dimensional Geometric Shapes,  Prev: Axis Configuration,  Up: Two-Dimensional Plots

15.2.1.2 Two-dimensional Function Plotting
..........................................

Octave can plot a function from a function handle inline function or
string defining the function without the user needing to explicitly
create the data to be plotted.  The function `fplot' also generates
two-dimensional plots with linear axes using a function name and limits
for the range of the x-coordinate instead of the x and y data.  For
example,

     fplot (@sin, [-10, 10], 201);

produces a plot that is equivalent to the one above, but also includes a
legend displaying the name of the plotted function.

 -- Function File:  fplot (FN, LIMITS)
 -- Function File:  fplot (FN, LIMITS, TOL)
 -- Function File:  fplot (FN, LIMITS, N)
 -- Function File:  fplot (FN, LIMITS, FMT)
 -- Function File:  fplot (FN, LIMITS, TOL, N, FMT)
 -- Function File: [X, Y] = fplot (...)
     Plot a function FN within the range defined by LIMITS.

     FN is a function handle, inline function, or string containing the
     name of the function to evaluate.  The limits of the plot are of
     the form `[XLO, XHI]' or `[XLO, XHI, YLO, YHI]'.  The next three
     arguments are all optional and any number of them may be given in
     any order.  TOL is the relative tolerance to use for the plot and
     defaults to 2e-3 (.2%).  N is the minimum number of points to use.
     When N is specified, the maximum stepsize will be `XHI - XLO / N'.
     More than N points may still be used in order to meet the relative
     tolerance requirement.  The FMT argument specifies the linestyle
     to be used by the plot command.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     With no output arguments the results are immediately plotted.
     With two output arguments the 2-D plot data is returned.  The data
     can subsequently be plotted manually with `plot (X, Y)'.

     Example:

          fplot (@cos, [0, 2*pi])
          fplot ("[cos(x), sin(x)]", [0, 2*pi])

     Note: `fplot' works best with continuous functions.  Functions with
     discontinuities are unlikely to plot well.  This restriction may
     be removed in the future.

     See also: *note ezplot: XREFezplot, *note plot: XREFplot.


   Other functions that can create two-dimensional plots directly from a
function include `ezplot', `ezcontour', `ezcontourf' and `ezpolar'.

 -- Function File:  ezplot (F)
 -- Function File:  ezplot (F2V)
 -- Function File:  ezplot (FX, FY)
 -- Function File:  ezplot (..., DOM)
 -- Function File:  ezplot (..., N)
 -- Function File:  ezplot (HAX, ...)
 -- Function File: H = ezplot (...)
     Plot the 2-D curve defined by the function F.

     The function F may be a string, inline function, or function handle
     and can have either one or two variables.  If F has one variable,
     then the function is plotted over the domain `-2*pi < X < 2*pi'
     with 500 points.

     If F2V is a function of two variables then the implicit function
     `F(X,Y) = 0' is calculated over the meshed domain `-2*pi <= X | Y
     <= 2*pi' with 60 points in each dimension.

     For example:

          ezplot (@(X, Y) X.^2 - Y.^2 - 1)

     If two functions are passed as inputs then the parametric function

          X = FX (T)
          Y = FY (T)

     is plotted over the domain `-2*pi <= T <= 2*pi' with 500 points.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y, or T for a parametric plot.  If
     DOM is a four element vector, then the minimum and maximum values
     are `[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in plotting the
     function.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a vector of graphics handles to the
     created line objects.

     See also: *note plot: XREFplot, *note ezplot3: XREFezplot3, *note
     ezpolar: XREFezpolar, *note ezcontour: XREFezcontour, *note
     ezcontourf: XREFezcontourf, *note ezmesh: XREFezmesh, *note
     ezmeshc: XREFezmeshc, *note ezsurf: XREFezsurf, *note ezsurfc:
     XREFezsurfc.


 -- Function File:  ezcontour (F)
 -- Function File:  ezcontour (..., DOM)
 -- Function File:  ezcontour (..., N)
 -- Function File:  ezcontour (HAX, ...)
 -- Function File: H = ezcontour (...)
     Plot the contour lines of a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain `-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are `[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     plot.

     Example:

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezcontour (f, [-3, 3]);

     See also: *note contour: XREFcontour, *note ezcontourf:
     XREFezcontourf, *note ezplot: XREFezplot, *note ezmeshc:
     XREFezmeshc, *note ezsurfc: XREFezsurfc.


 -- Function File:  ezcontourf (F)
 -- Function File:  ezcontourf (..., DOM)
 -- Function File:  ezcontourf (..., N)
 -- Function File:  ezcontourf (HAX, ...)
 -- Function File: H = ezcontourf (...)
     Plot the filled contour lines of a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain `-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are `[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     plot.

     Example:

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezcontourf (f, [-3, 3]);

     See also: *note contourf: XREFcontourf, *note ezcontour:
     XREFezcontour, *note ezplot: XREFezplot, *note ezmeshc:
     XREFezmeshc, *note ezsurfc: XREFezsurfc.


 -- Function File:  ezpolar (F)
 -- Function File:  ezpolar (..., DOM)
 -- Function File:  ezpolar (..., N)
 -- Function File:  ezpolar (HAX, ...)
 -- Function File: H = ezpolar (...)
     Plot a 2-D function in polar coordinates.

     The function F is a string, inline function, or function handle
     with a single argument.  The expected form of the function is `RHO
     = F(THETA)'.  By default the plot is over the domain `0 <= THETA
     <= 2*pi' with 500 points.

     If DOM is a two element vector, it represents the minimum and
     maximum values of THETA.

     N is a scalar defining the number of points to use in plotting the
     function.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     plot.

     Example:

          ezpolar (@(t) sin (5/4 * t), [0, 8*pi]);

     See also: *note polar: XREFpolar, *note ezplot: XREFezplot.



File: octave.info,  Node: Two-dimensional Geometric Shapes,  Prev: Two-dimensional Function Plotting,  Up: Two-Dimensional Plots

15.2.1.3 Two-dimensional Geometric Shapes
.........................................

 -- Function File:  rectangle ()
 -- Function File:  rectangle (..., "Position", POS)
 -- Function File:  rectangle (..., "Curvature", CURV)
 -- Function File:  rectangle (..., "EdgeColor", EC)
 -- Function File:  rectangle (..., "FaceColor", FC)
 -- Function File:  rectangle (HAX, ...)
 -- Function File: H = rectangle (...)
     Draw a rectangular patch defined by POS and CURV.

     The variable `POS(1:2)' defines the lower left-hand corner of the
     patch and `POS(3:4)' defines its width and height.  By default,
     the value of POS is `[0, 0, 1, 1]'.

     The variable CURV defines the curvature of the sides of the
     rectangle and may be a scalar or two-element vector with values
     between 0 and 1.  A value of 0 represents no curvature of the
     side, whereas a value of 1 means that the side is entirely curved
     into the arc of a circle.  If CURV is a two-element vector, then
     the first element is the curvature along the x-axis of the patch
     and the second along y-axis.

     If CURV is a scalar, it represents the curvature of the shorter of
     the two sides of the rectangle and the curvature of the other side
     is defined by

          min (pos (1:2)) / max (pos (1:2)) * curv

     Additional property/value pairs are passed to the underlying patch
     command.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     rectangle object.

See also: *note patch: XREFpatch, *note line: XREFline, *note cylinder:
XREFcylinder, *note ellipsoid: XREFellipsoid, *note sphere: XREFsphere.


File: octave.info,  Node: Three-Dimensional Plots,  Next: Plot Annotations,  Prev: Two-Dimensional Plots,  Up: High-Level Plotting

15.2.2 Three-Dimensional Plots
------------------------------

The function `mesh' produces mesh surface plots.  For example,

     tx = ty = linspace (-8, 8, 41)';
     [xx, yy] = meshgrid (tx, ty);
     r = sqrt (xx .^ 2 + yy .^ 2) + eps;
     tz = sin (r) ./ r;
     mesh (tx, ty, tz);

produces the familiar "sombrero" plot shown in *note fig:mesh::.  Note
the use of the function `meshgrid' to create matrices of X and Y
coordinates to use for plotting the Z data.  The `ndgrid' function is
similar to `meshgrid', but works for N-dimensional matrices.

 [image src="mesh.png" text="
+---------------------------------+
| Image unavailable in text mode. |
+---------------------------------+
" ]
Figure 15.5: Mesh plot.

   The `meshc' function is similar to `mesh', but also produces a plot
of contours for the surface.

   The `plot3' function displays arbitrary three-dimensional data,
without requiring it to form a surface.  For example,

     t = 0:0.1:10*pi;
     r = linspace (0, 1, numel (t));
     z = linspace (0, 1, numel (t));
     plot3 (r.*sin(t), r.*cos(t), z);

displays the spiral in three dimensions shown in *note fig:plot3::.

 [image src="plot3.png" text="
+---------------------------------+
| Image unavailable in text mode. |
+---------------------------------+
" ]
Figure 15.6: Three-dimensional spiral.

   Finally, the `view' function changes the viewpoint for
three-dimensional plots.

 -- Function File:  mesh (X, Y, Z)
 -- Function File:  mesh (Z)
 -- Function File:  mesh (..., C)
 -- Function File:  mesh (..., PROP, VAL, ...)
 -- Function File:  mesh (HAX, ...)
 -- Function File: H = mesh (...)
     Plot a 3-D wireframe mesh.

     The wireframe mesh is plotted using rectangles.  The vertices of
     the rectangles [X, Y] are typically the output of `meshgrid'.
     over a 2-D rectangular region in the x-y plane.  Z determines the
     height above the plane of each vertex.  If only a single Z matrix
     is given, then it is plotted over the meshgrid `X = 1:columns (Z),
     Y = 1:rows (Z)'.  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values
     to fit the range of the current colormap.  Use `caxis' and/or
     change the colormap to control the appearance.

     Optionally, the color of the mesh can be specified independently
     of Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: *note ezmesh: XREFezmesh, *note meshc: XREFmeshc, *note
     meshz: XREFmeshz, *note trimesh: XREFtrimesh, *note contour:
     XREFcontour, *note surf: XREFsurf, *note surface: XREFsurface,
     *note meshgrid: XREFmeshgrid, *note hidden: XREFhidden, *note
     shading: XREFshading, *note colormap: XREFcolormap, *note caxis:
     XREFcaxis.


 -- Function File:  meshc (X, Y, Z)
 -- Function File:  meshc (Z)
 -- Function File:  meshc (..., C)
 -- Function File:  meshc (..., PROP, VAL, ...)
 -- Function File:  meshc (HAX, ...)
 -- Function File: H = meshc (...)
     Plot a 3-D wireframe mesh with underlying contour lines.

     The wireframe mesh is plotted using rectangles.  The vertices of
     the rectangles [X, Y] are typically the output of `meshgrid'.
     over a 2-D rectangular region in the x-y plane.  Z determines the
     height above the plane of each vertex.  If only a single Z matrix
     is given, then it is plotted over the meshgrid `X = 1:columns (Z),
     Y = 1:rows (Z)'.  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values
     to fit the range of the current colormap.  Use `caxis' and/or
     change the colormap to control the appearance.

     Optionally the color of the mesh can be specified independently of
     Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a 2-element vector with a graphics
     handle to the created surface object and to the created contour
     plot.

     See also: *note ezmeshc: XREFezmeshc, *note mesh: XREFmesh, *note
     meshz: XREFmeshz, *note contour: XREFcontour, *note surfc:
     XREFsurfc, *note surface: XREFsurface, *note meshgrid:
     XREFmeshgrid, *note hidden: XREFhidden, *note shading:
     XREFshading, *note colormap: XREFcolormap, *note caxis: XREFcaxis.


 -- Function File:  meshz (X, Y, Z)
 -- Function File:  meshz (Z)
 -- Function File:  meshz (..., C)
 -- Function File:  meshz (..., PROP, VAL, ...)
 -- Function File:  meshz (HAX, ...)
 -- Function File: H = meshz (...)
     Plot a 3-D wireframe mesh with a surrounding curtain.

     The wireframe mesh is plotted using rectangles.  The vertices of
     the rectangles [X, Y] are typically the output of `meshgrid'.
     over a 2-D rectangular region in the x-y plane.  Z determines the
     height above the plane of each vertex.  If only a single Z matrix
     is given, then it is plotted over the meshgrid `X = 1:columns (Z),
     Y = 1:rows (Z)'.  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values
     to fit the range of the current colormap.  Use `caxis' and/or
     change the colormap to control the appearance.

     Optionally the color of the mesh can be specified independently of
     Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: *note mesh: XREFmesh, *note meshc: XREFmeshc, *note
     contour: XREFcontour, *note surf: XREFsurf, *note surface:
     XREFsurface, *note waterfall: XREFwaterfall, *note meshgrid:
     XREFmeshgrid, *note hidden: XREFhidden, *note shading:
     XREFshading, *note colormap: XREFcolormap, *note caxis: XREFcaxis.


 -- Command:  hidden
 -- Command:  hidden "on"
 -- Command:  hidden "off"
 -- Function File: MODE = hidden (...)
     Control mesh hidden line removal.

     When called with no argument the hidden line removal state is
     toggled.  When called with one of the modes "on" or "off" the state
     is set accordingly.

     The optional output argument MODE is the current state.

     Hidden Line Removal determines what graphic objects behind a mesh
     plot are visible.  The default is for the mesh to be opaque and
     lines behind the mesh are not visible.  If hidden line removal is
     turned off then objects behind the mesh can be seen through the
     faces (openings) of the mesh, although the mesh grid lines are
     still opaque.

     See also: *note mesh: XREFmesh, *note meshc: XREFmeshc, *note
     meshz: XREFmeshz, *note ezmesh: XREFezmesh, *note ezmeshc:
     XREFezmeshc, *note trimesh: XREFtrimesh, *note waterfall:
     XREFwaterfall.


 -- Function File:  surf (X, Y, Z)
 -- Function File:  surf (Z)
 -- Function File:  surf (..., C)
 -- Function File:  surf (..., PROP, VAL, ...)
 -- Function File:  surf (HAX, ...)
 -- Function File: H = surf (...)
     Plot a 3-D surface mesh.

     The surface mesh is plotted using shaded rectangles.  The vertices
     of the rectangles [X, Y] are typically the output of `meshgrid'.
     over a 2-D rectangular region in the x-y plane.  Z determines the
     height above the plane of each vertex.  If only a single Z matrix
     is given, then it is plotted over the meshgrid `X = 1:columns (Z),
     Y = 1:rows (Z)'.  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     The color of the surface is computed by linearly scaling the Z
     values to fit the range of the current colormap.  Use `caxis'
     and/or change the colormap to control the appearance.

     Optionally, the color of the surface can be specified
     independently of Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Note: The exact appearance of the surface can be controlled with
     the `shading' command or by using `set' to control surface object
     properties.

     See also: *note ezsurf: XREFezsurf, *note surfc: XREFsurfc, *note
     surfl: XREFsurfl, *note surfnorm: XREFsurfnorm, *note trisurf:
     XREFtrisurf, *note contour: XREFcontour, *note mesh: XREFmesh,
     *note surface: XREFsurface, *note meshgrid: XREFmeshgrid, *note
     hidden: XREFhidden, *note shading: XREFshading, *note colormap:
     XREFcolormap, *note caxis: XREFcaxis.


 -- Function File:  surfc (X, Y, Z)
 -- Function File:  surfc (Z)
 -- Function File:  surfc (..., C)
 -- Function File:  surfc (..., PROP, VAL, ...)
 -- Function File:  surfc (HAX, ...)
 -- Function File: H = surfc (...)
     Plot a 3-D surface mesh with underlying contour lines.

     The surface mesh is plotted using shaded rectangles.  The vertices
     of the rectangles [X, Y] are typically the output of `meshgrid'.
     over a 2-D rectangular region in the x-y plane.  Z determines the
     height above the plane of each vertex.  If only a single Z matrix
     is given, then it is plotted over the meshgrid `X = 1:columns (Z),
     Y = 1:rows (Z)'.  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     The color of the surface is computed by linearly scaling the Z
     values to fit the range of the current colormap.  Use `caxis'
     and/or change the colormap to control the appearance.

     Optionally, the color of the surface can be specified
     independently of Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Note: The exact appearance of the surface can be controlled with
     the `shading' command or by using `set' to control surface object
     properties.

     See also: *note ezsurfc: XREFezsurfc, *note surf: XREFsurf, *note
     surfl: XREFsurfl, *note surfnorm: XREFsurfnorm, *note trisurf:
     XREFtrisurf, *note contour: XREFcontour, *note mesh: XREFmesh,
     *note surface: XREFsurface, *note meshgrid: XREFmeshgrid, *note
     hidden: XREFhidden, *note shading: XREFshading, *note colormap:
     XREFcolormap, *note caxis: XREFcaxis.


 -- Function File:  surfl (X, Y, Z)
 -- Function File:  surfl (Z)
 -- Function File:  surfl (X, Y, Z, L)
 -- Function File:  surfl (X, Y, Z, L, P)
 -- Function File:  surfl (..., "light")
 -- Function File:  surfl (HAX, ...)
 -- Function File: H = surfl (...)
     Plot a 3-D surface using shading based on various lighting models.

     The surface mesh is plotted using shaded rectangles.  The vertices
     of the rectangles [X, Y] are typically the output of `meshgrid'.
     over a 2-D rectangular region in the x-y plane.  Z determines the
     height above the plane of each vertex.  If only a single Z matrix
     is given, then it is plotted over the meshgrid `X = 1:columns (Z),
     Y = 1:rows (Z)'.  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     The default lighting mode "cdata", changes the cdata property of
     the surface object to give the impression of a lighted surface.
     *Warning:* The alternative mode "light" mode which creates a light
     object to illuminate the surface is not implemented (yet).

     The light source location can be specified using L.  It can be
     given as a 2-element vector [azimuth, elevation] in degrees, or as
     a 3-element vector [lx, ly, lz].  The default value is rotated 45
     degrees counterclockwise to the current view.

     The material properties of the surface can specified using a
     4-element vector P = [AM D SP EXP] which defaults to P = [0.55 0.6
     0.4 10].

    "AM" strength of ambient light

    "D" strength of diffuse reflection

    "SP" strength of specular reflection

    "EXP" specular exponent

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Example:

          colormap (bone (64));
          surfl (peaks);
          shading interp;

     See also: *note diffuse: XREFdiffuse, *note specular:
     XREFspecular, *note surf: XREFsurf, *note shading: XREFshading,
     *note colormap: XREFcolormap, *note caxis: XREFcaxis.


 -- Function File:  surfnorm (X, Y, Z)
 -- Function File:  surfnorm (Z)
 -- Function File: [NX, NY, NZ] = surfnorm (...)
 -- Function File:  surfnorm (H, ...)
     Find the vectors normal to a meshgridded surface.  The meshed
     gridded surface is defined by X, Y, and Z.  If X and Y are not
     defined, then it is assumed that they are given by

          [X, Y] = meshgrid (1:rows (Z),
                             1:columns (Z));

     If no return arguments are requested, a surface plot with the
     normal vectors to the surface is plotted.  Otherwise the
     components of the normal vectors at the mesh gridded points are
     returned in NX, NY, and NZ.

     The normal vectors are calculated by taking the cross product of
     the diagonals of each of the quadrilaterals in the meshgrid to
     find the normal vectors of the centers of these quadrilaterals.
     The four nearest normal vectors to the meshgrid points are then
     averaged to obtain the normal to the surface at the meshgridded
     points.

     An example of the use of `surfnorm' is

          surfnorm (peaks (25));

     See also: *note surf: XREFsurf, *note quiver3: XREFquiver3.


 -- Function File: [FV] = isosurface (VAL, ISO)
 -- Function File: [FV] = isosurface (X, Y, Z, VAL, ISO)
 -- Function File: [FV] = isosurface (..., "noshare", "verbose")
 -- Function File: [FVC] = isosurface (..., COL)
 -- Function File: [F, V] = isosurface (X, Y, Z, VAL, ISO)
 -- Function File: [F, V, C] = isosurface (X, Y, Z, VAL, ISO, COL)
 -- Function File:  isosurface (X, Y, Z, VAL, ISO, COL, OPT)
     If called with one output argument and the first input argument
     VAL is a three-dimensional array that contains the data of an
     isosurface geometry and the second input argument ISO keeps the
     isovalue as a scalar value then return a structure array FV that
     contains the fields FACES and VERTICES at computed points `[x, y,
     z] = meshgrid (1:l, 1:m, 1:n)'.  The output argument FV can
     directly be taken as an input argument for the `patch' function.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays with the same size than VAL then the
     volume data is taken at those given points.

     The string input argument "noshare" is only for compatibility and
     has no effect.  If given the string input argument "verbose" then
     print messages to the command line interface about the current
     progress.

     If called with the input argument COL which is a three-dimensional
     array of the same size than VAL then take those values for the
     interpolation of coloring the isosurface geometry.  Add the field
     FACEVERTEXCDATA to the structure array FV.

     If called with two or three output arguments then return the
     information about the faces F, vertices V and color data C as
     separate arrays instead of a single structure array.

     If called with no output argument then directly process the
     isosurface geometry with the `patch' command.

     For example,

          [x, y, z] = meshgrid (1:5, 1:5, 1:5);
          val = rand (5, 5, 5);
          isosurface (x, y, z, val, .5);

     will directly draw a random isosurface geometry in a graphics
     window.  Another example for an isosurface geometry with different
     additional coloring

          N = 15;    # Increase number of vertices in each direction
          iso = .4;  # Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); # Open another figure window

          subplot (2,2,1); view (-38, 20);
          [f, v] = isosurface (x, y, z, c, iso);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceColor", "green", "FaceLighting", "phong");
          # light ("Position", [1 1 5]); # Available with the JHandles package

          subplot (2,2,2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "blue");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceColor", "none", "FaceLighting", "phong");
          # light ("Position", [1 1 5]);

          subplot (2,2,3); view (-38, 20);
          [f, v, c] = isosurface (x, y, z, c, iso, y);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceLighting", "phong");
          # light ("Position", [1 1 5]);

          subplot (2,2,4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, ...
                     "FaceColor", "interp", "EdgeColor", "blue");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceLighting", "phong");
          # light ("Position", [1 1 5]);

     See also: *note isonormals: XREFisonormals, *note isocolors:
     XREFisocolors.


 -- Function File: [N] = isonormals (VAL, V)
 -- Function File: [N] = isonormals (VAL, P)
 -- Function File: [N] = isonormals (X, Y, Z, VAL, V)
 -- Function File: [N] = isonormals (X, Y, Z, VAL, P)
 -- Function File: [N] = isonormals (..., "negate")
 -- Function File:  isonormals (..., P)
     If called with one output argument and the first input argument
     VAL is a three-dimensional array that contains the data for an
     isosurface geometry and the second input argument V keeps the
     vertices of an isosurface then return the normals N in form of a
     matrix with the same size than V at computed points `[x, y, z] =
     meshgrid (1:l, 1:m, 1:n)'.  The output argument N can be taken to
     manually set VERTEXNORMALS of a patch.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays with the same size than VAL then the
     volume data is taken at those given points.  Instead of the
     vertices data V a patch handle P can be passed to this function.

     If given the string input argument "negate" as last input argument
     then compute the reverse vector normals of an isosurface geometry.

     If no output argument is given then directly redraw the patch that
     is given by the patch handle P.

     For example:

          function [] = isofinish (p)
            set (gca, "PlotBoxAspectRatioMode", "manual", ...
                      "PlotBoxAspectRatio", [1 1 1]);
            set (p, "VertexNormals", -get (p,"VertexNormals")); # Revert normals
            set (p, "FaceColor", "interp");
            ## set (p, "FaceLighting", "phong");
            ## light ("Position", [1 1 5]); # Available with JHandles
          endfunction

          N = 15;    # Increase number of vertices in each direction
          iso = .4;  # Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); # Open another figure window

          subplot (2,2,1); view (-38, 20);
          [f, v, cdat] = isosurface (x, y, z, c, iso, y);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          isofinish (p); ## Call user function isofinish

          subplot (2,2,2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          isonormals (x, y, z, c, p); # Directly modify patch
          isofinish (p);

          subplot (2,2,3); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          n = isonormals (x, y, z, c, v); # Compute normals of isosurface
          set (p, "VertexNormals", n);    # Manually set vertex normals
          isofinish (p);

          subplot (2,2,4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          isonormals (x, y, z, c, v, "negate"); # Use reverse directly
          isofinish (p);

     See also: *note isosurface: XREFisosurface, *note isocolors:
     XREFisocolors.


 -- Function File: [CD] = isocolors (C, V)
 -- Function File: [CD] = isocolors (X, Y, Z, C, V)
 -- Function File: [CD] = isocolors (X, Y, Z, R, G, B, V)
 -- Function File: [CD] = isocolors (R, G, B, V)
 -- Function File: [CD] = isocolors (..., P)
 -- Function File:  isocolors (...)
     If called with one output argument and the first input argument C
     is a three-dimensional array that contains color values and the
     second input argument V keeps the vertices of a geometry then
     return a matrix CD with color data information for the geometry at
     computed points `[x, y, z] = meshgrid (1:l, 1:m, 1:n)'.  The
     output argument CD can be taken to manually set FaceVertexCData of
     a patch.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays of the same size than C then the color
     data is taken at those given points.  Instead of the color data C
     this function can also be called with RGB values R, G, B.  If
     input argumnets X, Y, Z are not given then again `meshgrid'
     computed values are taken.

     Optionally, the patch handle P can be given as the last input
     argument to all variations of function calls instead of the
     vertices data V.  Finally, if no output argument is given then
     directly change the colors of a patch that is given by the patch
     handle P.

     For example:

          function [] = isofinish (p)
            set (gca, "PlotBoxAspectRatioMode", "manual", ...
                      "PlotBoxAspectRatio", [1 1 1]);
            set (p, "FaceColor", "interp");
            ## set (p, "FaceLighting", "flat");
            ## light ("Position", [1 1 5]); ## Available with JHandles
          endfunction

          N = 15;    # Increase number of vertices in each direction
          iso = .4;  # Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); # Open another figure window

          subplot (2,2,1); view (-38, 20);
          [f, v] = isosurface (x, y, z, c, iso);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          cdat = rand (size (c));       # Compute random patch color data
          isocolors (x, y, z, cdat, p); # Directly set colors of patch
          isofinish (p);                # Call user function isofinish

          subplot (2,2,2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          [r, g, b] = meshgrid (lin, 2-lin, 2-lin);
          cdat = isocolors (x, y, z, c, v); # Compute color data vertices
          set (p, "FaceVertexCData", cdat); # Set color data manually
          isofinish (p);

          subplot (2,2,3); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          cdat = isocolors (r, g, b, c, p); # Compute color data patch
          set (p, "FaceVertexCData", cdat); # Set color data manually
          isofinish (p);

          subplot (2,2,4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          r = g = b = repmat ([1:N] / N, [N, 1, N]); # Black to white
          cdat = isocolors (x, y, z, r, g, b, v);
          set (p, "FaceVertexCData", cdat);
          isofinish (p);

     See also: *note isosurface: XREFisosurface, *note isonormals:
     XREFisonormals.


 -- Function File:  shrinkfaces (P, SF)
 -- Function File: NFV = shrinkfaces (P, SF)
 -- Function File: NFV = shrinkfaces (FV, SF)
 -- Function File: NFV = shrinkfaces (F, V, SF)
 -- Function File: [NF, NV] = shrinkfaces (...)
     Reduce the faces area for a given patch, structure or explicit
     faces and points matrices by a scale factor SF.  The structure FV
     must contain the fields "faces" and "vertices".  If the factor SF
     is omitted then a default of 0.3 is used.

     Given a patch handle as the first input argument and no output
     parameters, perform the shrinking of the patch faces in place and
     redraw the patch.

     If called with one output argument, return a structure with fields
     "faces", "vertices", and "facevertexcdata" containing the data
     after shrinking which can then directly be used as an input
     argument for the `patch' function.

     Performing the shrinking on faces which are not convex can lead to
     undesired results.

     For example,

          [phi r] = meshgrid (linspace (0, 1.5*pi, 16), linspace (1, 2, 4));
          tri = delaunay (phi(:), r(:));
          v = [r(:).*sin(phi(:)) r(:).*cos(phi(:))];
          clf ()
          p = patch ("Faces", tri, "Vertices", v, "FaceColor", "none");
          fv = shrinkfaces (p);
          patch (fv)
          axis equal
          grid on

     draws a triangulated 3/4 circle and the corresponding shrunken
     version.

     See also: *note patch: XREFpatch.


 -- Function File:  diffuse (SX, SY, SZ, LV)
     Calculate diffuse reflection strength of a surface defined by the
     normal vector elements SX, SY, SZ.

     The light source location vector LV can be given as 2-element
     vector [azimuth, elevation] in degrees or as 3-element vector [lx,
     ly, lz].

     See also: *note specular: XREFspecular, *note surfl: XREFsurfl.


 -- Function File:  specular (SX, SY, SZ, LV, VV)
 -- Function File:  specular (SX, SY, SZ, LV, VV, SE)
     Calculate specular reflection strength of a surface defined by the
     normal vector elements SX, SY, SZ using Phong's approximation.

     The light source location and viewer location vectors can be
     specified using parameter LV and  VV respectively.  The location
     vectors can given as 2-element vectors [azimuth, elevation] in
     degrees or as 3-element vectors [x, y, z].

     An optional sixth argument describes the specular exponent
     (spread) SE.

     See also: *note diffuse: XREFdiffuse, *note surfl: XREFsurfl.


 -- Function File: [XX, YY] = meshgrid (X, Y)
 -- Function File: [XX, YY, ZZ] = meshgrid (X, Y, Z)
 -- Function File: [XX, YY] = meshgrid (X)
 -- Function File: [XX, YY, ZZ] = meshgrid (X)
     Given vectors of X and Y and Z coordinates, and returning 3
     arguments, return three-dimensional arrays corresponding to the X,
     Y, and Z coordinates of a mesh.  When returning only 2 arguments,
     return matrices corresponding to the X and Y coordinates of a
     mesh.  The rows of XX are copies of X, and the columns of YY are
     copies of Y.  If Y is omitted, then it is assumed to be the same
     as X, and Z is assumed the same as Y.

     See also: *note ndgrid: XREFndgrid, *note mesh: XREFmesh, *note
     contour: XREFcontour, *note surf: XREFsurf.


 -- Function File: [Y1, Y2, ..., Yn] = ndgrid (X1, X2, ..., Xn)
 -- Function File: [Y1, Y2, ..., Yn] = ndgrid (X)
     Given n vectors X1, ... Xn, `ndgrid' returns n arrays of dimension
     n.  The elements of the i-th output argument contains the elements
     of the vector Xi repeated over all dimensions different from the
     i-th dimension.  Calling ndgrid with only one input argument X is
     equivalent of calling ndgrid with all n input arguments equal to X:

     [Y1, Y2, ..., Yn] = ndgrid (X, ..., X)

     See also: *note meshgrid: XREFmeshgrid.


 -- Function File:  plot3 (X, Y, Z)
 -- Function File:  plot3 (X, Y, Z, PROP, VALUE, ...)
 -- Function File:  plot3 (X, Y, Z, FMT)
 -- Function File:  plot3 (X, CPLX)
 -- Function File:  plot3 (CPLX)
 -- Function File:  plot3 (HAX, ...)
 -- Function File: H = plot3 (...)
     Produce 3-D plots.

     Many different combinations of arguments are possible.  The
     simplest form is

          plot3 (X, Y, Z)

     in which the arguments are taken to be the vertices of the points
     to be plotted in three dimensions.  If all arguments are vectors
     of the same length, then a single continuous line is drawn.  If
     all arguments are matrices, then each column of is treated as a
     separate line.  No attempt is made to transpose the arguments to
     make the number of rows match.

     If only two arguments are given, as

          plot3 (X, CPLX)

     the real and imaginary parts of the second argument are used as
     the Y and Z coordinates, respectively.

     If only one argument is given, as

          plot3 (CPLX)

     the real and imaginary parts of the argument are used as the Y and
     Z values, and they are plotted versus their index.

     Arguments may also be given in groups of three as

          plot3 (X1, Y1, Z1, X2, Y2, Z2, ...)

     in which each set of three arguments is treated as a separate line
     or set of lines in three dimensions.

     To plot multiple one- or two-argument groups, separate each group
     with an empty format string, as

          plot3 (X1, C1, "", C2, "", ...)

     Multiple property-value pairs may be specified which will affect
     the line objects drawn by `plot3'.  If the FMT argument is
     supplied it will format the line objects in the same manner as
     `plot'.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     plot.

     Example:

          z = [0:0.05:5];
          plot3 (cos (2*pi*z), sin (2*pi*z), z, ";helix;");
          plot3 (z, exp (2i*pi*z), ";complex sinusoid;");

     See also: *note ezplot3: XREFezplot3, *note plot: XREFplot.


 -- Function File:  view (AZIMUTH, ELEVATION)
 -- Function File:  view ([AZIMUTH ELEVATION])
 -- Function File:  view ([X Y Z])
 -- Function File:  view (2)
 -- Function File:  view (3)
 -- Function File:  view (HAX, ...)
 -- Function File: [AZIMUTH, ELEVATION] = view ()
     Query or set the viewpoint for the current axes.

     The parameters AZIMUTH and ELEVATION can be given as two arguments
     or as 2-element vector.  The viewpoint can also be specified with
     Cartesian coordinates X, Y, and Z.

     The call `view (2)' sets the viewpoint to AZIMUTH = 0 and
     ELEVATION = 90, which is the default for 2-D graphs.

     The call `view (3)' sets the viewpoint to AZIMUTH = -37.5 and
     ELEVATION = 30, which is the default for 3-D graphs.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by `gca'.

     If no inputs are given, return the current AZIMUTH and ELEVATION.

 -- Function File:  slice (X, Y, Z, V, SX, SY, SZ)
 -- Function File:  slice (X, Y, Z, V, XI, YI, ZI)
 -- Function File:  slice (V, SX, SY, SZ)
 -- Function File:  slice (V, XI, YI, ZI)
 -- Function File:  slice (..., METHOD)
 -- Function File:  slice (HAX, ...)
 -- Function File: H = slice (...)
     Plot slices of 3-D data/scalar fields.

     Each element of the 3-dimensional array V represents a scalar
     value at a location given by the parameters X, Y, and Z.  The
     parameters X, X, and Z are either 3-dimensional arrays of the same
     size as the array V in the "meshgrid" format or vectors.  The
     parameters XI, etc. respect a similar format to X, etc., and they
     represent the points at which the array VI is interpolated using
     interp3.  The vectors SX, SY, and SZ contain points of orthogonal
     slices of the respective axes.

     If X, Y, Z are omitted, they are assumed to be `x = 1:size (V,
     2)', `y = 1:size (V, 1)' and `z = 1:size (V, 3)'.

     METHOD is one of:

    "nearest"
          Return the nearest neighbor.

    "linear"
          Linear interpolation from nearest neighbors.

    "cubic"
          Cubic interpolation from four nearest neighbors (not
          implemented yet).

    "spline"
          Cubic spline interpolation--smooth first and second
          derivatives throughout the curve.

     The default method is "linear".

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Examples:

          [x, y, z] = meshgrid (linspace (-8, 8, 32));
          v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
          slice (x, y, z, v, [], 0, []);

          [xi, yi] = meshgrid (linspace (-7, 7));
          zi = xi + yi;
          slice (x, y, z, v, xi, yi, zi);

     See also: *note interp3: XREFinterp3, *note surface: XREFsurface,
     *note pcolor: XREFpcolor.


 -- Function File:  ribbon (Y)
 -- Function File:  ribbon (X, Y)
 -- Function File:  ribbon (X, Y, WIDTH)
 -- Function File:  ribbon (HAX, ...)
 -- Function File: H = ribbon (...)
     Plot a ribbon plot for the columns of Y vs. X.

     The optional parameter WIDTH specifies the width of a single ribbon
     (default is 0.75).  If X is omitted, a vector containing the row
     numbers is assumed (`1:rows (Y)').

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a vector of graphics handles to the
     surface objects representing each ribbon.

     See also: *note surface: XREFsurface, *note waterfall:
     XREFwaterfall.


 -- Function File:  shading (TYPE)
 -- Function File:  shading (HAX, TYPE)
     Set the shading of patch or surface graphic objects.

     Valid arguments for TYPE are

    "flat"
          Single colored patches with invisible edges.

    "faceted"
          Single colored patches with visible edges.

    "interp"
          Color between patch vertices are interpolated and the patch
          edges are invisible.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     See also: *note fill: XREFfill, *note mesh: XREFmesh, *note patch:
     XREFpatch, *note pcolor: XREFpcolor, *note surf: XREFsurf, *note
     surface: XREFsurface, *note hidden: XREFhidden.


 -- Function File:  scatter3 (X, Y, Z)
 -- Function File:  scatter3 (X, Y, Z, S)
 -- Function File:  scatter3 (X, Y, Z, S, C)
 -- Function File:  scatter3 (..., STYLE)
 -- Function File:  scatter3 (..., "filled")
 -- Function File:  scatter3 (..., PROP, VAL)
 -- Function File:  scatter3 (HAX, ...)
 -- Function File: H = scatter3 (...)
     Draw a 3-D scatter plot.

     A marker is plotted at each point defined by the coordinates in
     the vectors X, Y, and Z.

     The size of the markers is determined by S, which can be a scalar
     or a vector of the same length as X, Y, and Z.  If S is not given,
     or is an empty matrix, then a default value of 8 points is used.

     The color of the markers is determined by C, which can be a string
     defining a fixed color; a 3-element vector giving the red, green,
     and blue components of the color; a vector of the same length as X
     that gives a scaled index into the current colormap; or an Nx3
     matrix defining the RGB color of each marker individually.

     The marker to use can be changed with the STYLE argument, that is a
     string defining a marker in the same manner as the `plot' command.
     If no marker is specified it defaults to "o" or circles.  If the
     argument "filled" is given then the markers are filled.

     Additional property/value pairs are passed directly to the
     underlying patch object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the hggroup
     object representing the points.

          [x, y, z] = peaks (20);
          scatter3 (x(:), y(:), z(:), [], z(:));

     See also: *note scatter: XREFscatter, *note patch: XREFpatch,
     *note plot: XREFplot.


 -- Function File:  waterfall (X, Y, Z)
 -- Function File:  waterfall (Z)
 -- Function File:  waterfall (..., C)
 -- Function File:  waterfall (..., PROP, VAL, ...)
 -- Function File:  waterfall (HAX, ...)
 -- Function File: H = waterfall (...)
     Plot a 3-D waterfall plot.

     A waterfall plot is similar to a `meshz' plot except only mesh
     lines for the rows of Z (x-values) are shown.

     The wireframe mesh is plotted using rectangles.  The vertices of
     the rectangles [X, Y] are typically the output of `meshgrid'.
     over a 2-D rectangular region in the x-y plane.  Z determines the
     height above the plane of each vertex.  If only a single Z matrix
     is given, then it is plotted over the meshgrid `X = 1:columns (Z),
     Y = 1:rows (Z)'.  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     The color of the mesh is computed by linearly scaling the Z values
     to fit the range of the current colormap.  Use `caxis' and/or
     change the colormap to control the appearance.

     Optionally the color of the mesh can be specified independently of
     Z by supplying a color matrix, C.

     Any property/value pairs are passed directly to the underlying
     surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: *note meshz: XREFmeshz, *note mesh: XREFmesh, *note
     meshc: XREFmeshc, *note contour: XREFcontour, *note surf:
     XREFsurf, *note surface: XREFsurface, *note ribbon: XREFribbon,
     *note meshgrid: XREFmeshgrid, *note hidden: XREFhidden, *note
     shading: XREFshading, *note colormap: XREFcolormap, *note caxis:
     XREFcaxis.


* Menu:

* Aspect Ratio::
* Three-dimensional Function Plotting::
* Three-dimensional Geometric Shapes::


File: octave.info,  Node: Aspect Ratio,  Next: Three-dimensional Function Plotting,  Up: Three-Dimensional Plots

15.2.2.1 Aspect Ratio
.....................

For three-dimensional plots the aspect ratio can be set for data with
`daspect' and for the plot box with `pbaspect'.  *Note Axis
Configuration::, for controlling the x-, y-, and z-limits for plotting.

 -- Function File: DATA_ASPECT_RATIO = daspect ()
 -- Function File:  daspect (DATA_ASPECT_RATIO)
 -- Function File:  daspect (MODE)
 -- Function File: DATA_ASPECT_RATIO_MODE = daspect ("mode")
 -- Function File:  daspect (HAX, ...)
     Query or set the data aspect ratio of the current axes.

     The aspect ratio is a normalized 3-element vector representing the
     span of the x, y, and z-axis limits.

     `(daspect (MODE))'

     Set the data aspect ratio mode of the current axes.  MODE is
     either "auto" or "manual".

     `daspect ("mode")'

     Return the data aspect ratio mode of the current axes.

     `daspect (HAX, ...)'

     Operate on the axes in handle HAX instead of the current axes.

     See also: *note axis: XREFaxis, *note pbaspect: XREFpbaspect,
     *note xlim: XREFxlim, *note ylim: XREFylim, *note zlim: XREFzlim.


 -- Function File: PLOT_BOX_ASPECT_RATIO = pbaspect ( )
 -- Function File:  pbaspect (PLOT_BOX_ASPECT_RATIO)
 -- Function File:  pbaspect (MODE)
 -- Function File: PLOT_BOX_ASPECT_RATIO_MODE = pbaspect ("mode")
 -- Function File:  pbaspect (HAX, ...)
     Query or set the plot box aspect ratio of the current axes.

     The aspect ratio is a normalized 3-element vector representing the
     rendered lengths of the x, y, and z axes.

     `pbaspect(MODE)'

     Set the plot box aspect ratio mode of the current axes.  MODE is
     either "auto" or "manual".

     `pbaspect ("mode")'

     Return the plot box aspect ratio mode of the current axes.

     `pbaspect (HAX, ...)'

     Operate on the axes in handle HAX instead of the current axes.

     See also: *note axis: XREFaxis, *note daspect: XREFdaspect, *note
     xlim: XREFxlim, *note ylim: XREFylim, *note zlim: XREFzlim.



File: octave.info,  Node: Three-dimensional Function Plotting,  Next: Three-dimensional Geometric Shapes,  Prev: Aspect Ratio,  Up: Three-Dimensional Plots

15.2.2.2 Three-dimensional Function Plotting
............................................

 -- Function File:  ezplot3 (FX, FY, FZ)
 -- Function File:  ezplot3 (..., DOM)
 -- Function File:  ezplot3 (..., N)
 -- Function File:  ezplot3 (HAX, ...)
 -- Function File: H = ezplot3 (...)
     Plot a parametrically defined curve in three dimensions.

     FX, FY, and FZ are strings, inline functions, or function handles
     with one argument defining the function.  By default the plot is
     over the domain `0 <= T <= 2*pi' with 500 points.

     If DOM is a two element vector, it represents the minimum and
     maximum values of T.

     N is a scalar defining the number of points to use in plotting the
     function.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     plot.

          fx = @(t) cos (t);
          fy = @(t) sin (t);
          fz = @(t) t;
          ezplot3 (fx, fy, fz, [0, 10*pi], 100);

     See also: *note plot3: XREFplot3, *note ezplot: XREFezplot, *note
     ezmesh: XREFezmesh, *note ezsurf: XREFezsurf.


 -- Function File:  ezmesh (F)
 -- Function File:  ezmesh (FX, FY, FZ)
 -- Function File:  ezmesh (..., DOM)
 -- Function File:  ezmesh (..., N)
 -- Function File:  ezmesh (..., "circ")
 -- Function File:  ezmesh (HAX, ...)
 -- Function File: H = ezmesh (...)
     Plot the mesh defined by a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain `-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function `[FX (S, T), FY (S, T), FZ (S, T)]'.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are `[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the argument "circ" is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Example 1: 2-argument function

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezmesh (f, [-3, 3]);

     Example 2: parametrically defined function

          fx = @(s,t) cos (s) .* cos (t);
          fy = @(s,t) sin (s) .* cos (t);
          fz = @(s,t) sin (t);
          ezmesh (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);

     See also: *note mesh: XREFmesh, *note ezmeshc: XREFezmeshc, *note
     ezplot: XREFezplot, *note ezsurf: XREFezsurf, *note ezsurfc:
     XREFezsurfc, *note hidden: XREFhidden.


 -- Function File:  ezmeshc (F)
 -- Function File:  ezmeshc (FX, FY, FZ)
 -- Function File:  ezmeshc (..., DOM)
 -- Function File:  ezmeshc (..., N)
 -- Function File:  ezmeshc (..., "circ")
 -- Function File:  ezmeshc (HAX, ...)
 -- Function File: H = ezmeshc (...)
     Plot the mesh and contour lines defined by a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain `-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function `[FX (S, T), FY (S, T), FZ (S, T)]'.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are `[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the argument "circ" is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a 2-element vector with a graphics
     handle for the created mesh plot and a second handle for the
     created contour plot.

     Example: 2-argument function

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezmeshc (f, [-3, 3]);

     See also: *note meshc: XREFmeshc, *note ezmesh: XREFezmesh, *note
     ezplot: XREFezplot, *note ezsurf: XREFezsurf, *note ezsurfc:
     XREFezsurfc, *note hidden: XREFhidden.


 -- Function File:  ezsurf (F)
 -- Function File:  ezsurf (FX, FY, FZ)
 -- Function File:  ezsurf (..., DOM)
 -- Function File:  ezsurf (..., N)
 -- Function File:  ezsurf (..., "circ")
 -- Function File:  ezsurf (HAX, ...)
 -- Function File: H = ezsurf (...)
     Plot the surface defined by a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain `-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function `[FX (S, T), FY (S, T), FZ (S, T)]'.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are `[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the argument "circ" is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     Example 1: 2-argument function

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezsurf (f, [-3, 3]);

     Example 2: parametrically defined function

          fx = @(s,t) cos (s) .* cos (t);
          fy = @(s,t) sin (s) .* cos (t);
          fz = @(s,t) sin (t);
          ezsurf (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);

     See also: *note surf: XREFsurf, *note ezsurfc: XREFezsurfc, *note
     ezplot: XREFezplot, *note ezmesh: XREFezmesh, *note ezmeshc:
     XREFezmeshc, *note shading: XREFshading.


 -- Function File:  ezsurfc (F)
 -- Function File:  ezsurfc (FX, FY, FZ)
 -- Function File:  ezsurfc (..., DOM)
 -- Function File:  ezsurfc (..., N)
 -- Function File:  ezsurfc (..., "circ")
 -- Function File:  ezsurfc (HAX, ...)
 -- Function File: H = ezsurfc (...)
     Plot the surface and contour lines defined by a function.

     F is a string, inline function, or function handle with two
     arguments defining the function.  By default the plot is over the
     meshed domain `-2*pi <= X | Y <= 2*pi' with 60 points in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function `[FX (S, T), FY (S, T), FZ (S, T)]'.

     If DOM is a two element vector, it represents the minimum and
     maximum values of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum values are `[xmin xmax ymin ymax]'.

     N is a scalar defining the number of points to use in each
     dimension.

     If the argument "circ" is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a 2-element vector with a graphics
     handle for the created surface plot and a second handle for the
     created contour plot.

     Example:

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezsurfc (f, [-3, 3]);

     See also: *note surfc: XREFsurfc, *note ezsurf: XREFezsurf, *note
     ezplot: XREFezplot, *note ezmesh: XREFezmesh, *note ezmeshc:
     XREFezmeshc, *note shading: XREFshading.



File: octave.info,  Node: Three-dimensional Geometric Shapes,  Prev: Three-dimensional Function Plotting,  Up: Three-Dimensional Plots

15.2.2.3 Three-dimensional Geometric Shapes
...........................................

 -- Command:  cylinder
 -- Function File:  cylinder (R)
 -- Function File:  cylinder (R, N)
 -- Function File:  cylinder (HAX, ...)
 -- Function File: [X, Y, Z] = cylinder (...)
     Plot a 3-D unit cylinder.

     The optional input R is a vector specifying the radius along the
     unit z-axis.  The default is [1 1] indicating radius 1 at `Z == 0'
     and at `Z == 1'.

     The optional input N determines the number of faces around the the
     circumference of the cylinder.  The default value is 20.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     If outputs are requested `cylinder' returns three matrices in
     `meshgrid' format, such that `surf (X, Y, Z)' generates a unit
     cylinder.

     Example:

          [x, y, z] = cylinder (10:-1:0, 50);
          surf (x, y, z);
          title ("a cone");

     See also: *note ellipsoid: XREFellipsoid, *note rectangle:
     XREFrectangle, *note sphere: XREFsphere.


 -- Function File:  sphere ()
 -- Function File:  sphere (N)
 -- Function File:  sphere (HAX, ...)
 -- Function File: [X, Y, Z] = sphere (...)
     Plot a 3-D unit sphere.

     The optional input N determines the number of faces around the the
     circumference of the sphere.  The default value is 20.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     If outputs are requested `sphere' returns three matrices in
     `meshgrid' format such that `surf (X, Y, Z)' generates a unit
     sphere.

     Example:

          [x, y, z] = sphere (40);
          surf (3*x, 3*y, 3*z);
          axis equal;
          title ("sphere of radius 3");

     See also: *note cylinder: XREFcylinder, *note ellipsoid:
     XREFellipsoid, *note rectangle: XREFrectangle.


 -- Function File:  ellipsoid (XC, YC, ZC, XR, YR, ZR, N)
 -- Function File:  ellipsoid (..., N)
 -- Function File:  ellipsoid (HAX, ...)
 -- Function File: [X, Y, Z] = ellipsoid (...)
     Plot a 3-D ellipsoid.

     The inputs XC, YC, ZC specify the center of the ellipsoid.  The
     inputs XR, YR, ZR specify the semi-major axis lengths.

     The optional input N determines the number of faces around the the
     circumference of the cylinder.  The default value is 20.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     If outputs are requested `ellipsoid' returns three matrices in
     `meshgrid' format, such that `surf (X, Y, Z)' generates the
     ellipsoid.

     See also: *note cylinder: XREFcylinder, *note rectangle:
     XREFrectangle, *note sphere: XREFsphere.



File: octave.info,  Node: Plot Annotations,  Next: Multiple Plots on One Page,  Prev: Three-Dimensional Plots,  Up: High-Level Plotting

15.2.3 Plot Annotations
-----------------------

You can add titles, axis labels, legends, and arbitrary text to an
existing plot.  For example:

     x = -10:0.1:10;
     plot (x, sin (x));
     title ("sin(x) for x = -10:0.1:10");
     xlabel ("x");
     ylabel ("sin (x)");
     text (pi, 0.7, "arbitrary text");
     legend ("sin (x)");

   The functions `grid' and `box' may also be used to add grid and
border lines to the plot.  By default, the grid is off and the border
lines are on.

 -- Function File:  title (STRING)
 -- Function File:  title (STRING, PROP, VAL, ...)
 -- Function File:  title (HAX, ...)
 -- Function File: H = title (...)
     Specify the string used as a title for the current axis.

     An optional list of PROPERTY/VALUE pairs can be used to change the
     appearance of the created title text object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     text object.

     See also: *note xlabel: XREFxlabel, *note ylabel: XREFylabel,
     *note zlabel: XREFzlabel, *note text: XREFtext.


 -- Function File:  legend (STR1, STR2, ...)
 -- Function File:  legend (MATSTR)
 -- Function File:  legend (CELLSTR)
 -- Function File:  legend (..., "location", POS)
 -- Function File:  legend (..., "orientation", ORIENT)
 -- Function File:  legend (HAX, ...)
 -- Function File:  legend (HOBJS, ...)
 -- Function File:  legend (HAX, HOBJS, ...)
 -- Function File:  legend ("OPTION")
 -- Function File: [HLEG, HLEG_OBJ, HPLOT, LABELS] = legend (...)
     Display a legend for the current axes using the specified strings
     as labels.

     Legend entries may be specified as individual character string
     arguments, a character array, or a cell array of character strings.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.  If the
     handles, HOBJS, are not specified then the legend's strings will
     be associated with the axes' descendants.  `legend' works on line
     graphs, bar graphs, etc.  A plot must exist before legend is
     called.

     The optional parameter POS specifies the location of the legend as
     follows:

          pos       location of the legend
     ---------------------------------------------------------------------- 
          north     center top
          south     center bottom
          east      right center
          west      left center
          northeast right top (default)
          northwest left top
          southeast right bottom
          southwest left bottom

          outside   can be appended to any location string

     The optional parameter ORIENT determines if the key elements are
     placed vertically or horizontally.  The allowed values are
     "vertical" (default) or "horizontal".

     The following customizations are available using OPTION:

    "show"
          Show legend on the plot

    "hide"
          Hide legend on the plot

    "toggle"
          Toggles between "hide" and "show"

    "boxon"
          Show a box around legend

    "boxoff"
          Hide the box around legend

    "left"
          Place label text to the left of the keys

    "right"
          Place label text to the right of the keys

    "off"
          Delete the legend object

     The optional output values are

    HLEG
          The graphics handle of the legend object.

    HLEG_OBJ
          Graphics handles to the text and line objects which make up
          the legend.

    HPLOT
          Graphics handles to the plot objects which were used in
          making the legend.

    LABELS
          A cell array of strings of the labels in the legend.

     The legend label text is either provided in the call to `legend' or
     is taken from the DisplayName property of graphics objects.  If no
     labels or DisplayNames are available, then the label text is simply
     "data1", "data2", ..., "dataN".

     Implementation Note: A legend is implemented as an additional axes
     object of the current figure with the "tag" set to "legend".
     Properties of the legend object may be manipulated directly by
     using `set'.

 -- Function File:  text (X, Y, STRING)
 -- Function File:  text (X, Y, Z, STRING)
 -- Function File:  text (..., PROP, VAL, ...)
 -- Function File: H = text (...)
     Create a text object with text STRING at position X, Y, Z on the
     current axes.

     Optional property/value pairs following may be used to specify the
     appearance of the text.

     The optional return value H is a graphics handle to the created
     text object.

     See also: *note gtext: XREFgtext, *note title: XREFtitle, *note
     xlabel: XREFxlabel, *note ylabel: XREFylabel, *note zlabel:
     XREFzlabel.


   See *note Text Properties:: for the properties that you can set.

 -- Function File:  xlabel (STRING)
 -- Function File:  xlabel (STRING, PROPERTY, VAL, ...)
 -- Function File:  xlabel (HAX, ...)
 -- Function File: H = xlabel (...)
     Specify the string used to label the x-axis of the current axis.

     An optional list of PROPERTY/VALUE pairs can be used to change the
     properties of the created text label.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     text object.

     See also: *note ylabel: XREFylabel, *note zlabel: XREFzlabel,
     *note datetick: XREFdatetick, *note title: XREFtitle, *note text:
     XREFtext.


 -- Function File:  clabel (C, H)
 -- Function File:  clabel (C, H, V)
 -- Function File:  clabel (C, H, "manual")
 -- Function File:  clabel (C)
 -- Function File:  clabel (..., PROP, VAL, ...)
 -- Function File: H = clabel (...)
     Add labels to the contours of a contour plot.

     The contour levels are specified by the contour matrix C which is
     returned by `contour', `contourc', `contourf', and `contour3'.
     Contour labels are rotated to match the local line orientation and
     centered on the line.  The position of labels along the contour
     line is chosen randomly.

     If the argument H is a handle to a contour group object, then label
     this plot rather than the one in the current axes returned by
     `gca'.

     By default, all contours are labeled.  However, the contours to
     label can be specified by the vector V.  If the "manual" argument
     is given then the contours to label can be selected with the mouse.

     Additional property/value pairs that are valid properties of text
     objects can be given and are passed to the underlying text
     objects.  Moreover, the contour group property "LabelSpacing" is
     available which determines the spacing between labels on a contour
     to be specified.  The default is 144 points, or 2 inches.

     The optional return value H is a vector of graphics handles to the
     text objects representing each label.  The "userdata" property of
     the text objects contains the numerical value of the contour label.

     An example of the use of `clabel' is

          [c, h] = contour (peaks (), -4 : 6);
          clabel (c, h, -4:2:6, "fontsize", 12);

     See also: *note contour: XREFcontour, *note contourf:
     XREFcontourf, *note contour3: XREFcontour3, *note meshc:
     XREFmeshc, *note surfc: XREFsurfc, *note text: XREFtext.


 -- Command:  box on
 -- Command:  box off
 -- Command:  box
 -- Function File:  box (HAX, ...)
     Control display of the axis border.

     The argument may be either "on" or "off".  If it is omitted, the
     current box state is toggled.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by `gca'.

     See also: *note axis: XREFaxis, *note grid: XREFgrid.


 -- Command:  grid
 -- Command:  grid on
 -- Command:  grid off
 -- Command:  grid minor
 -- Command:  grid minor on
 -- Command:  grid minor off
 -- Function File:  grid (HAX, ...)
     Control the display of plot grid lines.

     The function state input may be either "on" or "off".  If it is
     omitted, the current grid state is toggled.

     When the first argument is "minor" all subsequent commands modify
     the minor grid rather than the major grid.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by `gca'.

     To control the grid lines for an individual axis use the `set'
     function.  For example:

          set (gca, "ygrid", "on");

     See also: *note axis: XREFaxis, *note box: XREFbox.


 -- Command:  colorbar
 -- Function File:  colorbar (LOC)
 -- Function File:  colorbar (DELETE_OPTION)
 -- Function File:  colorbar (HCB, ...)
 -- Function File:  colorbar (HAX, ...)
 -- Function File:  colorbar (..., "peer", HAX, ...)
 -- Function File:  colorbar (..., "location", LOC, ...)
 -- Function File:  colorbar (..., PROP, VAL, ...)
 -- Function File: H = colorbar (...)
     Add a colorbar to the current axes.

     A colorbar displays the current colormap along with numerical
     rulings so that the color scale can be interpreted.

     The optional input LOC determines the location of the colorbar.
     Valid values for LOC are

    "EastOutside"
          Place the colorbar outside the plot to the right.  This is
          the default.

    "East"
          Place the colorbar inside the plot to the right.

    "WestOutside"
          Place the colorbar outside the plot to the left.

    "West"
          Place the colorbar inside the plot to the left.

    "NorthOutside"
          Place the colorbar above the plot.

    "North"
          Place the colorbar at the top of the plot.

    "SouthOutside"
          Place the colorbar under the plot.

    "South"
          Place the colorbar at the bottom of the plot.

     To remove a colorbar from a plot use any one of the following
     keywords for the DELETE_OPTION: "delete", "hide", "off".

     If the argument "peer" is given, then the following argument is
     treated as the axes handle in which to add the colorbar.
     Alternatively, If the first argument HAX is an axes handle, then
     the colorbar is added to this axis, rather than the current axes
     returned by `gca'.

     If the first argument HCB is a handle to a colorbar object, then
     operate on this colorbar directly.

     Additional property/value pairs are passed directly to the
     underlying axes object.

     The optional return value H is a graphics handle to the created
     colorbar object.

     Implementation Note: A colorbar is created as an additional axes
     to the current figure with the "tag" property set to "colorbar".
     The created axes object has the extra property "location" which
     controls the positioning of the colorbar.

     See also: *note colormap: XREFcolormap.



File: octave.info,  Node: Multiple Plots on One Page,  Next: Multiple Plot Windows,  Prev: Plot Annotations,  Up: High-Level Plotting

15.2.4 Multiple Plots on One Page
---------------------------------

Octave can display more than one plot in a single figure.  The simplest
way to do this is to use the `subplot' function to divide the plot area
into a series of subplot windows that are indexed by an integer.  For
example,

     subplot (2, 1, 1)
     fplot (@sin, [-10, 10]);
     subplot (2, 1, 2)
     fplot (@cos, [-10, 10]);

creates a figure with two separate axes, one displaying a sine wave and
the other a cosine wave.  The first call to subplot divides the figure
into two plotting areas (two rows and one column) and makes the first
plot area active.  The grid of plot areas created by `subplot' is
numbered in column-major order (top to bottom, left to right).

 -- Function File:  subplot (ROWS, COLS, INDEX)
 -- Function File:  subplot (RCN)
 -- Function File:  subplot (..., "align")
 -- Function File: HAX = subplot (...)
 -- Function File: HAX = subplot (...)
     Set up a plot grid with ROWS by COLS subwindows and set the
     current axes for plotting to the location given by INDEX.

     If only one numeric argument is supplied, then it must be a three
     digit value specifying the location in digits 1 (rows) and 2
     (columns) and the plot index in digit 3.

     The plot index runs row-wise.  First all the columns in a row are
     numbered and then the next row is filled.

     For example, a plot with 2 by 3 grid will have plot indices
     running as follows:

          +-----+-----+-----+
          |  1  |  2  |  3  |
          +-----+-----+-----+
          |  4  |  5  |  6  |
          +-----+-----+-----+

     INDEX may also be a vector.  In this case, the new axis will
     enclose the grid locations specified.  The first demo illustrates
     an example:

          demo ("subplot", 1)

     If the option "align" is given then the plot boxes of the
     subwindows will align, but this may leave no room for axis tick
     marks or labels.

     If the output HAX is requested, subplot returns the axis handle for
     the subplot.  This is useful for modifying the properties of a
     subplot.

     See also: *note axes: XREFaxes, *note plot: XREFplot.



File: octave.info,  Node: Multiple Plot Windows,  Next: Manipulation of Plot Windows,  Prev: Multiple Plots on One Page,  Up: High-Level Plotting

15.2.5 Multiple Plot Windows
----------------------------

You can open multiple plot windows using the `figure' function.  For
example,

     figure (1);
     fplot (@sin, [-10, 10]);
     figure (2);
     fplot (@cos, [-10, 10]);

creates two figures, with the first displaying a sine wave and the
second a cosine wave.  Figure numbers must be positive integers.

 -- Command:  figure
 -- Command:  figure N
 -- Function File:  figure (N)
 -- Function File:  figure (..., "PROPERTY", VALUE, ...)
 -- Function File: H = figure (DOTS)
     Create a new figure window for plotting.

     If no arguments are specified, a new figure with the next
     available number is created.

     If called with an integer N, and no such numbered figure exists,
     then a new figure with the specified number is created.  If the
     figure already exists then it is made visible and becomes the
     current figure for plotting.

     Multiple property-value pairs may be specified for the figure
     object, but they must appear in pairs.

     The optional return value H is a graphics handle to the created
     figure object.

     See also: *note axes: XREFaxes, *note gcf: XREFgcf, *note clf:
     XREFclf, *note close: XREFclose.



File: octave.info,  Node: Manipulation of Plot Windows,  Next: Use of the `interpreter' Property,  Prev: Multiple Plot Windows,  Up: High-Level Plotting

15.2.6 Manipulation of Plot Windows
-----------------------------------

By default, Octave refreshes the plot window when a prompt is printed,
or when waiting for input.  The `drawnow' function is used to cause a
plot window to be updated.

 -- Built-in Function:  drawnow ()
 -- Built-in Function:  drawnow ("expose")
 -- Built-in Function:  drawnow (TERM, FILE, MONO, DEBUG_FILE)
     Update figure windows and their children.  The event queue is
     flushed and any callbacks generated are executed.  With the
     optional argument "expose", only graphic objects are updated and
     no other events or callbacks are processed.  The third calling
     form of `drawnow' is for debugging and is undocumented.

   Only figures that are modified will be updated.  The `refresh'
function can also be used to force an update of the current figure,
even if it is not modified.

 -- Function File:  refresh ()
 -- Function File:  refresh (H)
     Refresh a figure, forcing it to be redrawn.

     When called without an argument the current figure is redrawn.
     Otherwise, the figure with graphic handle H is redrawn.

     See also: *note drawnow: XREFdrawnow.


   Normally, high-level plot functions like `plot' or `mesh' call
`newplot' to initialize the state of the current axes so that the next
plot is drawn in a blank window with default property settings.  To
have two plots superimposed over one another, use the `hold' function.
For example,

     hold on;
     x = -10:0.1:10;
     plot (x, sin (x));
     plot (x, cos (x));
     hold off;

displays sine and cosine waves on the same axes.  If the hold state is
off, consecutive plotting commands like this will only display the last
plot.

 -- Function File:  newplot ()
 -- Function File:  newplot (HFIG)
 -- Function File:  newplot (HAX)
 -- Function File: HAX = newplot (...)
     Prepare graphics engine to produce a new plot.

     This function is called at the beginning of all high-level plotting
     functions.  It is not normally required in user programs.
     `newplot' queries the "NextPlot" field of the current figure and
     axis to determine what to do.

     Figure NextPlot   Action
     --------------------------------------------------------------------- 
     "new"             Create a new figure and make it the current
                       figure.
     "add" (default)   Add new graphic objects to the current figure.
     "replacechildren" Delete child objects whose HandleVisibility is
                       set to "on".  Set NextPlot property to "add".
                       This typically clears a figure, but leaves in
                       place hidden objects such as menubars.  This is
                       equivalent to `clf'.
     "replace"         Delete all child objects of the figure and reset
                       all figure properties to their defaults.
                       However, the following four properties are not
                       reset: Position, Units, PaperPosition, PaperUnits.
                       This is equivalent to `clf reset'.

     Axis NextPlot     Action
     --------------------------------------------------------------------- 
     "add"             Add new graphic objects to the current axes.
                       This is equivalent to `hold on'.
     "replacechildren" Delete child objects whose HandleVisibility is
                       set to "on", but leave axis properties
                       unmodified.  This typically clears a plot, but
                       preserves special settings such as log scaling for
                       axes.  This is equivalent to `cla'.
     "replace"         Delete all child objects of the axis and reset
     (default)         all axis properties to their defaults.  However,
                       the following properties are not reset: Position,
                       Units.  This is equivalent to `cla reset'.

     If the optional input HFIG or HAX is given then prepare the
     specified figure or axes rather than the current figure and axes.

     The optional return value HAX is a graphics handle to the created
     axes object (not figure).

     *Caution:* Calling `newplot' may change the current figure and
     current axis.

 -- Command:  hold
 -- Command:  hold on
 -- Command:  hold off
 -- Command:  hold all
 -- Function File:  hold (HAX, ...)
     Toggle or set the "hold" state of the plotting engine which
     determines whether new graphic objects are added to the plot or
     replace the existing objects.

    `hold on'
          Retain plot data and settings so that subsequent plot
          commands are displayed on a single graph.

    `hold all'
          Retain plot line color, line style, data, and settings so
          that subsequent plot commands are displayed on a single graph
          with the next line color and style.

    `hold off'
          Restore default graphics settings which clear the graph and
          reset axis properties before each new plot command.
          (default).

    `hold'
          Toggle the current hold state.

     When given the additional argument HAX, the hold state is modified
     for this axis rather than the current axes returned by `gca'.

     To query the current hold state use the `ishold' function.

     See also: *note ishold: XREFishold, *note cla: XREFcla, *note clf:
     XREFclf, *note newplot: XREFnewplot.


 -- Command:  ishold
 -- Function File:  ishold (HAX)
 -- Function File:  ishold (HFIG)
     Return true if the next plot will be added to the current plot, or
     false if the plot device will be cleared before drawing the next
     plot.

     If the first argument is an axes handle HAX or figure handle HFIG
     then operate on this plot rather than the current one.

     See also: *note hold: XREFhold, *note newplot: XREFnewplot.


   To clear the current figure, call the `clf' function.  To clear the
current axis, call the `cla' function.  To bring the current figure to
the top of the window stack, call the `shg' function.  To delete a
graphics object, call `delete' on its index.  To close the figure
window, call the `close' function.

 -- Command:  clf
 -- Command:  clf reset
 -- Function File:  clf (HFIG)
 -- Function File:  clf (HFIG, "reset")
 -- Function File: H = clf (...)
     Clear the current figure window.

     `clf' operates by deleting child graphics objects with visible
     handles (HandleVisibility = "on").

     If the optional argument "reset" is specified, delete all child
     objects including those with hidden handles and reset all figure
     properties to their defaults.  However, the following properties
     are not reset: Position, Units, PaperPosition, PaperUnits.

     If the first argument HFIG is a figure handle, then operate on
     this figure rather than the current figure returned by `gcf'.

     The optional return value H is the graphics handle of the figure
     window that was cleared.

     See also: *note cla: XREFcla, *note close: XREFclose, *note
     delete: XREFdelete.


 -- Command:  cla
 -- Command:  cla reset
 -- Function File:  cla (HAX)
 -- Function File:  cla (HAX, "reset")
     Clear the current axes.

     `cla' operates by deleting child graphic objects with visible
     handles (HandleVisibility = "on").

     If the optional argument "reset" is specified, delete all child
     objects including those with hidden handles and reset all axis
     properties to their defaults.  However, the following properties
     are not reset: Position, Units.

     If the first argument HAX is an axes handle, then operate on this
     axis rather than the current axes returned by `gca'.

     See also: *note clf: XREFclf.


 -- Command:  shg
     Show the graph window.

     Currently, this is the same as executing `drawnow'.

     See also: *note drawnow: XREFdrawnow, *note figure: XREFfigure.


 -- Function File:  delete (FILE)
 -- Function File:  delete (HANDLE)
     Delete the named file or graphics handle.

     Deleting graphics objects is the proper way to remove features
     from a plot without clearing the entire figure.

     See also: *note clf: XREFclf, *note cla: XREFcla, *note unlink:
     XREFunlink.


 -- Command:  close
 -- Command:  close (H)
 -- Command:  close all
 -- Command:  close all hidden
     Close figure window(s).

     `close' operates by calling the function specified by the
     "closerequestfcn" property for each figure.  By default, the
     function `closereq' is used.

     When called with no arguments, close the current figure.  This is
     equivalent to `close (gcf)'.  If the input H is a graphic handle,
     or vector of graphics handles, then close each figure in H.

     If the argument "all" is given then all figures with visible
     handles (HandleVisibility = "on") are closed.

     If the argument "all hidden" is given then all figures, including
     hidden ones, are closed.

     Implementation Note: `close' calls a function to dispose of the
     figure.  It is possible that the function will delay or abort
     removing the figure.  To remove a figure without executing any
     callback functions use `delete'.

     See also: *note closereq: XREFclosereq, *note delete: XREFdelete.


 -- Function File:  closereq ()
     Close the current figure and delete all graphics objects
     associated with it.

     See also: *note close: XREFclose, *note delete: XREFdelete.



File: octave.info,  Node: Use of the `interpreter' Property,  Next: Printing and Saving Plots,  Prev: Manipulation of Plot Windows,  Up: High-Level Plotting

15.2.7 Use of the `interpreter' Property
----------------------------------------

All text objects, including titles, labels, legends, and text, include
the property "interpreter", this property determines the manner in which
special control sequences in the text are rendered.  If the interpreter
is set to "none", then no rendering occurs.  At this point the "latex"
option is not implemented and so the "latex" interpreter also does not
interpret the text.

   The "tex" option implements a subset of TeX functionality in the
rendering of the text.  This allows the insertion of special characters
such as Greek or mathematical symbols within the text.  The special
characters are also inserted with a code starting with the back-slash
(\) character, as in the table *note tab:extended::.

   In addition, the formatting of the text can be changed within the
string with the codes

               \bf            Bold font                                   
               \it            Italic font                                 
               \sl            Oblique Font                                
               \rm            Normal font                                 

   These are be used in conjunction with the { and } characters to limit
the change in the font to part of the string.  For example,

     xlabel ('{\bf H} = a {\bf V}')

where the character 'a' will not appear in a bold font.  Note that to
avoid having Octave interpret the backslash characters in the strings,
the strings should be in single quotes.

   It is also possible to change the fontname and size within the text

        \fontname{FONTNAME}           Specify the font to use                     
        \fontsize{SIZE}               Specify the size of the font to use         

   Finally, the superscript and subscripting can be controlled with the
'^' and '_' characters.  If the '^' or '_' is followed by a {
character, then all of the block surrounded by the { } pair is super- or
sub-scripted.  Without the { } pair, only the character immediately
following the '^' or '_' is super- or sub-scripted.

          \forall            \exists            \ni                
          \cong              \Delta             \Phi               
          \Gamma             \vartheta          \Lambda            
          \Pi                \Theta             \Sigma             
          \varsigma          \Omega             \Xi                
          \Psi               \perp              \alpha             
          \beta              \chi               \delta             
          \epsilon           \phi               \gamma             
          \eta               \iota              \varphi            
          \kappa             \lambda            \mu                
          \nu                \o                 \pi                
          \theta             \rho               \sigma             
          \tau               \upsilon           \varpi             
          \omega             \xi                \psi               
          \zeta              \sim               \Upsilon           
          \prime             \leq               \infty             
          \clubsuit          \diamondsuit       \heartsuit         
          \spadesuit         \leftrightarrow    \leftarrow         
          \uparrow           \rightarrow        \downarrow         
          \circ              \pm                \geq               
          \times             \propto            \partial           
          \bullet            \div               \neq               
          \equiv             \approx            \ldots             
          \mid               \aleph             \Im                
          \Re                \wp                \otimes            
          \oplus             \oslash            \cap               
          \cup               \supset            \supseteq          
          \subset            \subseteq          \in                
          \notin             \angle             \bigrightriangledown
          \langle            \rangle            \nabla             
          \prod              \surd              \cdot              
          \neg               \wedge             \vee               
          \Leftrightarrow    \Leftarrow         \Uparrow           
          \Rightarrow        \Downarrow         \diamond           
          \copyright         \lfloor            \lceil             
          \rfloor            \rceil             \int               

Table 15.1: Available special characters in TeX mode

   A complete example showing the capabilities of the extended text is

     x = 0:0.01:3;
     plot (x, erf (x));
     hold on;
     plot (x,x,"r");
     axis ([0, 3, 0, 1]);
     text (0.65, 0.6175, strcat ('\leftarrow x = {2/\surd\pi',
     ' {\fontsize{16}\int_{\fontsize{8}0}^{\fontsize{8}x}}',
     ' e^{-t^2} dt} = 0.6175'))


File: octave.info,  Node: Printing and Saving Plots,  Next: Interacting with Plots,  Prev: Use of the `interpreter' Property,  Up: High-Level Plotting

15.2.8 Printing and Saving Plots
--------------------------------

The `print' command allows you to send plots to you printer and to save
plots in a variety of formats.  For example,

     print -dpsc

prints the current figure to a color PostScript printer.  And,

     print -deps foo.eps

saves the current figure to an encapsulated PostScript file called
`foo.eps'.

 -- Function File:  print ()
 -- Function File:  print (OPTIONS)
 -- Function File:  print (FILENAME, OPTIONS)
 -- Function File:  print (H, FILENAME, OPTIONS)
     Print a plot, or save it to a file.

     Both output formatted for printing (PDF and PostScript), and many
     bitmapped and vector image formats are supported.

     FILENAME defines the name of the output file.  If the file name
     has no suffix, one is inferred from the specified device and
     appended to the file name.  If no filename is specified, the
     output is sent to the printer.

     H specifies the handle of the figure to print.  If no handle is
     specified the current figure is used.

     For output to a printer, PostScript file, or PDF file, the paper
     size is specified by the figure's `papersize' property.  The
     location and size of the image on the page are specified by the
     figure's `paperposition' property.  The orientation of the page is
     specified by the figure's `paperorientation' property.

     The width and height of images are specified by the figure's
     `paperpositon(3:4)' property values.

     The `print' command supports many OPTIONS:

    `-fH'
          Specify the handle, H, of the figure to be printed.  The
          default is the current figure.

    `-PPRINTER'
          Set the PRINTER name to which the plot is sent if no FILENAME
          is specified.

    `-GGHOSTSCRIPT_COMMAND'
          Specify the command for calling Ghostscript.  For Unix and
          Windows the defaults are "gs" and "gswin32c", respectively.

    `-color'
    `-mono'
          Color or monochrome output.

    `-solid'
    `-dashed'
          Force all lines to be solid or dashed, respectively.

    `-portrait'
    `-landscape'
          Specify the orientation of the plot for printed output.  For
          non-printed output the aspect ratio of the output corresponds
          to the plot area defined by the "paperposition" property in
          the orientation specified.  This option is equivalent to
          changing the figure's "paperorientation" property.

    `-TextAlphaBits=N'
    `-GraphicsAlphaBits=N'
          Octave is able to produce output for various printers,
          bitmaps, and vector formats by using Ghostscript.  For bitmap
          and printer output anti-aliasing is applied using
          Ghostscript's TextAlphaBits and GraphicsAlphaBits options.
          The default number of bits for each is 4.  Allowed values for
          N are 1, 2, or 4.

    `-dDEVICE'
          The available output format is specified by the option DEVICE,
          and is one of:

         `ps'
         `ps2'
         `psc'
         `psc2'
               PostScript (level 1 and 2, mono and color).  The FLTK
               graphics toolkit generates PostScript level 3.0.

         `eps'
         `eps2'
         `epsc'
         `epsc2'
               Encapsulated PostScript (level 1 and 2, mono and color).
               The FLTK graphic toolkit generates PostScript level 3.0.

         `tex'
         `epslatex'
         `epslatexstandalone'
         `pstex'
         `pslatex'
         `pdflatex'
               Generate a LaTeX (or TeX) file for labels and eps/ps/pdf
               for graphics.  The file produced by `epslatexstandalone'
               can be processed directly by LaTeX.  The other formats
               are intended to be included in a LaTeX (or TeX)
               document.  The `tex' device is the same as the
               `epslatex' device.  The `pdflatex' device is only
               available for the FLTK graphics toolkit.

         `tikz'
               Generate a LaTeX file using PGF/TikZ.  For the FLTK
               toolkit the result is PGF.

         `ill'
         `aifm'
               Adobe Illustrator (Obsolete for Gnuplot versions > 4.2)

         `cdr'
         `corel'
               CorelDraw

         `dxf'
               AutoCAD

         `emf'
         `meta'
               Microsoft Enhanced Metafile

         `fig'
               XFig.  For the Gnuplot graphics toolkit, the additional
               options `-textspecial' or `-textnormal' can be used to
               control whether the special flag should be set for the
               text in the figure.  (default is `-textnormal')

         `hpgl'
               HP plotter language

         `mf'
               Metafont

         `png'
               Portable network graphics

         `jpg'
         `jpeg'
               JPEG image

         `gif'
               GIF image (only available for the Gnuplot graphics
               toolkit)

         `pbm'
               PBMplus

         `svg'
               Scalable vector graphics

         `pdf'
               Portable document format

          If the device is omitted, it is inferred from the file
          extension, or if there is no filename it is sent to the
          printer as PostScript.

    `-dGHOSTSCRIPT_DEVICE'
          Additional devices are supported by Ghostscript.  Some
          examples are;

         `ljet2p'
               HP LaserJet IIP

         `ljet3'
               HP LaserJet III

         `deskjet'
               HP DeskJet and DeskJet Plus

         `cdj550'
               HP DeskJet 550C

         `paintjet'
               HP PointJet

         `pcx24b'
               24-bit color PCX file format

         `ppm'
               Portable Pixel Map file format

         `pdfwrite'
               Produces pdf output from eps

          For a complete list, type `system ("gs -h")' to see what
          formats and devices are available.

          When Ghostscript output is sent to a printer the size is
          determined by the figure's "papersize" property.  When the
          output is sent to a file the size is determined by the plot
          box defined by the figure's "paperposition" property.

    `-append'
          Append PostScript or PDF output to a pre-existing file of the
          same type.

    `-rNUM'
          Resolution of bitmaps in pixels per inch.  For both metafiles
          and SVG the default is the screen resolution; for other
          formats it is 150 dpi.  To specify screen resolution, use
          "-r0".

    `-loose'
    `-tight'
          Force a tight or loose bounding box for eps files.  The
          default is loose.

    `-PREVIEW'
          Add a preview to eps files.  Supported formats are:

         `-interchange'
               Provide an interchange preview.

         `-metalfile'
               Provide a metafile preview.

         `-pict'
               Provide pict preview.

         `-tiff'
               Provide a tiff preview.

    `-SXSIZE,YSIZE'
          Plot size in pixels for EMF, GIF, JPEG, PBM, PNG, and SVG.
          For PS, EPS, PDF, and other vector formats the plot size is
          in points.  This option is equivalent to changing the size of
          the plot box associated with the "paperposition" property.
          When using the command form of the print function you must
          quote the XSIZE,YSIZE option.  For example, by writing
          "-S640,480".

    `-FFONTNAME'
    `-FFONTNAME:SIZE'
    `-F:SIZE'
          Use FONTNAME and/or FONTSIZE for all text.  FONTNAME is
          ignored for some devices: dxf, fig, hpgl, etc.

     The filename and options can be given in any order.

     Example: Print to a file using the svg device.

          figure (1);
          clf ();
          surf (peaks);
          print -dsvg figure1.svg

     Example: Print to an HP DeskJet 550C.

          clf ();
          surf (peaks);
          print -dcdj550

     See also: *note saveas: XREFsaveas, *note orient: XREForient,
     *note figure: XREFfigure.


 -- Function File:  saveas (H, FILENAME)
 -- Function File:  saveas (H, FILENAME, FMT)
     Save graphic object H to the file FILENAME in graphic format FMT.

     FMT should be one of the following formats:

    `ps'
          PostScript

    `eps'
          Encapsulated PostScript

    `jpg'
          JPEG Image

    `png'
          PNG Image

    `emf'
          Enhanced Meta File

    `pdf'
          Portable Document Format

     All device formats specified in `print' may also be used.  If FMT
     is omitted it is extracted from the extension of FILENAME.  The
     default format is "pdf".

          clf ();
          surf (peaks);
          saveas (1, "figure1.png");

     See also: *note print: XREFprint, *note orient: XREForient.


 -- Function File:  orient (ORIENTATION)
 -- Function File:  orient (HFIG, ORIENTATION)
 -- Function File: ORIENTATION = orient ()
 -- Function File: ORIENTATION = orient (HFIG)
     Query or set the default print orientation.

     Valid values for ORIENTATION are "landscape", "portrait", and
     "tall".

     The "tall" option sets the orientation to portrait and fills the
     page with the plot, while leaving a 0.25 inch border.

     When called with no arguments, return the default print
     orientation.

     If the first argument HFIG is a figure handle, then operate on this
     figure rather than the current figure returned by `gcf'.

     See also: *note print: XREFprint, *note saveas: XREFsaveas.



File: octave.info,  Node: Interacting with Plots,  Next: Test Plotting Functions,  Prev: Printing and Saving Plots,  Up: High-Level Plotting

15.2.9 Interacting with Plots
-----------------------------

The user can select points on a plot with the `ginput' function or
selection the position at which to place text on the plot with the
`gtext' function using the mouse.  Menus may also be created and
populated with specific user commands via the `uimenu' function.

 -- Function File: [X, Y, BUTTONS] = ginput (N)
 -- Function File: [X, Y, BUTTONS] = ginput ()
     Return the position and type of mouse button clicks and/or key
     strokes in the current figure window.

     If N is defined, then capture N events before returning.  When N
     is not defined `ginput' will loop until the return key <RET> is
     pressed.

     The return values X, Y are the coordinates where the mouse was
     clicked in the units of the current axes.  The return value BUTTON
     is 1, 2, or 3 for the left, middle, or right button.  If a key is
     pressed the ASCII value is returned in BUTTON.

     See also: *note gtext: XREFgtext.


 -- Function File:  waitforbuttonpress ()
 -- Function File: B = waitforbuttonpress ()
     Wait for mouse click or key press over the current figure window.

     The return value of B is 0 if a mouse button was pressed or 1 if a
     key was pressed.

     See also: *note waitfor: XREFwaitfor, *note ginput: XREFginput.


 -- Function File:  gtext (S)
 -- Function File:  gtext ({S1, S2, ...})
 -- Function File:  gtext ({S1; S2; ...})
 -- Function File:  gtext (..., PROP, VAL, ...)
 -- Function File: H = gtext (...)
     Place text on the current figure using the mouse.

     The text is defined by the string S.  If S is a cell string
     organized as a row vector then each string of the cell array is
     written to a separate line.  If S is organized as a column vector
     then one string element of the cell array is placed for every
     mouse click.

     Optional property/value pairs are passed directly to the
     underlying text objects.

     The optional return value H is a graphics handle to the created
     text object(s).

     See also: *note ginput: XREFginput, *note text: XREFtext.


 -- Function File:  uimenu (PROPERTY, VALUE, ...)
 -- Function File:  uimenu (H, PROPERTY, VALUE, ...)
     Create a uimenu object and return a handle to it.  If H is omitted
     then a top-level menu for the current figure is created.  If H is
     given then a submenu relative to H is created.

     uimenu objects have the following specific properties:

    "accelerator"
          A string containing the key combination together with CTRL to
          execute this menu entry (e.g., "x" for CTRL+x).

    "callback"
          Is the function called when this menu entry is executed.  It
          can be either a function string (e.g., "myfun"), a function
          handle (e.g., @myfun) or a cell array containing the function
          handle and arguments for the callback function (e.g.,
          {@myfun, arg1, arg2}).

    "checked"
          Can be set "on" or "off".  Sets a mark at this menu entry.

    "enable"
          Can be set "on" or "off".  If disabled the menu entry cannot
          be selected and it is grayed out.

    "foregroundcolor"
          A color value setting the text color for this menu entry.

    "label"
          A string containing the label for this menu entry.  A
          "&"-symbol can be used to mark the "accelerator" character
          (e.g., "E&xit")

    "position"
          An scalar value containing the relative menu position.  The
          entry with the lowest value is at the first position starting
          from left or top.

    "separator"
          Can be set "on" or "off".  If enabled it draws a separator
          line above the current position.  It is ignored for top level
          entries.


     Examples:

          f = uimenu ("label", "&File", "accelerator", "f");
          e = uimenu ("label", "&Edit", "accelerator", "e");
          uimenu (f, "label", "Close", "accelerator", "q", ...
                     "callback", "close (gcf)");
          uimenu (e, "label", "Toggle &Grid", "accelerator", "g", ...
                     "callback", "grid (gca)");

     See also: *note figure: XREFfigure.



File: octave.info,  Node: Test Plotting Functions,  Prev: Interacting with Plots,  Up: High-Level Plotting

15.2.10 Test Plotting Functions
-------------------------------

The functions `sombrero' and `peaks' provide a way to check that
plotting is working.  Typing either `sombrero' or `peaks' at the Octave
prompt should display a three-dimensional plot.

 -- Function File:  sombrero ()
 -- Function File:  sombrero (N)
 -- Function File: Z = sombrero (...)
 -- Function File: [X, Y, Z] = sombrero (...)
     Plot the familiar 3-D sombrero function.

     The function plotted is

          z = sin (sqrt (x^2 + y^2)) / (sqrt (x^2 + y^2))

     Called without a return argument, `sombrero' plots the surface of
     the above function over the meshgrid [-8,8] using `surf'.

     If N is a scalar the plot is made with N grid lines.  The default
     value for N is 41.

     When called with output arguments, return the data for the function
     evaluated over the meshgrid.  This can subsequently be plotted with
     `surf (X, Y, Z)'.

     See also: *note peaks: XREFpeaks, *note meshgrid: XREFmeshgrid,
     *note mesh: XREFmesh, *note surf: XREFsurf.


 -- Function File:  peaks ()
 -- Function File:  peaks (N)
 -- Function File:  peaks (X, Y)
 -- Function File: Z = peaks (...)
 -- Function File: [X, Y, Z] = peaks (...)
     Plot a function with lots of local maxima and minima.

     The function has the form

     f(x,y) = 3*(1-x)^2*exp(-x^2 - (y+1)^2) ...
              - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
              - 1/3*exp(-(x+1)^2 - y^2)

     Called without a return argument, `peaks' plots the surface of the
     above function using `surf'.

     If N is a scalar, `peaks' plots the value of the above function on
     an N-by-N mesh over the range [-3,3].  The default value for N is
     49.

     If N is a vector, then it represents the grid values over which to
     calculate the function.  If X and Y are specified then the
     function value is calculated over the specified grid of vertices.

     When called with output arguments, return the data for the function
     evaluated over the meshgrid.  This can subsequently be plotted with
     `surf (X, Y, Z)'.

     See also: *note sombrero: XREFsombrero, *note meshgrid:
     XREFmeshgrid, *note mesh: XREFmesh, *note surf: XREFsurf.



File: octave.info,  Node: Graphics Data Structures,  Next: Advanced Plotting,  Prev: High-Level Plotting,  Up: Plotting

15.3 Graphics Data Structures
=============================

* Menu:

* Introduction to Graphics Structures::
* Graphics Objects::
* Graphics Object Properties::
* Searching Properties::
* Managing Default Properties::


File: octave.info,  Node: Introduction to Graphics Structures,  Next: Graphics Objects,  Up: Graphics Data Structures

15.3.1 Introduction to Graphics Structures
------------------------------------------

The graphics functions use pointers, which are of class
graphics_handle, in order to address the data structures which control
graphical displays.  A graphics handle may point any one of a number of
different object types.  The objects are the graphics data structures.
The types of objects are: `figure', `axes', `line', `text', `patch',
`surface', `text' and `image'.

   Each of these objects has a function by the same name. and, each of
these functions returns a graphics handle pointing to an object of
corresponding type.  In addition there are several functions which
operate on properties of the graphics objects and which return handles:
the functions ` plot' and `plot3' return a handle pointing to an object
of type line, the function `subplot' returns a handle pointing to an
object of type axes, the function `fill' returns a handle pointing to
an object of type patch, the functions `area', `bar', `barh', `contour',
`contourf', `contour3', `surf', `mesh', `surfc', `meshc', `errorbar',
`quiver', `quiver3', `scatter', `scatter3', `stair', `stem', `stem3'
each return a handle as documented in *note Data Sources:
XREFdatasources.

   The graphics objects are arranged in a hierarchy:

   1. The root is at 0.  i.e., `get (0)' returns the properties of the
root    object.

   2. Below the root are `figure' objects.

   3. Below the `figure' objects are `axes'.

   4. Below the `axes' objects are `line', `text', `patch', `surface',
and `image' objects.

   Graphics handles may be distinguished from function handles (*note
Function Handles::) by means of the function `ishandle'.  `ishandle'
returns true if its argument is a handle of a graphics object.  In
addition, the figure object may be tested using `isfigure'.  `isfigure'
returns true only if its argument is a handle of a figure.  The `whos'
function can be used to show the object type of each currently defined
graphics handle.  (Note: this is not true today, but it is, I hope,
considered an error in whos.  It may be better to have whos just show
graphics_handle as the class, and provide a new function which, given a
graphics handle, returns its object type.  This could generalize the
ishandle() functions and, in fact, replace them.)

   The `get' and `set' commands are used to obtain and set the values of
properties of graphics objects.  In addition, the `get' command may be
used to obtain property names.

   For example, the property "type" of the graphics object pointed to by
the graphics handle h may be displayed by:

     get (h, "type")

   The properties and their current values are returned by `get (h)'
where h is a handle of a graphics object.  If only the names of the
allowed properties are wanted they may be displayed by: `get (h, "")'.

   Thus, for example:

     h = figure ();
     get (h, "type")
     ans = figure
     get (h, "");
     error: get: ambiguous figure property name ; possible matches:

     __graphics_toolkit__  hittest              resize
     __enhanced__          integerhandle        resizefcn
     __modified__          interruptible        selected
     __myhandle__          inverthardcopy       selectionhighlight
     __plot_stream__       keypressfcn          selectiontype
     alphamap              keyreleasefcn        tag
     beingdeleted          menubar              toolbar
     busyaction            mincolormap          type
     buttondownfcn         name                 uicontextmenu
     children              nextplot             units
     clipping              numbertitle          userdata
     closerequestfcn       paperorientation     visible
     color                 paperposition        windowbuttondownfcn
     colormap              paperpositionmode    windowbuttonmotionfcn
     createfcn             papersize            windowbuttonupfcn
     currentaxes           papertype            windowscrollwheelfcn
     currentcharacter      paperunits           windowstyle
     currentobject         parent               wvisual
     currentpoint          pointer              wvisualmode
     deletefcn             pointershapecdata    xdisplay
     dockcontrols          pointershapehotspot  xvisual
     doublebuffer          position             xvisualmode
     filename              renderer
     handlevisibility      renderermode

   The root figure has index 0.  Its properties may be displayed by:
`get (0, "")'.

   The uses of `get' and `set' are further explained in *note get:
XREFget, *note set: XREFset.

 -- Function File: RES = isprop (H, PROP)
     Return true if PROP is a property of the object with handle H.

     See also: *note get: XREFget, *note set: XREFset.



File: octave.info,  Node: Graphics Objects,  Next: Graphics Object Properties,  Prev: Introduction to Graphics Structures,  Up: Graphics Data Structures

15.3.2 Graphics Objects
-----------------------

The hierarchy of graphics objects was explained above.  *Note
Introduction to Graphics Structures::.  Here the specific objects are
described, and the properties contained in these objects are discussed.
Keep in mind that graphics objects are always referenced by "handle".

root figure
     the top level of the hierarchy and the parent of all figure
     objects.  The handle index of the root figure is 0.

figure
     A figure window.

axes
     A set of axes.  This object is a child of a figure object and may
     be a parent of line, text, image, patch, or surface objects.

line
     A line in two or three dimensions.

text
     Text annotations.

image
     A bitmap image.

patch
     A filled polygon, currently limited to two dimensions.

surface
     A three-dimensional surface.

15.3.2.1 Creating Graphics Objects
..................................

You can create axes, line, patch, and surface objects directly using the
`axes', `line', `patch', `fill', and `surface' functions.  These
objects become children of the current axes object.

 -- Function File:  axes ()
 -- Function File:  axes (PROPERTY, VALUE, ...)
 -- Function File:  axes (HAX)
 -- Function File: H = axes (...)
     Create an axes object and return a handle to it, or set the current
     axes to HAX.

     Called without any arguments, or with PROPERTY/VALUE pairs,
     construct a new axes.  For accepted properties and corresponding
     values, *note set: XREFset.

     Called with a single axes handle argument HAX, the function makes
     HAX the current axis.  It also restacks the axes in the
     corresponding figure so that HAX is the first entry in the list of
     children.  This causes HAX to be displayed on top of any other
     axes objects (Z-order stacking).

     See also: gca, set, get.


 -- Function File:  line ()
 -- Function File:  line (X, Y)
 -- Function File:  line (X, Y, PROPERTY, VALUE, ...)
 -- Function File:  line (X, Y, Z)
 -- Function File:  line (X, Y, Z, PROPERTY, VALUE, ...)
 -- Function File:  line (PROPERTY, VALUE, ...)
 -- Function File:  line (HAX, ...)
 -- Function File: H = line (...)
     Create line object from X and Y (and possibly Z) and insert in the
     current axes.

     Multiple property-value pairs may be specified for the line
     object, but they must appear in pairs.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle (or vector of
     handles) to the line objects created.

     See also: *note image: XREFimage, *note patch: XREFpatch, *note
     rectangle: XREFrectangle, *note surface: XREFsurface, *note text:
     XREFtext.


 -- Function File:  patch ()
 -- Function File:  patch (X, Y, C)
 -- Function File:  patch (X, Y, Z, C)
 -- Function File:  patch (FV)
 -- Function File:  patch ("Faces", FACES, "Vertices", VERTS, ...)
 -- Function File:  patch (..., PROP, VAL, ...)
 -- Function File:  patch (HAX, ...)
 -- Function File: H = patch (...)
     Create patch object in the current axes with vertices at locations
     (X, Y) and of color C.

     If the vertices are matrices of size MxN then each polygon patch
     has M vertices and a total of N polygons will be created.  If some
     polygons do not have M vertices use NaN to represent "no vertex".
     If the Z input is present then 3-D patches will be created.

     The color argument C can take many forms.  To create polygons
     which all share a single color use a string value (e.g., "r" for
     red), a scalar value which is scaled by `caxis' and indexed into
     the current colormap, or a 3-element RGB vector with the precise
     TrueColor.

     If C is a vector of length N then the ith polygon will have a color
     determined by scaling entry C(i) according to `caxis' and then
     indexing into the current colormap.  More complicated coloring
     situations require directly manipulating patch property/value
     pairs.

     Instead of specifying polygons by matrices X and Y, it is possible
     to present a unique list of vertices and then a list of polygon
     faces created from those vertices.  In this case the "Vertices"
     matrix will be an Nx2 (2-D patch) or Nx3 (3-D path).  The MxN
     "Faces" matrix describes M polygons having N vertices--each row
     describes a single polygon and each column entry is an index into
     the "Vertices" matrix to identify a vertex.  The patch object can
     be created by directly passing the property/value pairs
     "Vertices"/VERTS, "Faces"/FACES as inputs.

     A third input form is to create a structure FV with the fields
     "vertices", "faces", and optionally "facevertexcdata".

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     patch object.

     Implementation Note: Patches are highly configurable objects.  To
     truly customize them requires setting patch properties directly.
     Useful patch properties are: "cdata", "edgecolor", "facecolor",
     "faces", "facevertexcdata".

     See also: *note fill: XREFfill, *note get: XREFget, *note set:
     XREFset.


 -- Function File:  fill (X, Y, C)
 -- Function File:  fill (X1, Y1, C1, X2, Y2, C2)
 -- Function File:  fill (..., PROP, VAL)
 -- Function File:  fill (HAX, ...)
 -- Function File: H = fill (...)
     Create one or more filled 2-D polygons.

     The inputs X and Y are the coordinates of the polygon vertices.
     If the inputs are matrices then the rows represent different
     vertices and each column produces a different polygon.  `fill'
     will close any open polygons before plotting.

     The input C determines the color of the polygon.  The simplest form
     is a single color specification such as a `plot' format or an
     RGB-triple.  In this case the polygon(s) will have one unique
     color.  If C is a vector or matrix then the color data is first
     scaled using `caxis' and then indexed into the current colormap.
     A row vector will color each polygon (a column from matrices X and
     Y) with a single computed color.  A matrix C of the same size as X
     and Y will compute the color of each vertex and then interpolate
     the face color between the vertices.

     Multiple property/value pairs for the underlying patch object may
     be specified, but they must appear in pairs.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a vector of graphics handles to the
     created patch objects.

     Example: red square

          vertices = [0 0
                      1 0
                      1 1
                      0 1];
          fill (vertices(:,1), vertices(:,2), "r");
          axis ([-0.5 1.5, -0.5 1.5])
          axis equal

     See also: *note patch: XREFpatch, *note caxis: XREFcaxis, *note
     colormap: XREFcolormap.


 -- Function File:  surface (X, Y, Z, C)
 -- Function File:  surface (X, Y, Z)
 -- Function File:  surface (Z, C)
 -- Function File:  surface (Z)
 -- Function File:  surface (..., PROP, VAL, ...)
 -- Function File:  surface (HAX, ...)
 -- Function File: H = surface (...)
     Create a surface graphic object given matrices X and Y from
     `meshgrid' and a matrix of values Z corresponding to the X and Y
     coordinates of the surface.

     If X and Y are vectors, then a typical vertex is (X(j), Y(i),
     Z(i,j)).  Thus, columns of Z correspond to different X values and
     rows of Z correspond to different Y values.  If only a single
     input Z is given then X is taken to be `1:rows (Z)' and Y is
     `1:columns (Z)'.

     Any property/value input pairs are assigned to the surface object.

     If the first argument HAX is an axes handle, then plot into this
     axis, rather than the current axes returned by `gca'.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: *note surf: XREFsurf, *note mesh: XREFmesh, *note patch:
     XREFpatch, *note line: XREFline.


15.3.2.2 Handle Functions
.........................

To determine whether a variable is a graphics object index, or an index
to an axes or figure, use the functions `ishandle', `isaxes', and
`isfigure'.

 -- Built-in Function:  ishandle (H)
     Return true if H is a graphics handle and false otherwise.

     H may also be a matrix of handles in which case a logical array is
     returned that is true where the elements of H are graphics handles
     and false where they are not.

     See also: *note isaxes: XREFisaxes, *note isfigure: XREFisfigure.


 -- Function File:  ishghandle (H)
     Return true if H is a graphics handle and false otherwise.

     This function is equivalent to `ishandle' and is provided for
     compatibility with MATLAB.

     See also: *note ishandle: XREFishandle.


 -- Function File:  isaxes (H)
     Return true if H is an axes graphics handle and false otherwise.

     If H is a matrix then return a logical array which is true where
     the elements of H are axes graphics handles and false where they
     are not.

     See also: *note isaxes: XREFisaxes, *note ishandle: XREFishandle.


 -- Function File:  isfigure (H)
     Return true if H is a figure graphics handle and false otherwise.

     If H is a matrix then return a logical array which is true where
     the elements of H are figure graphics handles and false where they
     are not.

     See also: *note isaxes: XREFisaxes, *note ishandle: XREFishandle.


   The function `gcf' returns an index to the current figure object, or
creates one if none exists.  Similarly, `gca' returns the current axes
object, or creates one (and its parent figure object) if none exists.

 -- Function File: H = gcf ()
     Return the current figure handle.

     If a figure does not exist, create one and return its handle.  The
     handle may then be used to examine or set properties of the
     figure.  For example,

          fplot (@sin, [-10, 10]);
          fig = gcf ();
          set (fig, "visible", "off");

     plots a sine wave, finds the handle of the current figure, and then
     makes that figure invisible.  Setting the visible property of the
     figure to "on" will cause it to be displayed again.

     See also: *note gca: XREFgca, *note gco: XREFgco, *note gcbf:
     XREFgcbf, *note gcbo: XREFgcbo, *note get: XREFget, *note set:
     XREFset.


 -- Function File: H = gca ()
     Return a handle to the current axis object.

     If no axis object exists, create one and return its handle.  The
     handle may then be used to examine or set properties of the axes.
     For example,

          ax = gca ();
          set (ax, "position", [0.5, 0.5, 0.5, 0.5]);

     creates an empty axes object, then changes its location and size
     in the figure window.

     See also: *note gcf: XREFgcf, *note gco: XREFgco, *note gcbf:
     XREFgcbf, *note gcbo: XREFgcbo, *note get: XREFget, *note set:
     XREFset.


 -- Function File: H = gco ()
 -- Function File: H = gco (FIG)
     Return a handle to the current object of the current figure, or a
     handle to the current object of the figure with handle FIG.

     The current object of a figure is the object that was last clicked
     on.  It is stored in the "CurrentObject" property of the target
     figure.

     If the last mouse click did not occur on any child object of the
     figure, then the current object is the figure itself.

     If no mouse click occurred in the target figure, this function
     returns an empty matrix.

     Programming Note: The value returned by this function is not
     necessarily the same as the one returned by `gcbo' during callback
     execution.  An executing callback can be interrupted by another
     callback and the current object may be changed.

     See also: *note gcbo: XREFgcbo, *note gca: XREFgca, *note gcf:
     XREFgcf, *note gcbf: XREFgcbf, *note get: XREFget, *note set:
     XREFset.


   The `get' and `set' functions may be used to examine and set
properties for graphics objects.  For example,

     get (0)
         => ans =
            {
              type = root
              currentfigure = [](0x0)
              children = [](0x0)
              visible = on
              ...
            }

returns a structure containing all the properties of the root figure.
As with all functions in Octave, the structure is returned by value, so
modifying it will not modify the internal root figure plot object.  To
do that, you must use the `set' function.  Also, note that in this
case, the `currentfigure' property is empty, which indicates that there
is no current figure window.

   The `get' function may also be used to find the value of a single
property.  For example,

     get (gca (), "xlim")
         => [ 0 1 ]

returns the range of the x-axis for the current axes object in the
current figure.

   To set graphics object properties, use the set function.  For
example,

     set (gca (), "xlim", [-10, 10]);

sets the range of the x-axis for the current axes object in the current
figure to `[-10, 10]'.  Additionally, calling set with a graphics
object index as the only argument returns a structure containing the
default values for all the properties for the given object type.  For
example,

     set (gca ())

returns a structure containing the default property values for axes
objects.

 -- Built-in Function: VAL = get (H)
 -- Built-in Function: VAL = get (H, P)
     Return the value of the named property P from the graphics handle
     H.  If P is omitted, return the complete property list for H.  If
     H is a vector, return a cell array including the property values
     or lists respectively.

     See also: *note set: XREFset.


 -- Built-in Function:  set (H, PROPERTY, VALUE, ...)
 -- Built-in Function:  set (H, PROPERTIES, VALUES)
 -- Built-in Function:  set (H, PV)
     Set named property values for the graphics handle (or vector of
     graphics handles) H.  There are three ways how to give the
     property names and values:

        * as a comma separated list of PROPERTY, VALUE pairs

          Here, each PROPERTY is a string containing the property name,
          each VALUE is a value of the appropriate type for the
          property.

        * as a cell array of strings PROPERTIES containing property
          names and a cell array VALUES containing property values.

          In this case, the number of columns of VALUES must match the
          number of elements in PROPERTIES.  The first column of VALUES
          contains values for the first entry in PROPERTIES, etc.  The
          number of rows of VALUES must be 1 or match the number of
          elements of H.  In the first case, each handle in H will be
          assigned the same values.  In the latter case, the first
          handle in H will be assigned the values from the first row of
          VALUES and so on.

        * as a structure array PV

          Here, the field names of PV represent the property names, and
          the field values give the property values.  In contrast to
          the previous case, all elements of PV will be set in all
          handles in H independent of the dimensions of PV.

     See also: *note get: XREFget.


 -- Function File: PARENT = ancestor (H, TYPE)
 -- Function File: PARENT = ancestor (H, TYPE, "toplevel")
     Return the first ancestor of handle object H whose type matches
     TYPE, where TYPE is a character string.  If TYPE is a cell array
     of strings, return the first parent whose type matches any of the
     given type strings.

     If the handle object H itself is of type TYPE, return H.

     If "toplevel" is given as a third argument, return the highest
     parent in the object hierarchy that matches the condition, instead
     of the first (nearest) one.

     See also: *note findobj: XREFfindobj, *note findall: XREFfindall,
     *note allchild: XREFallchild.


 -- Function File: H = allchild (HANDLES)
     Find all children, including hidden children, of a graphics object.

     This function is similar to `get (h, "children")', but also returns
     hidden objects (HandleVisibility = "off").  If HANDLES is a
     scalar, H will be a vector.  Otherwise, H will be a cell matrix of
     the same size as HANDLES and each cell will contain a vector of
     handles.

     See also: *note findall: XREFfindall, *note findobj: XREFfindobj,
     *note get: XREFget, *note set: XREFset.


 -- Function File:  findfigs ()
     Find all visible figures that are currently off the screen and
     move them onto the screen.

     See also: *note allchild: XREFallchild, *note figure: XREFfigure,
     *note get: XREFget, *note set: XREFset.


   Figures can be printed or saved in many graphics formats with
`print' and `saveas'.  Occasionally, however, it may be useful to save
the original Octave handle graphic directly so that further
modifications can be made such as modifying a title or legend.

   This can be accomplished with the following functions by

     fig_struct = hdl2struct (gcf);
     save myplot.fig -struct fig_struct;
     ...
     fig_struct = load ("myplot.fig");
     struct2hdl (fig_struct);

 -- Function File: S = hdl2struct (H)
     Return a structure, S, whose fields describe the properties of the
     object, and its children, associated with the handle, H.

     The fields of the structure S are "type", "handle", "properties",
     "children", and "special".

     See also: *note struct2hdl: XREFstruct2hdl, *note findobj:
     XREFfindobj.


 -- Function File: H = struct2hdl (S)
 -- Function File: H = struct2hdl (S, P)
 -- Function File: H = struct2hdl (S, P, HILEV)
     Construct a graphics handle object H from the structure S.

     The structure must contain the fields "handle", "type",
     "children", "properties", and "special".  If the handle of an
     existing figure or axes is specified, P, the new object will be
     created as a child of that object.  If no parent handle is provided
     then a new figure and the necessary children will be constructed
     using the default values from the root figure.

     A third boolean argument HILEV can be passed to specify whether
     the function should preserve listeners/callbacks, e.g., for
     legends or hggroups.  The default is false.

     See also: *note hdl2struct: XREFhdl2struct, *note findobj:
     XREFfindobj.


 -- Function File: HNEW = copyobj (HORIG)
 -- Function File: HNEW = copyobj (HORIG, HPARENT)
     Construct a copy of the graphic object associated with handle HORIG
     and return a handle HNEW to the new object.

     If a parent handle HPARENT (root, figure, axes, or hggroup) is
     specified, the copied object will be created as a child of HPARENT.

     See also: *note struct2hdl: XREFstruct2hdl, *note hdl2struct:
     XREFhdl2struct, *note findobj: XREFfindobj.



File: octave.info,  Node: Graphics Object Properties,  Next: Searching Properties,  Prev: Graphics Objects,  Up: Graphics Data Structures

15.3.3 Graphics Object Properties
---------------------------------

* Menu:

* Root Figure Properties::
* Figure Properties::
* Axes Properties::
* Line Properties::
* Text Properties::
* Image Properties::
* Patch Properties::
* Surface Properties::

   In this Section the object properties are discussed in detail,
starting with the root figure properties and continuing through the
graphics object hierarchy.


File: octave.info,  Node: Root Figure Properties,  Next: Figure Properties,  Up: Graphics Object Properties

15.3.3.1 Root Figure Properties
...............................

The `root figure' properties are:

`__modified__'
     -- Values: "on", "off"

`__myhandle__'

`beingdeleted'
     -- Values: "on", "off"

`busyaction'

`buttondownfcn'

`callbackobject'

`children'

`clipping'
     -- Values: "on", "off"

`createfcn'

`currentfigure'

`deletefcn'

`handlevisibility'
     -- Values: "on", "off"

`hittest'
     -- Values: "on", "off"

`interruptible'
     -- Values: "on", "off"

`parent'

`screendepth'

`screenpixelsperinch'

`screensize'

`selected'

`selectionhighlight'

`screendepth'

`screenpixelsperinch'

`showhiddenhandles'
     -- Values: "on", "off"

`tag'

`type'

`uicontextmenu'

`units'

`userdata'

`visible'


File: octave.info,  Node: Figure Properties,  Next: Axes Properties,  Prev: Root Figure Properties,  Up: Graphics Object Properties

15.3.3.2 Figure Properties
..........................

The `figure' properties are:

`__graphics_toolkit__'
     -- The graphics toolkit currently in use.

`__enhanced__'

`__modified__'

`__myhandle__'

`__plot_stream__'

`alphamap'

`beingdeleted'
     -- Values: "on", "off"

`busyaction'

`buttondownfcn'

`children'
     Handle to children.

`clipping'
     -- Values: "on", "off"

`closerequestfcn'
     -- Handle of function to call on close.

`color'

`colormap'
     An N-by-3 matrix containing the color map for the current axes.

`paperorientation'

`createfcn'

`currentaxes'
     Handle to graphics object of current axes.

`currentcharacter'

`currentobject'

`currentpoint'
     Holds the coordinates of the point over which the mouse pointer
     was when the mouse button was pressed.  If a mouse callback
     function is defined, "currentpoint" holds the coordinates of the
     point over which the mouse pointer is when the function gets
     called.

`deletefcn'

`dockcontrols'
     -- Values: "on", "off"

`doublebuffer'
     -- Values: "on", "off"

`filename'

`handlevisibility'
     -- Values: "on", "off"

`hittest'

`integerhandle'

`interruptible'
     -- Values: "on", "off"

`inverthardcopy'

`keypressfcn'
     see "keypressfcn"

`keyreleasefcn'
     With "keypressfcn", the keyboard callback functions.  These
     callback functions get called when a key is pressed/released
     respectively.  The functions are called with two input arguments.
     The first argument holds the handle of the calling figure.  The
     second argument holds the event structure which has the following
     members:

    `Character'
          The ASCII value of the key

    `Key'
          lowercase value of the key

    `Modifier'
          A cell array containing strings representing the modifiers
          pressed with the key.  Possible values are "shift", "alt", and
          "control".

`menubar'

`mincolormap'

`name'

`nextplot'
     May be one of

    "new"

    "add"

    "replace"

    "replacechildren"

`numbertitle'

`paperorientation'
     Indicates the orientation for printing.  Either "landscape" or
     "portrait".

`paperposition'

`paperpositionmode'

`papersize'

`papertype'

`paperunits'

`pointer'

`pointershapecdata'

`pointershapehotspot'

`position'

`renderer'

`renderermode'

`resize'

`resizefcn'

`selected'

`selectionhighlight'
     -- Values: "on", "off"

`selectiontype'

`tag'

`toolbar'

`type'

`units'

`userdata'

`visible'
     Either "on" or "off" to toggle display of the figure.

`windowbuttondownfcn'
     See "windowbuttonupfcn"

`windowbuttonmotionfcn'
     See "windowbuttonupfcn"

`windowbuttonupfcn'
     With "windowbuttondownfcn" and "windowbuttonmotionfcn", the mouse
     callback functions.  These callback functions get called when the
     mouse button is pressed, dragged, and released respectively.  When
     these callback functions are called, the "currentpoint" property
     holds the current coordinates of the cursor.

`windowscrollwheelfcn'

`windowstyle'

`wvisual'

`wvisualmode'

`xdisplay'

`xvisual'

`xvisualmode'


File: octave.info,  Node: Axes Properties,  Next: Line Properties,  Prev: Figure Properties,  Up: Graphics Object Properties

15.3.3.3 Axes Properties
........................

The `axes' properties are:

`__modified__'

`__myhandle__'

`activepositionproperty'

`alim'

`alimmode'

`ambientlightcolor'

`beingdeleted'

`box'
     Box surrounding axes.  -- Values: "on", "off"

`busyaction'

`buttondownfcn'

`cameraposition'

`camerapositionmode'

`cameratarget'

`cameratargetmode'

`cameraupvector'

`cameraupvectormode'

`cameraviewangle'

`cameraviewanglemode'

`children'

`clim'
     Two-element vector defining the limits for the c axis of an image.
     See `pcolor' property.  Setting this property also forces the
     corresponding mode property to be set to "manual".

`climmode'
     Either "manual" or "auto".

`clipping'

`color'

`colororder'

`createfcn'

`currentpoint'
     Holds the coordinates of the point over which the mouse pointer
     was when the mouse button was pressed.  If a mouse callback
     function is defined, "currentpoint" holds the coordinates of the
     point over which the mouse pointer is when the function gets
     called.

`dataaspectratio'
     A two-element vector specifying the relative height and width of
     the data displayed in the axes.  Setting `dataaspectratio' to `1,
     2]' causes the length of one unit as displayed on the y-axis to be
     the same as the length of 2 units on the x-axis.  Setting
     `dataaspectratio' also forces the `dataaspectratiomode' property
     to be set to "manual".

`dataaspectratiomode'
     Either "manual" or "auto".

`deletefcn'

`drawmode'

`fontangle'

`fontname'

`fontsize'

`fontunits'

`fontweight'

`gridlinestyle'

`handlevisibility'

`hittest'

`interpreter'

`interruptible'

`layer'

`linestyleorder'

`linewidth'

`minorgridlinestyle'

`nextplot'
     May be one of

    "add"

    "replace"

    "replacechildren"

`outerposition'
     A vector specifying the position of the plot, including titles,
     axes and legend.  The four elements of the vector are the
     coordinates of the lower left corner and width and height of the
     plot, in units normalized to the width and height of the plot
     window.  For example, `[0.2, 0.3, 0.4, 0.5]' sets the lower left
     corner of the axes at (0.2, 0.3) and the width and height to be
     0.4 and 0.5 respectively.  See also the `position' property.

`parent'

`plotboxaspectratio'

`plotboxaspectratiomode'

`position'
     A vector specifying the position of the plot, excluding titles,
     axes and legend.  The four elements of the vector are the
     coordinates of the lower left corner and width and height of the
     plot, in units normalized to the width and height of the plot
     window.  For example, `[0.2, 0.3, 0.4, 0.5]' sets the lower left
     corner of the axes at (0.2, 0.3) and the width and height to be
     0.4 and 0.5 respectively.  See also the `outerposition' property.

`projection'

`selected'

`selectionhighlight'

`tag'

`tickdir'

`tickdirmode'

`ticklength'

`tightinset'

`title'
     Index of text object for the axes title.

`type'

`uicontextmenu'

`units'

`userdata'

`view'
     A three element vector specifying the view point for
     three-dimensional plots.

`visible'
     Either "on" or "off" to toggle display of the axes.

`x_normrendertransform'

`x_projectiontransform'

`x_rendertransform'

`x_viewporttransform'

`x_viewtransform'

`xaxislocation'
     Either "top" or "bottom".

`xcolor'

`xdir'
     Either "forward" or "reverse".

`xgrid'
     Either "on" or "off" to toggle display of grid lines.

`xlabel'
     Indices to text objects for the axes labels.

`xlim'
     Two-element vector defining the limits for the x-axis.  Setting
     this property also forces the corresponding mode property to be
     set to "manual".

`xlimmode'
     Either "manual" or "auto".

`xminorgrid'
     Either "on" or "off" to toggle display of minor grid lines.

`xminortick'

`xscale'
     Either "linear" or "log".

`xtick'
     Set position of tick marks.  Setting this property also forces the
     corresponding mode property to be set to "manual".

`xticklabel'
     Setting this property also forces the corresponding mode property
     to be set to "manual".

`xticklabelmode'
     Either "manual" or "auto".

`xtickmode'
     Either "manual" or "auto".

`yaxislocation'
     Either "left" or "right"

`ycolor'

`ydir'
     Either "forward" or "reverse".

`ygrid'
     Either "on" or "off" to toggle display of grid lines.

`ylabel'
     Indices to text objects for the axes labels.

`ylim'
     Two-element vectors defining the limits for the x, y, and z axes
     and the Setting one of these properties also forces the
     corresponding mode property to be set to "manual".

`ylimmode'
     Either "manual" or "auto".

`yminorgrid'
     Either "on" or "off" to toggle display of minor grid lines.

`yminortick'

`yscale'
     Either "linear" or "log".

`ytick'
     Set position of tick marks.  Setting this property also forces the
     corresponding mode property to be set to "manual".

`yticklabel'
     Setting this property also forces the corresponding mode property
     to be set to "manual".

`yticklabelmode'
     Either "manual" or "auto".

`ytickmode'
     Either "manual" or "auto".

`zcolor'

`zdir'
     Either "forward" or "reverse".

`zgrid'
     Either "on" or "off" to toggle display of grid lines.

`zlabel'
     Indices to text objects for the axes labels.

`zlim'
     Two-element vector defining the limits for z-axis.  Setting this
     property also forces the corresponding mode property to be set to
     "manual".

`zlimmode'
     Either "manual" or "auto".

`zminorgrid'
     Either "on" or "off" to toggle display of minor grid lines.

`zminortick'

`zscale'
     Either "linear" or "log".

`ztick'
     Set position of tick marks.  Setting this property also forces the
     corresponding mode property to be set to "manual".

`zticklabel'
     Setting this property also forces the corresponding mode property
     to be set to "manual".

`zticklabelmode'
     Either "manual" or "auto".

`ztickmode'
     Either "manual" or "auto".



File: octave.info,  Node: Line Properties,  Next: Text Properties,  Prev: Axes Properties,  Up: Graphics Object Properties

15.3.3.4 Line Properties
........................

The `line' properties are:

`__modified__'

`__myhandle__'

`beingdeleted'

`busyaction'

`buttondownfcn'

`children'

`clipping'

`color'
     The RGB color of the line, or a color name.  *Note Colors::.

`createfcn'

`deletefcn'

`displayname'
     The text of the legend entry corresponding to this line.

`erasemode'

`handlevisibility'

`hittest'

`interpreter'

`interruptible'

`ldata'
     The lower errorbar in the y direction to be plotted.

`linestyle'
`linewidth'
     *Note Line Styles::.

`linewidth'

`marker'

`markeredgecolor'

`markerfacecolor'

`markersize'
     *Note Marker Styles::.

`parent'

`selected'

`selectionhighlight'

`tag'

`type'

`udata'
     The upper errorbar in the y direction to be plotted.

`uicontextmenu'

`userdata'

`visible'

`xdata'
     The data to be plotted.

`xdatasource'

`xldata'
     The lower errorbar to be plotted.

`xlim'

`xliminclude'

`xudata'
     The upper errorbar to be plotted.

`ydata'
     The data to be plotted.

`ydatasource'

`ylim'

`yliminclude'

`zdata'
     The data to be plotted.

`zdatasource'

`zlim'

`zliminclude'


File: octave.info,  Node: Text Properties,  Next: Image Properties,  Prev: Line Properties,  Up: Graphics Object Properties

15.3.3.5 Text Properties
........................

The `text' properties are:

`__modified__'

`__myhandle__'

`backgroundcolor'

`beingdeleted'

`busyaction'

`buttondownfcn'

`children'

`clipping'

`color'
     The color of the text.  *Note Colors::.

`createfcn'

`deletefcn'

`displayname'
     The text of the legend entry corresponding to this line.

`edgecolor'

`editing'

`erasemode'

`fontangle'
     Flag whether the font is italic or normal.  Valid values are
     "normal", "italic", and "oblique".

`fontname'
     The font used for the text.

`fontsize'
     The size of the font, in points to use.

`fontunits'

`fontweight'
     Flag whether the font is bold, etc.  Valid values are "normal",
     "bold", "demi", or "light".

`handlevisibility'

`hittest'

`horizontalalignment'
     May be "left", "center", or "right".

`interpreter'
     Determines how the text is rendered.  Valid values are "none",
     "tex", or "latex".

`interruptible'

`linestyle'

`linewidth'

`margin'

`parent'

`position'
     The coordinates of the text object.

`rotation'
     The angle of rotation for the displayed text, measured in degrees.

`selected'

`selectionhighlight'

`string'
     The character string contained by the text object.

`tag'

`type'

`uicontextmenu'

`units'
     May be "normalized" or "graph".

`userdata'

`verticalalignment'

`visible'

`xlim'

`xliminclude'

`ylim'

`yliminclude'

`zlim'

`zliminclude'


File: octave.info,  Node: Image Properties,  Next: Patch Properties,  Prev: Text Properties,  Up: Graphics Object Properties

15.3.3.6 Image Properties
.........................

The `image' properties are:

`__modified__'

`__myhandle__'

`beingdeleted'

`busyaction'

`buttondownfcn'

`cdata'
     The data for the image.  Each pixel of the image corresponds to an
     element of `cdata'.  The value of an element of `cdata' specifies
     the row-index into the colormap of the axes object containing the
     image.  The color value found in the color map for the given index
     determines the color of the pixel.

`cdatamapping'

`children'

`clim'

`climinclude'

`clipping'

`createfcn'

`deletefcn'

`handlevisibility'

`hittest'

`interruptible'

`parent'

`selected'

`selectionhighlight'

`tag'

`type'

`uicontextmenu'

`userdata'

`visible'

`xdata'
     Two-element vector specifying the range of the x-coordinates for
     the image.

`xlim'

`xliminclude'

`ydata'
     Two-element vector specifying the range of the y-coordinates for
     the image.

`ylim'

`yliminclude'


File: octave.info,  Node: Patch Properties,  Next: Surface Properties,  Prev: Image Properties,  Up: Graphics Object Properties

15.3.3.7 Patch Properties
.........................

The `patch' properties are:

`__modified__'

`__myhandle__'

`alim'

`aliminclude'

`alphadatamapping'

`ambientstrength'

`backfacelighting'

`beingdeleted'

`busyaction'

`buttondownfcn'

`cdata'
     Data defining the patch object.

`cdatamapping'

`children'

`clim'

`climinclude'

`clipping'

`createfcn'

`deletefcn'

`diffusestrength'

`displayname'
     The text of the legend entry corresponding to this line.

`edgealpha'

`edgecolor'
     The color of the line defining the patch.  *Note Colors::.

`edgelighting'

`erasemode'

`facealpha'
     A number in the range [0, 1] indicating the transparency of the
     patch.

`facecolor'
     The fill color of the patch.  *Note Colors::.

`facelighting'

`faces'

`facevertexalphadata'

`facevertexcdata'

`handlevisibility'

`hittest'

`interpreter'

`interruptible'

`linestyle'
     *Note Line Styles::.

`linewidth'
     *Note Line Styles::.

`marker'
     *Note Marker Styles::.

`markeredgecolor'
     *Note Marker Styles::.

`markerfacecolor'
     *Note Marker Styles::.

`markersize'
     *Note Marker Styles::.

`normalmode'

`parent'

`selected'

`selectionhighlight'

`specularcolorreflectance'

`specularexponent'

`specularstrength'

`tag'

`type'

`uicontextmenu'

`userdata'

`vertexnormals'

`vertices'

`visible'

`xdata'
     Data defining the patch object.

`xlim'

`xliminclude'

`ydata'
     Data defining the patch object.

`ylim'

`yliminclude'

`zdata'
     Data defining the patch object.

`zlim'

`zliminclude'


File: octave.info,  Node: Surface Properties,  Prev: Patch Properties,  Up: Graphics Object Properties

15.3.3.8 Surface Properties
...........................

The `surface' properties are:

`__modified__'

`__myhandle__'

`alim'

`aliminclude'

`alphadata'

`alphadatamapping'

`ambientstrength'

`backfacelighting'

`beingdeleted'

`busyaction'

`buttondownfcn'

`cdata'

`cdatamapping'

`cdatasource'

`children'

`clim'

`climinclude'

`clipping'

`createfcn'

`deletefcn'

`diffusestrength'

`displayname'
     The text of the legend entry corresponding to this surface.

`edgealpha'

`edgecolor'

`edgelighting'

`erasemode'

`facealpha'

`facecolor'

`facelighting'

`handlevisibility'

`hittest'

`interpreter'

`interruptible'

`linestyle'

`linewidth'

`marker'

`markeredgecolor'

`markerfacecolor'

`markersize'

`meshstyle'

`normalmode'

`parent'

`selected'

`selectionhighlight'

`specularcolorreflectance'

`specularexponent'

`specularstrength'

`tag'

`type'

`uicontextmenu'

`userdata'

`vertexnormals'

`visible'

`xdata'
     The data determining the surface.  The `xdata' and `ydata'
     elements are vectors and `zdata' must be a matrix.

`xdatasource'

`xlim'

`xliminclude'

`ydata'
     The data determining the surface.  The `xdata' and `ydata'
     elements are vectors and `zdata' must be a matrix.

`ydatasource'

`ylim'

`yliminclude'

`zdata'
     The data determining the surface.  The `xdata' and `ydata'
     elements are vectors and `zdata' must be a matrix.

`zdatasource'

`zlim'

`zliminclude'


File: octave.info,  Node: Searching Properties,  Next: Managing Default Properties,  Prev: Graphics Object Properties,  Up: Graphics Data Structures

15.3.4 Searching Properties
---------------------------

 -- Function File: H = findobj ()
 -- Function File: H = findobj (PROP_NAME, PROP_VALUE, ...)
 -- Function File: H = findobj (PROP_NAME, PROP_VALUE, "-LOGICAL_OP",
          PROP_NAME, PROP_VALUE)
 -- Function File: H = findobj ("-property", PROP_NAME)
 -- Function File: H = findobj ("-regexp", PROP_NAME, PATTERN)
 -- Function File: H = findobj (HLIST, ...)
 -- Function File: H = findobj (HLIST, "flat", ...)
 -- Function File: H = findobj (HLIST, "-depth", D, ...)
     Find graphics object with specified property values.

     The simplest form is

          findobj (PROP_NAME, PROP_VALUE)

     which returns the handles of all objects which have a property
     named PROP_NAME that has the value PROP_VALUE.  If multiple
     property/value pairs are specified then only objects meeting all
     of the conditions are returned.

     The search can be limited to a particular set of objects and their
     descendants, by passing a handle or set of handles HLIST as the
     first argument.

     The depth of the object hierarchy to search can be limited with the
     "-depth" argument.  An example of searching only three generations
     of children is:

          findobj (HLIST, "-depth", D, PROP_NAME, PROP_VALUE)

     Specifying a depth D of 0, limits the search to the set of objects
     passed in HLIST.  A depth D of 0 is equivalent to the "flat"
     argument.

     A specified logical operator may be applied to the pairs of
     PROP_NAME and PROP_VALUE.  The supported logical operators are:
     "-and", "-or", "-xor", "-not".

     Objects may also be matched by comparing a regular expression to
     the property values, where property values that match `regexp
     (PROP_VALUE, PATTERN)' are returned.

     Finally, objects may be matched by property name only by using the
     "-property" option.

     Implementation Note: The search only includes objects with visible
     handles (HandleVisibility = "on").  *Note findall: XREFfindall, to
     search for all objects including hidden ones.

     See also: *note findall: XREFfindall, *note allchild:
     XREFallchild, *note get: XREFget, *note set: XREFset.


 -- Function File: H = findall ()
 -- Function File: H = findall (PROP_NAME, PROP_VALUE, ...)
 -- Function File: H = findall (PROP_NAME, PROP_VALUE, "-LOGICAL_OP",
          PROP_NAME, PROP_VALUE)
 -- Function File: H = findall ("-property", PROP_NAME)
 -- Function File: H = findall ("-regexp", PROP_NAME, PATTERN)
 -- Function File: H = findall (HLIST, ...)
 -- Function File: H = findall (HLIST, "flat", ...)
 -- Function File: H = findall (HLIST, "-depth", D, ...)
     Find graphics object, including hidden ones, with specified
     property values.

     The return value H is a list of handles to the found graphic
     objects.

     `findall' performs the same search as `findobj', but it includes
     hidden objects (HandleVisibility = "off").  For full
     documentation, *note findobj: XREFfindobj.

     See also: *note findobj: XREFfindobj, *note allchild:
     XREFallchild, *note get: XREFget, *note set: XREFset.



File: octave.info,  Node: Managing Default Properties,  Prev: Searching Properties,  Up: Graphics Data Structures

15.3.5 Managing Default Properties
----------------------------------

Object properties have two classes of default values, "factory
defaults" (the initial values) and "user-defined defaults", which may
override the factory defaults.

   Although default values may be set for any object, they are set in
parent objects and apply to child objects, of the specified object type.
For example, setting the default `color' property of `line' objects to
"green", for the `root' object, will result in all `line' objects
inheriting the `color' "green" as the default value.

     set (0, "defaultlinecolor", "green");

sets the default line color for all objects.  The rule for constructing
the property name to set a default value is

     default + OBJECT-TYPE + PROPERTY-NAME

   This rule can lead to some strange looking names, for example
`defaultlinelinewidth"' specifies the default `linewidth' property for
`line' objects.

   The example above used the root figure object, 0, so the default
property value will apply to all line objects.  However, default values
are hierarchical, so defaults set in a figure objects override those
set in the root figure object.  Likewise, defaults set in axes objects
override those set in figure or root figure objects.  For example,

     subplot (2, 1, 1);
     set (0, "defaultlinecolor", "red");
     set (1, "defaultlinecolor", "green");
     set (gca (), "defaultlinecolor", "blue");
     line (1:10, rand (1, 10));
     subplot (2, 1, 2);
     line (1:10, rand (1, 10));
     figure (2)
     line (1:10, rand (1, 10));

produces two figures.  The line in first subplot window of the first
figure is blue because it inherits its color from its parent axes
object.  The line in the second subplot window of the first figure is
green because it inherits its color from its parent figure object.  The
line in the second figure window is red because it inherits its color
from the global root figure parent object.

   To remove a user-defined default setting, set the default property to
the value "remove".  For example,

     set (gca (), "defaultlinecolor", "remove");

removes the user-defined default line color setting from the current
axes object.  To quickly remove all user-defined defaults use the
`reset' function.

 -- Built-in Function:  reset (H, PROPERTY)
     Remove any defaults set for the handle H.  The default figure
     properties of "position", "units", "windowstyle" and "paperunits"
     and the default axes properties of "position" and "units" are not
     reset.

   Getting the "default" property of an object returns a list of
user-defined defaults set for the object.  For example,

     get (gca (), "default");

returns a list of user-defined default values for the current axes
object.

   Factory default values are stored in the root figure object.  The
command

     get (0, "factory");

returns a list of factory defaults.


File: octave.info,  Node: Advanced Plotting,  Prev: Graphics Data Structures,  Up: Plotting

15.4 Advanced Plotting
======================

* Menu:

* Colors::
* Line Styles::
* Marker Styles::
* Callbacks::
* Application-defined Data::
* Object Groups::
* Graphics Toolkits::


File: octave.info,  Node: Colors,  Next: Line Styles,  Up: Advanced Plotting

15.4.1 Colors
-------------

Colors may be specified as RGB triplets with values ranging from zero to
one, or by name.  Recognized color names include "blue", "black",
"cyan", "green", "magenta", "red", "white", and "yellow".


File: octave.info,  Node: Line Styles,  Next: Marker Styles,  Prev: Colors,  Up: Advanced Plotting

15.4.2 Line Styles
------------------

Line styles are specified by the following properties:

`linestyle'
     May be one of

    `"-"'
          Solid line.  [default]

    `"--"'
          Dashed line.

    `":"'
          Dotted line.

    `"-."'
          A dash-dot line.

    `"none"'
          No line.  Points will still be marked using the current
          Marker Style.

`linewidth'
     A number specifying the width of the line.  The default is 1.  A
     value of 2 is twice as wide as the default, etc.


File: octave.info,  Node: Marker Styles,  Next: Callbacks,  Prev: Line Styles,  Up: Advanced Plotting

15.4.3 Marker Styles
--------------------

Marker styles are specified by the following properties:

`marker'
     A character indicating a plot marker to be place at each data
     point, or "none", meaning no markers should be displayed.

`markeredgecolor'
     The color of the edge around the marker, or "auto", meaning that
     the edge color is the same as the face color.  *Note Colors::.

`markerfacecolor'
     The color of the marker, or "none" to indicate that the marker
     should not be filled.  *Note Colors::.

`markersize'
     A number specifying the size of the marker.  The default is 1.  A
     value of 2 is twice as large as the default, etc.

   The `colstyle' function will parse a `plot'-style specification and
will return the color, line, and marker values that would result.

 -- Function File: [STYLE, COLOR, MARKER, MSG] = colstyle (LINESPEC)
     Parse LINESPEC and return the line style, color, and markers given.
     In the case of an error, the string MSG will return the text of the
     error.


File: octave.info,  Node: Callbacks,  Next: Application-defined Data,  Prev: Marker Styles,  Up: Advanced Plotting

15.4.4 Callbacks
----------------

Callback functions can be associated with graphics objects and triggered
after certain events occur.  The basic structure of all callback
function is

     function mycallback (src, data)
     ...
     endfunction

where `src' gives a handle to the source of the callback, and `code'
gives some event specific data.  This can then be associated with an
object either at the objects creation or later with the `set' function.
For example,

     plot (x, "DeleteFcn", @(s, e) disp ("Window Deleted"))

where at the moment that the plot is deleted, the message "Window
Deleted" will be displayed.

   Additional user arguments can be passed to callback functions, and
will be passed after the 2 default arguments.  For example:

     plot (x, "DeleteFcn", {@mycallback, "1"})
     ...
     function mycallback (src, data, a1)
       fprintf ("Closing plot %d\n", a1);
     endfunction

   The basic callback functions that are available for all graphics
objects are

   * CreateFcn This is the callback that is called at the moment of the
     objects creation.  It is not called if the object is altered in
     any way, and so it only makes sense to define this callback in the
     function call that defines the object.  Callbacks that are added
     to `CreateFcn' later with the `set' function will never be
     executed.

   * DeleteFcn This is the callback that is called at the moment an
     object is deleted.

   * ButtonDownFcn This is the callback that is called if a mouse
     button is pressed while the pointer is over this object.  Note,
     that the gnuplot interface does not respect this callback.

   The object and figure that the event occurred in that resulted in the
callback being called can be found with the `gcbo' and `gcbf' functions.

 -- Function File: H = gcbo ()
 -- Function File: [H, FIG] = gcbo ()
     Return a handle to the object whose callback is currently
     executing.

     If no callback is executing, this function returns the empty
     matrix.  This handle is obtained from the root object property
     "CallbackObject".

     When called with a second output argument, return the handle of
     the figure containing the object whose callback is currently
     executing.  If no callback is executing the second output is also
     set to the empty matrix.

     See also: *note gcbf: XREFgcbf, *note gco: XREFgco, *note gca:
     XREFgca, *note gcf: XREFgcf, *note get: XREFget, *note set:
     XREFset.


 -- Function File: FIG = gcbf ()
     Return a handle to the figure containing the object whose callback
     is currently executing.

     If no callback is executing, this function returns the empty
     matrix.  The handle returned by this function is the same as the
     second output argument of `gcbo'.

     See also: *note gcbo: XREFgcbo, *note gcf: XREFgcf, *note gco:
     XREFgco, *note gca: XREFgca, *note get: XREFget, *note set:
     XREFset.


   Callbacks can equally be added to properties with the `addlistener'
function described below.


File: octave.info,  Node: Application-defined Data,  Next: Object Groups,  Prev: Callbacks,  Up: Advanced Plotting

15.4.5 Application-defined Data
-------------------------------

Octave has a provision for attaching application-defined data to a
graphics handle.  The data can be anything which is meaningful to the
application, and will be completely ignored by Octave.

 -- Function File:  setappdata (H, NAME, VALUE)
     Set the named application data to VALUE for the object(s) with
     handle(s) H.  If the application data with the specified name does
     not exist, it is created.

     See also: *note getappdata: XREFgetappdata, *note guidata:
     XREFguidata, *note get: XREFget, *note set: XREFset, *note
     getpref: XREFgetpref, *note setpref: XREFsetpref.


 -- Function File: VALUE = getappdata (H, NAME)
 -- Function File: APPDATA = getappdata (H)
     Return the VALUE for named application data for the object(s) with
     handle(s) H.

     `getappdata(H)' returns a structure, APPDATA, whose fields
     correspond to the appdata properties.

     See also: *note setappdata: XREFsetappdata, *note guidata:
     XREFguidata, *note get: XREFget, *note set: XREFset, *note
     getpref: XREFgetpref, *note setpref: XREFsetpref.


 -- Function File:  rmappdata (H, NAME)
     Delete the named application data for the object(s) with handle(s)
     H.

 -- Function File: V = isappdata (H, NAME)
     Return true if the named application data, NAME, exists for the
     object with handle H.

     See also: *note getappdata: XREFgetappdata, *note setappdata:
     XREFsetappdata, *note rmappdata: XREFrmappdata.



File: octave.info,  Node: Object Groups,  Next: Graphics Toolkits,  Prev: Application-defined Data,  Up: Advanced Plotting

15.4.6 Object Groups
--------------------

A number of Octave high level plot functions return groups of other
graphics objects or they return graphics objects that have their
properties linked in such a way that changes to one of the properties
results in changes in the others.  A graphic object that groups other
objects is an `hggroup'

 -- Function File:  hggroup ()
 -- Function File:  hggroup (HAX)
 -- Function File:  hggroup (..., PROPERTY, VALUE, ...)
 -- Function File: H = hggroup (...)
     Create handle graphics group object with axes parent HAX.

     If no parent is specified, the group is created in the current
     axes.

     Multiple property/value pairs may be specified for the hggroup,
     but they must appear in pairs.

     The optional return value H is a graphics handle to the created
     hggroup object.

     Programming Note: An hggroup is a way to group base graphics
     objects such as line objects or patch objects into a single unit
     which can react appropriately.  For example, the individual lines
     of a contour plot are collected into a single hggroup so that they
     can be made visible/invisible with a single command, `set
     (hg_handle, "visible", "off")'.


   For example a simple use of a `hggroup' might be

     x = 0:0.1:10;
     hg = hggroup ();
     plot (x, sin (x), "color", [1, 0, 0], "parent", hg);
     hold on
     plot (x, cos (x), "color", [0, 1, 0], "parent", hg);
     set (hg, "visible", "off");

which groups the two plots into a single object and controls their
visibility directly.  The default properties of an `hggroup' are the
same as the set of common properties for the other graphics objects.
Additional properties can be added with the `addproperty' function.

 -- Built-in Function:  addproperty (NAME, H, TYPE)
 -- Built-in Function:  addproperty (NAME, H, TYPE, ARG, ...)
     Create a new property named NAME in graphics object H.  TYPE
     determines the type of the property to create.  ARGS usually
     contains the default value of the property, but additional
     arguments might be given, depending on the type of the property.

     The supported property types are:

    `string'
          A string property.  ARG contains the default string value.

    `any'
          An un-typed property.  This kind of property can hold any
          octave value.  ARGS contains the default value.

    `radio'
          A string property with a limited set of accepted values.  The
          first argument must be a string with all accepted values
          separated by a vertical bar ('|').  The default value can be
          marked by enclosing it with a '{' '}' pair.  The default
          value may also be given as an optional second string argument.

    `boolean'
          A boolean property.  This property type is equivalent to a
          radio property with "on|off" as accepted values.  ARG contains
          the default property value.

    `double'
          A scalar double property.  ARG contains the default value.

    `handle'
          A handle property.  This kind of property holds the handle of
          a graphics object.  ARG contains the default handle value.
          When no default value is given, the property is initialized to
          the empty matrix.

    `data'
          A data (matrix) property.  ARG contains the default data
          value.  When no default value is given, the data is
          initialized to the empty matrix.

    `color'
          A color property.  ARG contains the default color value.
          When no default color is given, the property is set to black.
          An optional second string argument may be given to specify an
          additional set of accepted string values (like a radio
          property).

     TYPE may also be the concatenation of a core object type and a
     valid property name for that object type.  The property created
     then has the same characteristics as the referenced property (type,
     possible values, hidden state...).  This allows to clone an
     existing property into the graphics object H.

     Examples:

          addproperty ("my_property", gcf, "string", "a string value");
          addproperty ("my_radio", gcf, "radio", "val_1|val_2|{val_3}");
          addproperty ("my_style", gcf, "linelinestyle", "--");


   Once a property in added to an `hggroup', it is not linked to any
other property of either the children of the group, or any other
graphics object.  Add so to control the way in which this newly added
property is used, the `addlistener' function is used to define a
callback function that is executed when the property is altered.

 -- Built-in Function:  addlistener (H, PROP, FCN)
     Register FCN as listener for the property PROP of the graphics
     object H.  Property listeners are executed (in order of
     registration) when the property is set.  The new value is already
     available when the listeners are executed.

     PROP must be a string naming a valid property in H.

     FCN can be a function handle, a string or a cell array whose first
     element is a function handle.  If FCN is a function handle, the
     corresponding function should accept at least 2 arguments, that
     will be set to the object handle and the empty matrix
     respectively.  If FCN is a string, it must be any valid octave
     expression.  If FCN is a cell array, the first element must be a
     function handle with the same signature as described above.  The
     next elements of the cell array are passed as additional arguments
     to the function.

     Example:

          function my_listener (h, dummy, p1)
            fprintf ("my_listener called with p1=%s\n", p1);
          endfunction

          addlistener (gcf, "position", {@my_listener, "my string"})


 -- Built-in Function:  dellistener (H, PROP, FCN)
     Remove the registration of FCN as a listener for the property PROP
     of the graphics object H.  The function FCN must be the same
     variable (not just the same value), as was passed to the original
     call to `addlistener'.

     If FCN is not defined then all listener functions of PROP are
     removed.

     Example:

          function my_listener (h, dummy, p1)
            fprintf ("my_listener called with p1=%s\n", p1);
          endfunction

          c = {@my_listener, "my string"};
          addlistener (gcf, "position", c);
          dellistener (gcf, "position", c);


   An example of the use of these two functions might be

     x = 0:0.1:10;
     hg = hggroup ();
     h = plot (x, sin (x), "color", [1, 0, 0], "parent", hg);
     addproperty ("linestyle", hg, "linelinestyle", get (h, "linestyle"));
     addlistener (hg, "linestyle", @update_props);
     hold on
     plot (x, cos (x), "color", [0, 1, 0], "parent", hg);

     function update_props (h, d)
       set (get (h, "children"), "linestyle", get (h, "linestyle"));
     endfunction

that adds a `linestyle' property to the `hggroup' and propagating any
changes its value to the children of the group.  The `linkprop'
function can be used to simplify the above to be

     x = 0:0.1:10;
     hg = hggroup ();
     h1 = plot (x, sin (x), "color", [1, 0, 0], "parent", hg);
     addproperty ("linestyle", hg, "linelinestyle", get (h, "linestyle"));
     hold on
     h2 = plot (x, cos (x), "color", [0, 1, 0], "parent", hg);
     hlink = linkprop ([hg, h1, h2], "color");

 -- Function File: HLINK = linkprop (H, PROP)
 -- Function File: HLINK = linkprop (H, {PROP1, PROP2, ...})
     Link graphics object properties, such that a change in one is
     propagated to the others.

     PROP can be a string for a single property, or a cell array of
     strings for multiple properties.  H is an array of graphics
     handles which will have their properties linked.

     An example of the use of `linkprop' is

          x = 0:0.1:10;
          subplot (1,2,1);
          h1 = plot (x, sin (x));
          subplot (1,2,2);
          h2 = plot (x, cos (x));
          hlink = linkprop ([h1, h2], {"color","linestyle"});
          set (h1, "color", "green");
          set (h2, "linestyle", "--");


   These capabilities are used in a number of basic graphics objects.
The `hggroup' objects created by the functions of Octave contain one or
more graphics object and are used to:

   * group together multiple graphics objects,

   * create linked properties between different graphics objects, and

   * to hide the nominal user data, from the actual data of the objects.

For example the `stem' function creates a stem series where each
`hggroup' of the stem series contains two line objects representing the
body and head of the stem.  The `ydata' property of the `hggroup' of
the stem series represents the head of the stem, whereas the body of
the stem is between the baseline and this value.  For example

     h = stem (1:4)
     get (h, "xdata")
     => [  1   2   3   4]'
     get (get (h, "children")(1), "xdata")
     => [  1   1 NaN   2   2 NaN   3   3 NaN   4   4 NaN]'

shows the difference between the `xdata' of the `hggroup' of a stem
series object and the underlying line.

   The basic properties of such group objects is that they consist of
one or more linked `hggroup', and that changes in certain properties of
these groups are propagated to other members of the group.  Whereas,
certain properties of the members of the group only apply to the current
member.

   In addition the members of the group can also be linked to other
graphics objects through callback functions.  For example the baseline
of the `bar' or `stem' functions is a line object, whose length and
position are automatically adjusted, based on changes to the
corresponding hggroup elements.

* Menu:

* Data Sources in Object Groups::
* Area Series::
* Bar Series::
* Contour Groups::
* Error Bar Series::
* Line Series::
* Quiver Group::
* Scatter Group::
* Stair Group::
* Stem Series::
* Surface Group::


File: octave.info,  Node: Data Sources in Object Groups,  Next: Area Series,  Up: Object Groups

15.4.6.1 Data Sources in Object Groups
......................................

All of the group objects contain data source parameters.  There are
string parameters that contain an expression that is evaluated to update
the relevant data property of the group when the `refreshdata' function
is called.

 -- Function File:  refreshdata ()
 -- Function File:  refreshdata (H)
 -- Function File:  refreshdata (H, WORKSPACE)
     Evaluate any `datasource' properties of the current figure and
     update the plot if the corresponding data has changed.

     If the first argument H is a list of graphic handles, then operate
     on these objects rather than the current figure returned by `gcf'.

     The optional second argument WORKSPACE can take the following
     values:

    "base"
          Evaluate the datasource properties in the base workspace.
          (default).

    "caller"
          Evaluate the datasource properties in the workspace of the
          function that called `refreshdata'.

     An example of the use of `refreshdata' is:

          x = 0:0.1:10;
          y = sin (x);
          plot (x, y, "ydatasource", "y");
          for i = 1 : 100
            pause (0.1);
            y = sin (x + 0.1*i);
            refreshdata ();
          endfor


File: octave.info,  Node: Area Series,  Next: Bar Series,  Prev: Data Sources in Object Groups,  Up: Object Groups

15.4.6.2 Area Series
....................

Area series objects are created by the `area' function.  Each of the
`hggroup' elements contains a single patch object.  The properties of
the area series are

`basevalue'
     The value where the base of the area plot is drawn.

`linewidth'
`linestyle'
     The line width and style of the edge of the patch objects making
     up the areas.  *Note Line Styles::.

`edgecolor'
`facecolor'
     The line and fill color of the patch objects making up the areas.
     *Note Colors::.

`xdata'
`ydata'
     The x and y coordinates of the original columns of the data passed
     to `area' prior to the cumulative summation used in the `area'
     function.

`xdatasource'
`ydatasource'
     Data source variables.


File: octave.info,  Node: Bar Series,  Next: Contour Groups,  Prev: Area Series,  Up: Object Groups

15.4.6.3 Bar Series
...................

Bar series objects are created by the `bar' or `barh' functions.  Each
`hggroup' element contains a single patch object.  The properties of
the bar series are

`showbaseline'
`baseline'
`basevalue'
     The property `showbaseline' flags whether the baseline of the bar
     series is displayed (default is "on").  The handle of the graphics
     object representing the baseline is given by the `baseline'
     property and the y-value of the baseline by the `basevalue'
     property.

     Changes to any of these property are propagated to the other
     members of the bar series and to the baseline itself.  Equally
     changes in the properties of the base line itself are propagated
     to the members of the corresponding bar series.

`barwidth'
`barlayout'
`horizontal'
     The property `barwidth' is the width of the bar corresponding to
     the WIDTH variable passed to `bar' or BARH.  Whether the bar
     series is "grouped" or "stacked" is determined by the `barlayout'
     property and whether the bars are horizontal or vertical by the
     `horizontal' property.

     Changes to any of these property are propagated to the other
     members of the bar series.

`linewidth'
`linestyle'
     The line width and style of the edge of the patch objects making
     up the bars.  *Note Line Styles::.

`edgecolor'
`facecolor'
     The line and fill color of the patch objects making up the bars.
     *Note Colors::.

`xdata'
     The nominal x positions of the bars.  Changes in this property and
     propagated to the other members of the bar series.

`ydata'
     The y value of the bars in the `hggroup'.

`xdatasource'
`ydatasource'
     Data source variables.


File: octave.info,  Node: Contour Groups,  Next: Error Bar Series,  Prev: Bar Series,  Up: Object Groups

15.4.6.4 Contour Groups
.......................

Contour group objects are created by the `contour', `contourf' and
`contour3' functions.  The are equally one of the handles returned by
the `surfc' and `meshc' functions.  The properties of the contour group
are

`contourmatrix'
     A read only property that contains the data return by `contourc'
     used to create the contours of the plot.

`fill'
     A radio property that can have the values "on" or "off" that flags
     whether the contours to plot are to be filled.

`zlevelmode'
`zlevel'
     The radio property `zlevelmode' can have the values "none",
     "auto", or "manual".  When its value is "none" there is no z
     component to the plotted contours.  When its value is "auto" the z
     value of the plotted contours is at the same value as the contour
     itself.  If the value is "manual", then the z value at which to
     plot the contour is determined by the `zlevel' property.

`levellistmode'
`levellist'
`levelstepmode'
`levelstep'
     If `levellistmode' is "manual", then the levels at which to plot
     the contours is determined by `levellist'.  If `levellistmode' is
     set to "auto", then the distance between contours is determined by
     `levelstep'.  If both `levellistmode' and `levelstepmode' are set
     to "auto", then there are assumed to be 10 equal spaced contours.

`textlistmode'
`textlist'
`textstepmode'
`textstep'
     If `textlistmode' is "manual", then the labeled contours is
     determined by `textlist'.  If `textlistmode' is set to "auto",
     then the distance between labeled contours is determined by
     `textstep'.  If both `textlistmode' and `textstepmode' are set to
     "auto", then there are assumed to be 10 equal spaced labeled
     contours.

`showtext'
     Flag whether the contour labels are shown or not.

`labelspacing'
     The distance between labels on a single contour in points.

`linewidth'

`linestyle'

`linecolor'
     The properties of the contour lines.  The properties `linewidth'
     and `linestyle' are similar to the corresponding properties for
     lines.  The property `linecolor' is a color property (*note
     Colors::), that can also have the values of "none" or "auto".  If
     `linecolor' is "none", then no contour line is drawn.  If
     `linecolor' is "auto" then the line color is determined by the
     colormap.

`xdata'
`ydata'
`zdata'
     The original x, y, and z data of the contour lines.

`xdatasource'
`ydatasource'
`zdatasource'
     Data source variables.


File: octave.info,  Node: Error Bar Series,  Next: Line Series,  Prev: Contour Groups,  Up: Object Groups

15.4.6.5 Error Bar Series
.........................

Error bar series are created by the `errorbar' function.  Each
`hggroup' element contains two line objects representing the data and
the errorbars separately.  The properties of the error bar series are

`color'
     The RGB color or color name of the line objects of the error bars.
     *Note Colors::.

`linewidth'
`linestyle'
     The line width and style of the line objects of the error bars.
     *Note Line Styles::.

`marker'
`markeredgecolor'
`markerfacecolor'
`markersize'
     The line and fill color of the markers on the error bars.  *Note
     Colors::.

`xdata'
`ydata'
`ldata'
`udata'
`xldata'
`xudata'
     The original x, y, l, u, xl, xu data of the error bars.

`xdatasource'
`ydatasource'
`ldatasource'
`udatasource'
`xldatasource'
`xudatasource'
     Data source variables.


File: octave.info,  Node: Line Series,  Next: Quiver Group,  Prev: Error Bar Series,  Up: Object Groups

15.4.6.6 Line Series
....................

Line series objects are created by the `plot'  and `plot3' functions
and are of the type `line'.  The properties of the line series with the
ability to add data sources.

`color'
     The RGB color or color name of the line objects.  *Note Colors::.

`linewidth'
`linestyle'
     The line width and style of the line objects.  *Note Line Styles::.

`marker'
`markeredgecolor'
`markerfacecolor'
`markersize'
     The line and fill color of the markers.  *Note Colors::.

`xdata'
`ydata'
`zdata'
     The original x, y and z data.

`xdatasource'
`ydatasource'
`zdatasource'
     Data source variables.


File: octave.info,  Node: Quiver Group,  Next: Scatter Group,  Prev: Line Series,  Up: Object Groups

15.4.6.7 Quiver Group
.....................

Quiver series objects are created by the `quiver' or `quiver3'
functions.  Each `hggroup' element of the series contains three line
objects as children representing the body and head of the arrow,
together with a marker as the point of origin of the arrows.  The
properties of the quiver series are

`autoscale'
`autoscalefactor'
     Flag whether the length of the arrows is scaled or defined
     directly from the U, V and W data.  If the arrow length is flagged
     as being scaled by the `autoscale' property, then the length of the
     autoscaled arrow is controlled by the `autoscalefactor'.

`maxheadsize'
     This property controls the size of the head of the arrows in the
     quiver series.  The default value is 0.2.

`showarrowhead'
     Flag whether the arrow heads are displayed in the quiver plot.

`color'
     The RGB color or color name of the line objects of the quiver.
     *Note Colors::.

`linewidth'
`linestyle'
     The line width and style of the line objects of the quiver.  *Note
     Line Styles::.

`marker'
`markerfacecolor'
`markersize'
     The line and fill color of the marker objects at the original of
     the arrows.  *Note Colors::.

`xdata'
`ydata'
`zdata'
     The origins of the values of the vector field.

`udata'
`vdata'
`wdata'
     The values of the vector field to plot.

`xdatasource'
`ydatasource'
`zdatasource'
`udatasource'
`vdatasource'
`wdatasource'
     Data source variables.


File: octave.info,  Node: Scatter Group,  Next: Stair Group,  Prev: Quiver Group,  Up: Object Groups

15.4.6.8 Scatter Group
......................

Scatter series objects are created by the `scatter' or `scatter3'
functions.  A single hggroup element contains as many children as there
are points in the scatter plot, with each child representing one of the
points.  The properties of the stem series are

`linewidth'
     The line width of the line objects of the points.  *Note Line
     Styles::.

`marker'
`markeredgecolor'
`markerfacecolor'
     The line and fill color of the markers of the points.  *Note
     Colors::.

`xdata'
`ydata'
`zdata'
     The original x, y and z data of the stems.

`cdata'
     The color data for the points of the plot.  Each point can have a
     separate color, or a unique color can be specified.

`sizedata'
     The size data for the points of the plot.  Each point can its own
     size or a unique size can be specified.

`xdatasource'
`ydatasource'
`zdatasource'
`cdatasource'
`sizedatasource'
     Data source variables.


File: octave.info,  Node: Stair Group,  Next: Stem Series,  Prev: Scatter Group,  Up: Object Groups

15.4.6.9 Stair Group
....................

Stair series objects are created by the `stair' function.  Each
`hggroup' element of the series contains a single line object as a
child representing the stair.  The properties of the stair series are

`color'
     The RGB color or color name of the line objects of the stairs.
     *Note Colors::.

`linewidth'
`linestyle'
     The line width and style of the line objects of the stairs.  *Note
     Line Styles::.

`marker'
`markeredgecolor'
`markerfacecolor'
`markersize'
     The line and fill color of the markers on the stairs.  *Note
     Colors::.

`xdata'
`ydata'
     The original x and y data of the stairs.

`xdatasource'
`ydatasource'
     Data source variables.


File: octave.info,  Node: Stem Series,  Next: Surface Group,  Prev: Stair Group,  Up: Object Groups

15.4.6.10 Stem Series
.....................

Stem series objects are created by the `stem' or `stem3' functions.
Each `hggroup' element contains a single line object as a child
representing the stems.  The properties of the stem series are

`showbaseline'
`baseline'
`basevalue'
     The property `showbaseline' flags whether the baseline of the stem
     series is displayed (default is "on").  The handle of the graphics
     object representing the baseline is given by the `baseline'
     property and the y-value (or z-value for `stem3') of the baseline
     by the `basevalue' property.

     Changes to any of these property are propagated to the other
     members of the stem series and to the baseline itself.  Equally
     changes in the properties of the base line itself are propagated
     to the members of the corresponding stem series.

`color'
     The RGB color or color name of the line objects of the stems.
     *Note Colors::.

`linewidth'
`linestyle'
     The line width and style of the line objects of the stems.  *Note
     Line Styles::.

`marker'
`markeredgecolor'
`markerfacecolor'
`markersize'
     The line and fill color of the markers on the stems.  *Note
     Colors::.

`xdata'
`ydata'
`zdata'
     The original x, y and z data of the stems.

`xdatasource'
`ydatasource'
`zdatasource'
     Data source variables.


File: octave.info,  Node: Surface Group,  Prev: Stem Series,  Up: Object Groups

15.4.6.11 Surface Group
.......................

Surface group objects are created by the `surf' or `mesh' functions,
but are equally one of the handles returned by the `surfc' or `meshc'
functions.  The surface group is of the type `surface'.

   The properties of the surface group are

`edgecolor'

`facecolor'
     The RGB color or color name of the edges or faces of the surface.
     *Note Colors::.

`linewidth'
`linestyle'
     The line width and style of the lines on the surface.  *Note Line
     Styles::.

`marker'
`markeredgecolor'
`markerfacecolor'
`markersize'
     The line and fill color of the markers on the surface.  *Note
     Colors::.

`xdata'
`ydata'
`zdata'
`cdata'
     The original x, y, z and c data.

`xdatasource'
`ydatasource'
`zdatasource'
`cdatasource'
     Data source variables.


File: octave.info,  Node: Graphics Toolkits,  Prev: Object Groups,  Up: Advanced Plotting

15.4.7 Graphics Toolkits
------------------------

 -- Function File: NAME = graphics_toolkit ()
 -- Function File: NAME = graphics_toolkit (HLIST)
 -- Function File:  graphics_toolkit (NAME)
 -- Function File:  graphics_toolkit (HLIST, NAME)
     Query or set the default graphics toolkit which is assigned to new
     figures.

     With no inputs, return the current default graphics toolkit.  If
     the input is a list of figure graphic handles, HLIST, then return
     the name of the graphics toolkit in use for each figure.

     When called with a single input NAME set the default graphics
     toolkit to NAME.  If the toolkit is not already loaded, it is
     initialized by calling the function `__init_NAME__'.  If the first
     input is a list of figure handles, HLIST, then the graphics
     toolkit is set to NAME for these figures only.

     See also: *note available_graphics_toolkits:
     XREFavailable_graphics_toolkits.


 -- Built-in Function:  available_graphics_toolkits ()
     Return a cell array of registered graphics toolkits.

     See also: *note graphics_toolkit: XREFgraphics_toolkit, *note
     register_graphics_toolkit: XREFregister_graphics_toolkit.


 -- Built-in Function:  loaded_graphics_toolkits ()
     Return a cell array of the currently loaded graphics toolkits.

     See also: *note available_graphics_toolkits:
     XREFavailable_graphics_toolkits.


 -- Built-in Function:  register_graphics_toolkit (TOOLKIT)
     List TOOLKIT as an available graphics toolkit.

     See also: *note available_graphics_toolkits:
     XREFavailable_graphics_toolkits.


* Menu:

* Customizing Toolkit Behavior::


File: octave.info,  Node: Customizing Toolkit Behavior,  Up: Graphics Toolkits

15.4.7.1 Customizing Toolkit Behavior
.....................................

The specific behavior of the backend toolkit may be modified using the
following utility functions.  Note: Not all functions apply to every
graphics toolkit.

 -- Loadable Function: [PROG, ARGS] = gnuplot_binary ()
 -- Loadable Function: [OLD_PROG, OLD_ARGS] = gnuplot_binary (NEW_PROG,
          ARG1, ...)
     Query or set the name of the program invoked by the plot command
     when the graphics toolkit is set to "gnuplot".  Additional
     arguments to pass to the external plotting program may also be
     given.  The default value is "gnuplot" with no additional
     arguments.  *Note Installation::.

     See also: *note graphics_toolkit: XREFgraphics_toolkit.


 -- Built-in Function: MODE = gui_mode ()
 -- Built-in Function:  gui_mode (MODE)
     Query or set the GUI mode for the current graphics toolkit.  The
     MODE argument can be one of the following strings:

    "2d"
          Allows panning and zooming of current axes.

    "3d"
          Allows rotating and zooming of current axes.

    "none"
          Mouse inputs have no effect.

     This function is currently implemented only for the FLTK graphics
     toolkit.

     See also: *note mouse_wheel_zoom: XREFmouse_wheel_zoom.


 -- Built-in Function: SPEED = mouse_wheel_zoom ()
 -- Built-in Function:  mouse_wheel_zoom (SPEED)
     Query or set the mouse wheel zoom factor.

     This function is currently implemented only for the FLTK graphics
     toolkit.

     See also: *note gui_mode: XREFgui_mode.



File: octave.info,  Node: Matrix Manipulation,  Next: Arithmetic,  Prev: Plotting,  Up: Top

16 Matrix Manipulation
**********************

There are a number of functions available for checking to see if the
elements of a matrix meet some condition, and for rearranging the
elements of a matrix.  For example, Octave can easily tell you if all
the elements of a matrix are finite, or are less than some specified
value.  Octave can also rotate the elements, extract the upper- or
lower-triangular parts, or sort the columns of a matrix.

* Menu:

* Finding Elements and Checking Conditions::
* Rearranging Matrices::
* Special Utility Matrices::
* Famous Matrices::


File: octave.info,  Node: Finding Elements and Checking Conditions,  Next: Rearranging Matrices,  Up: Matrix Manipulation

16.1 Finding Elements and Checking Conditions
=============================================

The functions `any' and `all' are useful for determining whether any or
all of the elements of a matrix satisfy some condition.  The `find'
function is also useful in determining which elements of a matrix meet
a specified condition.

 -- Built-in Function:  any (X)
 -- Built-in Function:  any (X, DIM)
     For a vector argument, return true (logical 1) if any element of
     the vector is nonzero.

     For a matrix argument, return a row vector of logical ones and
     zeros with each element indicating whether any of the elements of
     the corresponding column of the matrix are nonzero.  For example:

          any (eye (2, 4))
           => [ 1, 1, 0, 0 ]

     If the optional argument DIM is supplied, work along dimension
     DIM.  For example:

          any (eye (2, 4), 2)
           => [ 1; 1 ]

     See also: *note all: XREFall.


 -- Built-in Function:  all (X)
 -- Built-in Function:  all (X, DIM)
     For a vector argument, return true (logical 1) if all elements of
     the vector are nonzero.

     For a matrix argument, return a row vector of logical ones and
     zeros with each element indicating whether all of the elements of
     the corresponding column of the matrix are nonzero.  For example:

          all ([2, 3; 1, 0]))
              => [ 1, 0 ]

     If the optional argument DIM is supplied, work along dimension DIM.

     See also: *note any: XREFany.


   Since the comparison operators (*note Comparison Ops::) return
matrices of ones and zeros, it is easy to test a matrix for many
things, not just whether the elements are nonzero.  For example,

     all (all (rand (5) < 0.9))
          => 0

tests a random 5 by 5 matrix to see if all of its elements are less
than 0.9.

   Note that in conditional contexts (like the test clause of `if' and
`while' statements) Octave treats the test as if you had typed `all
(all (condition))'.

 -- Mapping Function: Z = xor (X, Y)
     Return the "exclusive or" of the entries of X and Y.  For boolean
     expressions X and Y, `xor (X, Y)' is true if and only if one of X
     or Y is true.  Otherwise, for X and Y both true or both false,
     `xor' returns false.

     The truth table for the xor operation is

                                   X  Y   Z  
                                   0  0   0  
                                   1  0   1  
                                   0  1   1  
                                   1  1   0  

     See also: *note and: XREFand, *note or: XREFor, *note not: XREFnot.


 -- Built-in Function:  diff (X)
 -- Built-in Function:  diff (X, K)
 -- Built-in Function:  diff (X, K, DIM)
     If X is a vector of length n, `diff (X)' is the vector of first
     differences  X(2) - X(1), ..., X(n) - X(n-1).

     If X is a matrix, `diff (X)' is the matrix of column differences
     along the first non-singleton dimension.

     The second argument is optional.  If supplied, `diff (X, K)',
     where K is a non-negative integer, returns the K-th differences.
     It is possible that K is larger than the first non-singleton
     dimension of the matrix.  In this case, `diff' continues to take
     the differences along the next non-singleton dimension.

     The dimension along which to take the difference can be explicitly
     stated with the optional variable DIM.  In this case the K-th
     order differences are calculated along this dimension.  In the
     case where K exceeds `size (X, DIM)' an empty matrix is returned.

     See also: *note sort: XREFsort, *note merge: XREFmerge.


 -- Mapping Function:  isinf (X)
     Return a logical array which is true where the elements of X are
     are infinite and false where they are not.  For example:

          isinf ([13, Inf, NA, NaN])
                => [ 0, 1, 0, 0 ]

     See also: *note isfinite: XREFisfinite, *note isnan: XREFisnan,
     *note isna: XREFisna.


 -- Mapping Function:  isnan (X)
     Return a logical array which is true where the elements of X are
     NaN values and false where they are not.  NA values are also
     considered NaN values.  For example:

          isnan ([13, Inf, NA, NaN])
                => [ 0, 0, 1, 1 ]

     See also: *note isna: XREFisna, *note isinf: XREFisinf, *note
     isfinite: XREFisfinite.


 -- Mapping Function:  isfinite (X)
 -- Mapping Function:  finite (X)
     Return a logical array which is true where the elements of X are
     finite values and false where they are not.  For example:

          finite ([13, Inf, NA, NaN])
               => [ 1, 0, 0, 0 ]

     See also: *note isinf: XREFisinf, *note isnan: XREFisnan, *note
     isna: XREFisna.


 -- Function File: [ERR, Y1, ...] = common_size (X1, ...)
     Determine if all input arguments are either scalar or of common
     size.  If so, ERR is zero, and YI is a matrix of the common size
     with all entries equal to XI if this is a scalar or XI otherwise.
     If the inputs cannot be brought to a common size, ERR is 1, and YI
     is XI.  For example:

          [errorcode, a, b] = common_size ([1 2; 3 4], 5)
               => errorcode = 0
               => a = [ 1, 2; 3, 4 ]
               => b = [ 5, 5; 5, 5 ]

     This is useful for implementing functions where arguments can
     either be scalars or of common size.

 -- Built-in Function: IDX = find (X)
 -- Built-in Function: IDX = find (X, N)
 -- Built-in Function: IDX = find (X, N, DIRECTION)
 -- Built-in Function: [i, j] = find (...)
 -- Built-in Function: [i, j, v] = find (...)
     Return a vector of indices of nonzero elements of a matrix, as a
     row if X is a row vector or as a column otherwise.  To obtain a
     single index for each matrix element, Octave pretends that the
     columns of a matrix form one long vector (like Fortran arrays are
     stored).  For example:

          find (eye (2))
            => [ 1; 4 ]

     If two outputs are requested, `find' returns the row and column
     indices of nonzero elements of a matrix.  For example:

          [i, j] = find (2 * eye (2))
              => i = [ 1; 2 ]
              => j = [ 1; 2 ]

     If three outputs are requested, `find' also returns a vector
     containing the nonzero values.  For example:

          [i, j, v] = find (3 * eye (2))
                 => i = [ 1; 2 ]
                 => j = [ 1; 2 ]
                 => v = [ 3; 3 ]

     If two inputs are given, N indicates the maximum number of
     elements to find from the beginning of the matrix or vector.

     If three inputs are given, DIRECTION should be one of "first" or
     "last", requesting only the first or last N indices, respectively.
     However, the indices are always returned in ascending order.

     Note that this function is particularly useful for sparse
     matrices, as it extracts the non-zero elements as vectors, which
     can then be used to create the original matrix.  For example:

          sz = size (a);
          [i, j, v] = find (a);
          b = sparse (i, j, v, sz(1), sz(2));

     See also: *note nonzeros: XREFnonzeros.


 -- Built-in Function: IDX = lookup (TABLE, Y)
 -- Built-in Function: IDX = lookup (TABLE, Y, OPT)
     Lookup values in a sorted table.  Usually used as a prelude to
     interpolation.

     If table is increasing and `idx = lookup (table, y)', then
     `table(idx(i)) <= y(i) < table(idx(i+1))' for all `y(i)' within
     the table.  If `y(i) < table(1)' then `idx(i)' is 0. If `y(i) >=
     table(end)' or `isnan (y(i))' then `idx(i)' is `n'.

     If the table is decreasing, then the tests are reversed.  For
     non-strictly monotonic tables, empty intervals are always skipped.
     The result is undefined if TABLE is not monotonic, or if TABLE
     contains a NaN.

     The complexity of the lookup is O(M*log(N)) where N is the size of
     TABLE and M is the size of Y.  In the special case when Y is also
     sorted, the complexity is O(min(M*log(N),M+N)).

     TABLE and Y can also be cell arrays of strings (or Y can be a
     single string).  In this case, string lookup is performed using
     lexicographical comparison.

     If OPTS is specified, it must be a string with letters indicating
     additional options.

    `m'
          `table(idx(i)) == val(i)' if `val(i)' occurs in table;
          otherwise, `idx(i)' is zero.

    `b'
          `idx(i)' is a logical 1 or 0, indicating whether `val(i)' is
          contained in table or not.

    `l'
          For numeric lookups the leftmost subinterval shall be
          extended to infinity (i.e., all indices at least 1)

    `r'
          For numeric lookups the rightmost subinterval shall be
          extended to infinity (i.e., all indices at most n-1).

   If you wish to check if a variable exists at all, instead of
properties its elements may have, consult *note Status of Variables::.


File: octave.info,  Node: Rearranging Matrices,  Next: Special Utility Matrices,  Prev: Finding Elements and Checking Conditions,  Up: Matrix Manipulation

16.2 Rearranging Matrices
=========================

 -- Function File:  fliplr (X)
     Return a copy of X with the order of the columns reversed.  In
     other words, X is flipped left-to-right about a vertical axis.  For
     example:

          fliplr ([1, 2; 3, 4])
               =>  2  1
                   4  3

     Note that `fliplr' only works with 2-D arrays.  To flip N-D arrays
     use `flipdim' instead.

     See also: *note flipud: XREFflipud, *note flipdim: XREFflipdim,
     *note rot90: XREFrot90, *note rotdim: XREFrotdim.


 -- Function File:  flipud (X)
     Return a copy of X with the order of the rows reversed.  In other
     words, X is flipped upside-down about a horizontal axis.  For
     example:

          flipud ([1, 2; 3, 4])
               =>  3  4
                   1  2

     Note that `flipud' only works with 2-D arrays.  To flip N-D arrays
     use `flipdim' instead.

     See also: *note fliplr: XREFfliplr, *note flipdim: XREFflipdim,
     *note rot90: XREFrot90, *note rotdim: XREFrotdim.


 -- Function File:  flipdim (X)
 -- Function File:  flipdim (X, DIM)
     Return a copy of X flipped about the dimension DIM.  DIM defaults
     to the first non-singleton dimension.  For example:

          flipdim ([1, 2; 3, 4], 2)
                =>  2  1
                    4  3

     See also: *note fliplr: XREFfliplr, *note flipud: XREFflipud,
     *note rot90: XREFrot90, *note rotdim: XREFrotdim.


 -- Function File:  rot90 (A)
 -- Function File:  rot90 (A, K)
     Return a copy of A with the elements rotated counterclockwise in
     90-degree increments.  The second argument is optional, and
     specifies how many 90-degree rotations are to be applied (the
     default value is 1).  Negative values of K rotate the matrix in a
     clockwise direction.  For example,

          rot90 ([1, 2; 3, 4], -1)
              =>  3  1
                  4  2

     rotates the given matrix clockwise by 90 degrees.  The following
     are all equivalent statements:

          rot90 ([1, 2; 3, 4], -1)
          rot90 ([1, 2; 3, 4], 3)
          rot90 ([1, 2; 3, 4], 7)

     Note that `rot90' only works with 2-D arrays.  To rotate N-D arrays
     use `rotdim' instead.

     See also: *note rotdim: XREFrotdim, *note flipud: XREFflipud,
     *note fliplr: XREFfliplr, *note flipdim: XREFflipdim.


 -- Function File:  rotdim (X)
 -- Function File:  rotdim (X, N)
 -- Function File:  rotdim (X, N, PLANE)
     Return a copy of X with the elements rotated counterclockwise in
     90-degree increments.  The second argument N is optional, and
     specifies how many 90-degree rotations are to be applied (the
     default value is 1).  The third argument is also optional and
     defines the plane of the rotation.  If present, PLANE is a two
     element vector containing two different valid dimensions of the
     matrix.  When PLANE is not given the first two non-singleton
     dimensions are used.

     Negative values of N rotate the matrix in a clockwise direction.
     For example,

          rotdim ([1, 2; 3, 4], -1, [1, 2])
               =>  3  1
                   4  2

     rotates the given matrix clockwise by 90 degrees.  The following
     are all equivalent statements:

          rotdim ([1, 2; 3, 4], -1, [1, 2])
          rotdim ([1, 2; 3, 4], 3, [1, 2])
          rotdim ([1, 2; 3, 4], 7, [1, 2])

     See also: *note rot90: XREFrot90, *note flipud: XREFflipud, *note
     fliplr: XREFfliplr, *note flipdim: XREFflipdim.


 -- Built-in Function:  cat (DIM, ARRAY1, ARRAY2, ..., ARRAYN)
     Return the concatenation of N-D array objects, ARRAY1, ARRAY2,
     ..., ARRAYN along dimension DIM.

          A = ones (2, 2);
          B = zeros (2, 2);
          cat (2, A, B)
            => 1 1 0 0
               1 1 0 0

     Alternatively, we can concatenate A and B along the second
     dimension in the following way:

          [A, B]

     DIM can be larger than the dimensions of the N-D array objects and
     the result will thus have DIM dimensions as the following example
     shows:

          cat (4, ones (2, 2), zeros (2, 2))
            => ans(:,:,1,1) =

                 1 1
                 1 1

               ans(:,:,1,2) =

                 0 0
                 0 0

     See also: *note horzcat: XREFhorzcat, *note vertcat: XREFvertcat.


 -- Built-in Function:  horzcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the horizontal concatenation of N-D array objects, ARRAY1,
     ARRAY2, ..., ARRAYN along dimension 2.

     Arrays may also be concatenated horizontally using the syntax for
     creating new matrices.  For example:

          HCAT = [ ARRAY1, ARRAY2, ... ]

     See also: *note cat: XREFcat, *note vertcat: XREFvertcat.


 -- Built-in Function:  vertcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the vertical concatenation of N-D array objects, ARRAY1,
     ARRAY2, ..., ARRAYN along dimension 1.

     Arrays may also be concatenated vertically using the syntax for
     creating new matrices.  For example:

          VCAT = [ ARRAY1; ARRAY2; ... ]

     See also: *note cat: XREFcat, *note horzcat: XREFhorzcat.


 -- Built-in Function:  permute (A, PERM)
     Return the generalized transpose for an N-D array object A.  The
     permutation vector PERM must contain the elements `1:ndims (A)'
     (in any order, but each element must appear only once).

     See also: *note ipermute: XREFipermute.


 -- Built-in Function:  ipermute (A, IPERM)
     The inverse of the `permute' function.  The expression

          ipermute (permute (A, perm), perm)

     returns the original array A.

     See also: *note permute: XREFpermute.


 -- Built-in Function:  reshape (A, M, N, ...)
 -- Built-in Function:  reshape (A, [M N ...])
 -- Built-in Function:  reshape (A, ..., [], ...)
 -- Built-in Function:  reshape (A, SIZE)
     Return a matrix with the specified dimensions (M, N, ...)  whose
     elements are taken from the matrix A.  The elements of the matrix
     are accessed in column-major order (like Fortran arrays are
     stored).

     The following code demonstrates reshaping a 1x4 row vector into a
     2x2 square matrix.

          reshape ([1, 2, 3, 4], 2, 2)
                =>  1  3
                    2  4

     Note that the total number of elements in the original matrix
     (`prod (size (A))') must match the total number of elements in the
     new matrix (`prod ([M N ...])').

     A single dimension of the return matrix may be left unspecified
     and Octave will determine its size automatically.  An empty matrix
     ([]) is used to flag the unspecified dimension.

     See also: *note resize: XREFresize, *note vec: XREFvec, *note
     postpad: XREFpostpad, *note cat: XREFcat, *note squeeze:
     XREFsqueeze.


 -- Built-in Function:  resize (X, M)
 -- Built-in Function:  resize (X, M, N, ...)
 -- Built-in Function:  resize (X, [M N ...])
     Resize X cutting off elements as necessary.

     In the result, element with certain indices is equal to the
     corresponding element of X if the indices are within the bounds of
     X; otherwise, the element is set to zero.

     In other words, the statement

          y = resize (x, dv)

     is equivalent to the following code:

          y = zeros (dv, class (x));
          sz = min (dv, size (x));
          for i = 1:length (sz)
            idx{i} = 1:sz(i);
          endfor
          y(idx{:}) = x(idx{:});

     but is performed more efficiently.

     If only M is supplied, and it is a scalar, the dimension of the
     result is M-by-M.  If M, N, ... are all scalars, then the
     dimensions of the result are M-by-N-by-....  If given a vector as
     input, then the dimensions of the result are given by the elements
     of that vector.

     An object can be resized to more dimensions than it has; in such
     case the missing dimensions are assumed to be 1.  Resizing an
     object to fewer dimensions is not possible.

     See also: *note reshape: XREFreshape, *note postpad: XREFpostpad,
     *note prepad: XREFprepad, *note cat: XREFcat.


 -- Function File: Y = circshift (X, N)
     Circularly shift the values of the array X.  N must be a vector of
     integers no longer than the number of dimensions in X.  The values
     of N can be either positive or negative, which determines the
     direction in which the values or X are shifted.  If an element of
     N is zero, then the corresponding dimension of X will not be
     shifted.  For example:

          x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
          circshift (x, 1)
          =>  7, 8, 9
              1, 2, 3
              4, 5, 6
          circshift (x, -2)
          =>  7, 8, 9
              1, 2, 3
              4, 5, 6
          circshift (x, [0,1])
          =>  3, 1, 2
              6, 4, 5
              9, 7, 8

     See also: permute, ipermute, shiftdim.


 -- Function File:  shift (X, B)
 -- Function File:  shift (X, B, DIM)
     If X is a vector, perform a circular shift of length B of the
     elements of X.

     If X is a matrix, do the same for each column of X.  If the
     optional DIM argument is given, operate along this dimension.

 -- Function File: Y = shiftdim (X, N)
 -- Function File: [Y, NS] = shiftdim (X)
     Shift the dimensions of X by N, where N must be an integer scalar.
     When N is positive, the dimensions of X are shifted to the left,
     with the leading dimensions circulated to the end.  If N is
     negative, then the dimensions of X are shifted to the right, with
     N leading singleton dimensions added.

     Called with a single argument, `shiftdim', removes the leading
     singleton dimensions, returning the number of dimensions removed
     in the second output argument NS.

     For example:

          x = ones (1, 2, 3);
          size (shiftdim (x, -1))
             => [1, 1, 2, 3]
          size (shiftdim (x, 1))
             => [2, 3]
          [b, ns] = shiftdim (x)
             => b = [1, 1, 1; 1, 1, 1]
             => ns = 1

     See also: reshape, permute, ipermute, circshift, squeeze.


 -- Built-in Function: [S, I] = sort (X)
 -- Built-in Function: [S, I] = sort (X, DIM)
 -- Built-in Function: [S, I] = sort (X, MODE)
 -- Built-in Function: [S, I] = sort (X, DIM, MODE)
     Return a copy of X with the elements arranged in increasing order.
     For matrices, `sort' orders the elements within columns

     For example:

          sort ([1, 2; 2, 3; 3, 1])
             =>  1  1
                 2  2
                 3  3

     If the optional argument DIM is given, then the matrix is sorted
     along the dimension defined by DIM.  The optional argument `mode'
     defines the order in which the values will be sorted.  Valid
     values of `mode' are "ascend" or "descend".

     The `sort' function may also be used to produce a matrix
     containing the original row indices of the elements in the sorted
     matrix.  For example:

          [s, i] = sort ([1, 2; 2, 3; 3, 1])
            => s = 1  1
                   2  2
                   3  3
            => i = 1  3
                   2  1
                   3  2

     For equal elements, the indices are such that equal elements are
     listed in the order in which they appeared in the original list.

     Sorting of complex entries is done first by magnitude (`abs (Z)')
     and for any ties by phase angle (`angle (z)').  For example:

          sort ([1+i; 1; 1-i])
              => 1 + 0i
                 1 - 1i
                 1 + 1i

     NaN values are treated as being greater than any other value and
     are sorted to the end of the list.

     The `sort' function may also be used to sort strings and cell
     arrays of strings, in which case ASCII dictionary order (uppercase
     'A' precedes lowercase 'a') of the strings is used.

     The algorithm used in `sort' is optimized for the sorting of
     partially ordered lists.

     See also: *note sortrows: XREFsortrows, *note issorted:
     XREFissorted.


 -- Function File: [S, I] = sortrows (A)
 -- Function File: [S, I] = sortrows (A, C)
     Sort the rows of the matrix A according to the order of the
     columns specified in C.  If C is omitted, a lexicographical sort
     is used.  By default ascending order is used however if elements
     of C are negative then the corresponding column is sorted in
     descending order.

     See also: *note sort: XREFsort.


 -- Built-in Function:  issorted (A)
 -- Built-in Function:  issorted (A, MODE)
 -- Built-in Function:  issorted (A, "rows", MODE)
     Return true if the array is sorted according to MODE, which may be
     either "ascending", "descending", or "either".  By default,  MODE
     is "ascending".  NaNs are treated in the same manner as `sort'.

     If the optional argument "rows" is supplied, check whether the
     array is sorted by rows as output by the function `sortrows' (with
     no options).

     This function does not support sparse matrices.

     See also: *note sort: XREFsort, *note sortrows: XREFsortrows.


 -- Built-in Function:  nth_element (X, N)
 -- Built-in Function:  nth_element (X, N, DIM)
     Select the n-th smallest element of a vector, using the ordering
     defined by `sort'.  In other words, the result is equivalent to
     `sort(X)(N)'.  N can also be a contiguous range, either ascending
     `l:u' or descending `u:-1:l', in which case a range of elements is
     returned.  If X is an array, `nth_element' operates along the
     dimension defined by DIM, or the first non-singleton dimension if
     DIM is not given.

     nth_element encapsulates the C++ standard library algorithms
     nth_element and partial_sort.  On average, the complexity of the
     operation is O(M*log(K)), where `M = size (X, DIM)' and
     `K = length (N)'.  This function is intended for cases where the
     ratio K/M is small; otherwise, it may be better to use `sort'.

     See also: *note sort: XREFsort, *note min: XREFmin, *note max:
     XREFmax.


 -- Function File:  tril (A)
 -- Function File:  tril (A, K)
 -- Function File:  tril (A, K, PACK)
 -- Function File:  triu (A)
 -- Function File:  triu (A, K)
 -- Function File:  triu (A, K, PACK)
     Return a new matrix formed by extracting the lower (`tril') or
     upper (`triu') triangular part of the matrix A, and setting all
     other elements to zero.  The second argument is optional, and
     specifies how many diagonals above or below the main diagonal
     should also be set to zero.

     The default value of K is zero, so that `triu' and `tril' normally
     include the main diagonal as part of the result.

     If the value of K is nonzero integer, the selection of elements
     starts at an offset of K diagonals above or below the main
     diagonal; above for positive K and below for negative K.

     The absolute value of K must not be greater than the number of
     sub-diagonals or super-diagonals.

     For example:

          tril (ones (3), -1)
               =>  0  0  0
                   1  0  0
                   1  1  0

     and

          tril (ones (3), 1)
               =>  1  1  0
                   1  1  1
                   1  1  1

     If the option "pack" is given as third argument, the extracted
     elements are not inserted into a matrix, but rather stacked
     column-wise one above other.

     See also: *note diag: XREFdiag.


 -- Built-in Function: V = vec (X)
 -- Built-in Function: V = vec (X, DIM)
     Return the vector obtained by stacking the columns of the matrix X
     one above the other.  Without DIM this is equivalent to `X(:)'.
     If DIM is supplied, the dimensions of V are set to DIM with all
     elements along the last dimension.  This is equivalent to
     `shiftdim (X(:), 1-DIM)'.

     See also: *note vech: XREFvech, *note resize: XREFresize, *note
     cat: XREFcat.


 -- Function File:  vech (X)
     Return the vector obtained by eliminating all supradiagonal
     elements of the square matrix X and stacking the result one column
     above the other.  This has uses in matrix calculus where the
     underlying matrix is symmetric and it would be pointless to keep
     values above the main diagonal.

     See also: *note vec: XREFvec.


 -- Function File:  prepad (X, L)
 -- Function File:  prepad (X, L, C)
 -- Function File:  prepad (X, L, C, DIM)
     Prepend the scalar value C to the vector X until it is of length
     L.  If C is not given, a value of 0 is used.

     If `length (X) > L', elements from the beginning of X are removed
     until a vector of length L is obtained.

     If X is a matrix, elements are prepended or removed from each row.

     If the optional argument DIM is given, operate along this
     dimension.

     See also: *note postpad: XREFpostpad, *note cat: XREFcat, *note
     resize: XREFresize.


 -- Function File:  postpad (X, L)
 -- Function File:  postpad (X, L, C)
 -- Function File:  postpad (X, L, C, DIM)
     Append the scalar value C to the vector X until it is of length L.
     If C is not given, a value of 0 is used.

     If `length (X) > L', elements from the end of X are removed until
     a vector of length L is obtained.

     If X is a matrix, elements are appended or removed from each row.

     If the optional argument DIM is given, operate along this
     dimension.

     See also: *note prepad: XREFprepad, *note cat: XREFcat, *note
     resize: XREFresize.


 -- Built-in Function: M = diag (V)
 -- Built-in Function: M = diag (V, K)
 -- Built-in Function: M = diag (V, M, N)
 -- Built-in Function: V = diag (M)
 -- Built-in Function: V = diag (M, K)
     Return a diagonal matrix with vector V on diagonal K.  The second
     argument is optional.  If it is positive, the vector is placed on
     the K-th super-diagonal.  If it is negative, it is placed on the
     -K-th sub-diagonal.  The default value of K is 0, and the vector
     is placed on the main diagonal.  For example:

          diag ([1, 2, 3], 1)
             =>  0  1  0  0
                 0  0  2  0
                 0  0  0  3
                 0  0  0  0

     The 3-input form returns a diagonal matrix with vector V on the
     main diagonal and the resulting matrix being of size M rows x N
     columns.

     Given a matrix argument, instead of a vector, `diag' extracts the
     K-th diagonal of the matrix.

 -- Function File:  blkdiag (A, B, C, ...)
     Build a block diagonal matrix from A, B, C, ...  All the arguments
     must be numeric and are two-dimensional matrices or scalars.  If
     any argument is of type sparse, the output will also be sparse.

     See also: *note diag: XREFdiag, *note horzcat: XREFhorzcat, *note
     vertcat: XREFvertcat, *note sparse: XREFsparse.



File: octave.info,  Node: Special Utility Matrices,  Next: Famous Matrices,  Prev: Rearranging Matrices,  Up: Matrix Manipulation

16.3 Special Utility Matrices
=============================

 -- Built-in Function:  eye (N)
 -- Built-in Function:  eye (M, N)
 -- Built-in Function:  eye ([M N])
 -- Built-in Function:  eye (..., CLASS)
     Return an identity matrix.  If invoked with a single scalar
     argument N, return a square NxN identity matrix.  If supplied two
     scalar arguments (M, N), `eye' takes them to be the number of rows
     and columns.  If given a vector with two elements, `eye' uses the
     values of the elements as the number of rows and columns,
     respectively.  For example:

          eye (3)
           =>  1  0  0
               0  1  0
               0  0  1

     The following expressions all produce the same result:

          eye (2)
          ==
          eye (2, 2)
          ==
          eye (size ([1, 2; 3, 4])

     The optional argument CLASS, allows `eye' to return an array of
     the specified type, like

          val = zeros (n,m, "uint8")

     Calling `eye' with no arguments is equivalent to calling it with
     an argument of 1.  Any negative dimensions are treated as zero.
     These odd definitions are for compatibility with MATLAB.

     See also: *note speye: XREFspeye, *note ones: XREFones, *note
     zeros: XREFzeros.


 -- Built-in Function:  ones (N)
 -- Built-in Function:  ones (M, N)
 -- Built-in Function:  ones (M, N, K, ...)
 -- Built-in Function:  ones ([M N ...])
 -- Built-in Function:  ones (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 1.
     If invoked with a single scalar integer argument N, return a square
     NxN matrix.  If invoked with two or more scalar integer arguments,
     or a vector of integer values, return an array with the given
     dimensions.

     If you need to create a matrix whose values are all the same, you
     should use an expression like

          val_matrix = val * ones (m, n)

     The optional argument CLASS specifies the class of the return array
     and defaults to double.  For example:

          val = ones (m,n, "uint8")

     See also: *note zeros: XREFzeros.


 -- Built-in Function:  zeros (N)
 -- Built-in Function:  zeros (M, N)
 -- Built-in Function:  zeros (M, N, K, ...)
 -- Built-in Function:  zeros ([M N ...])
 -- Built-in Function:  zeros (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 0.
     If invoked with a single scalar integer argument, return a square
     NxN matrix.  If invoked with two or more scalar integer arguments,
     or a vector of integer values, return an array with the given
     dimensions.

     The optional argument CLASS specifies the class of the return array
     and defaults to double.  For example:

          val = zeros (m,n, "uint8")

     See also: *note ones: XREFones.


 -- Function File:  repmat (A, M)
 -- Function File:  repmat (A, M, N)
 -- Function File:  repmat (A, [M N])
 -- Function File:  repmat (A, [M N P ...])
     Form a block matrix of size M by N, with a copy of matrix A as
     each element.  If N is not specified, form an M by M block matrix.
     For copying along more than two dimensions, specify the number of
     times to copy across each dimension M, N, P, ..., in a vector in
     the second argument.

     See also: *note repelems: XREFrepelems.


 -- Built-in Function:  repelems (X, R)
     Construct a vector of repeated elements from X.  R is a 2xN
     integer matrix specifying which elements to repeat and how often
     to repeat each element.

     Entries in the first row, R(1,j), select an element to repeat.
     The corresponding entry in the second row, R(2,j), specifies the
     repeat count.  If X is a matrix then the columns of X are imagined
     to be stacked on top of each other for purposes of the selection
     index.  A row vector is always returned.

     Conceptually the result is calculated as follows:

          y = [];
          for i = 1:columns (R)
            y = [y, X(R(1,i)*ones(1, R(2,i)))];
          endfor

     See also: *note repmat: XREFrepmat, *note cat: XREFcat.


   The functions `linspace' and `logspace' make it very easy to create
vectors with evenly or logarithmically spaced elements.  *Note Ranges::.

 -- Built-in Function:  linspace (BASE, LIMIT)
 -- Built-in Function:  linspace (BASE, LIMIT, N)
     Return a row vector with N linearly spaced elements between BASE
     and LIMIT.  If the number of elements is greater than one, then
     the endpoints BASE and LIMIT are always included in the range.  If
     BASE is greater than LIMIT, the elements are stored in decreasing
     order.  If the number of points is not specified, a value of 100
     is used.

     The `linspace' function always returns a row vector if both BASE
     and LIMIT are scalars.  If one, or both, of them are column
     vectors, `linspace' returns a matrix.

     For compatibility with MATLAB, return the second argument (LIMIT)
     if fewer than two values are requested.

     See also: *note logspace: XREFlogspace.


 -- Function File:  logspace (A, B)
 -- Function File:  logspace (A, B, N)
 -- Function File:  logspace (A, pi, N)
     Return a row vector with N elements logarithmically spaced from
     10^A to 10^B.  If N is unspecified it defaults to 50.

     If B is equal to pi, the points are between 10^A and pi, _not_
     10^A and 10^pi, in order to be compatible with the corresponding
     MATLAB function.

     Also for compatibility with MATLAB, return the second argument B
     if fewer than two values are requested.

     See also: *note linspace: XREFlinspace.


 -- Built-in Function:  rand (N)
 -- Built-in Function:  rand (N, M, ...)
 -- Built-in Function:  rand ([N M ...])
 -- Built-in Function: V = rand ("state")
 -- Built-in Function:  rand ("state", V)
 -- Built-in Function:  rand ("state", "reset")
 -- Built-in Function: V = rand ("seed")
 -- Built-in Function:  rand ("seed", V)
 -- Built-in Function:  rand ("seed", "reset")
 -- Built-in Function:  rand (..., "single")
 -- Built-in Function:  rand (..., "double")
     Return a matrix with random elements uniformly distributed on the
     interval (0, 1).  The arguments are handled the same as the
     arguments for `eye'.

     You can query the state of the random number generator using the
     form

          v = rand ("state")

     This returns a column vector V of length 625.  Later, you can
     restore the random number generator to the state V using the form

          rand ("state", v)

     You may also initialize the state vector from an arbitrary vector
     of length <= 625 for V.  This new state will be a hash based on the
     value of V, not V itself.

     By default, the generator is initialized from `/dev/urandom' if it
     is available, otherwise from CPU time, wall clock time, and the
     current fraction of a second.  Note that this differs from MATLAB,
     which always initializes the state to the same state at startup.
     To obtain behavior comparable to MATLAB, initialize with a
     deterministic state vector in Octave's startup files (*note
     Startup Files::).

     To compute the pseudo-random sequence, `rand' uses the Mersenne
     Twister with a period of 2^19937-1 (See M. Matsumoto and T.
     Nishimura, `Mersenne Twister: A 623-dimensionally equidistributed
     uniform pseudorandom number generator', ACM Trans. on Modeling and
     Computer Simulation Vol. 8, No. 1, pp. 3-30, January 1998,
     `http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html').  Do
     *not* use for cryptography without securely hashing several
     returned values together, otherwise the generator state can be
     learned after reading 624 consecutive values.

     Older versions of Octave used a different random number generator.
     The new generator is used by default as it is significantly faster
     than the old generator, and produces random numbers with a
     significantly longer cycle time.  However, in some circumstances
     it might be desirable to obtain the same random sequences as used
     by the old generators.  To do this the keyword "seed" is used to
     specify that the old generators should be use, as in

          rand ("seed", val)

     which sets the seed of the generator to VAL.  The seed of the
     generator can be queried with

          s = rand ("seed")

     However, it should be noted that querying the seed will not cause
     `rand' to use the old generators, only setting the seed will.  To
     cause `rand' to once again use the new generators, the keyword
     "state" should be used to reset the state of the `rand'.

     The state or seed of the generator can be reset to a new random
     value using the "reset" keyword.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     See also: *note randn: XREFrandn, *note rande: XREFrande, *note
     randg: XREFrandg, *note randp: XREFrandp.


 -- Function File:  randi (IMAX)
 -- Function File:  randi (IMAX, N)
 -- Function File:  randi (IMAX, M, N, ...)
 -- Function File:  randi ([IMIN IMAX], ...)
 -- Function File:  randi (..., "CLASS")
     Return random integers in the range 1:IMAX.

     Additional arguments determine the shape of the return matrix.
     When no arguments are specified a single random integer is
     returned.  If one argument N is specified then a square matrix
     (N x N) is returned.  Two or more arguments will return a
     multi-dimensional matrix (M x N x ...).

     The integer range may optionally be described by a two element
     matrix with a lower and upper bound in which case the returned
     integers will be on the interval [IMIN, IMAX].

     The optional argument CLASS will return a matrix of the requested
     type.  The default is "double".

     The following example returns 150 integers in the range 1-10.

          ri = randi (10, 150, 1)

     Implementation Note: `randi' relies internally on `rand' which
     uses class "double" to represent numbers.  This limits the maximum
     integer (IMAX) and range (IMAX - IMIN) to the value returned by
     the `bitmax' function.  For IEEE floating point numbers this value
     is 2^53 - 1.

     See also: *note rand: XREFrand.


 -- Built-in Function:  randn (N)
 -- Built-in Function:  randn (N, M, ...)
 -- Built-in Function:  randn ([N M ...])
 -- Built-in Function: V = randn ("state")
 -- Built-in Function:  randn ("state", V)
 -- Built-in Function:  randn ("state", "reset")
 -- Built-in Function: V = randn ("seed")
 -- Built-in Function:  randn ("seed", V)
 -- Built-in Function:  randn ("seed", "reset")
 -- Built-in Function:  randn (..., "single")
 -- Built-in Function:  randn (..., "double")
     Return a matrix with normally distributed random elements having
     zero mean and variance one.  The arguments are handled the same as
     the arguments for `rand'.

     By default, `randn' uses the Marsaglia and Tsang "Ziggurat
     technique" to transform from a uniform to a normal distribution.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     Reference: G. Marsaglia and W.W. Tsang, `Ziggurat Method for
     Generating Random Variables', J. Statistical Software, vol 5, 2000,
     `http://www.jstatsoft.org/v05/i08/')

     See also: *note rand: XREFrand, *note rande: XREFrande, *note
     randg: XREFrandg, *note randp: XREFrandp.


 -- Built-in Function:  rande (N)
 -- Built-in Function:  rande (N, M, ...)
 -- Built-in Function:  rande ([N M ...])
 -- Built-in Function: V = rande ("state")
 -- Built-in Function:  rande ("state", V)
 -- Built-in Function:  rande ("state", "reset")
 -- Built-in Function: V = rande ("seed")
 -- Built-in Function:  rande ("seed", V)
 -- Built-in Function:  rande ("seed", "reset")
 -- Built-in Function:  rande (..., "single")
 -- Built-in Function:  rande (..., "double")
     Return a matrix with exponentially distributed random elements.
     The arguments are handled the same as the arguments for `rand'.

     By default, `randn' uses the Marsaglia and Tsang "Ziggurat
     technique" to transform from a uniform to an exponential
     distribution.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     Reference: G. Marsaglia and W.W. Tsang, `Ziggurat Method for
     Generating Random Variables', J. Statistical Software, vol 5, 2000,
     `http://www.jstatsoft.org/v05/i08/')

     See also: *note rand: XREFrand, *note randn: XREFrandn, *note
     randg: XREFrandg, *note randp: XREFrandp.


 -- Built-in Function:  randp (L, N)
 -- Built-in Function:  randp (L, N, M, ...)
 -- Built-in Function:  randp (L, [N M ...])
 -- Built-in Function: V = randp ("state")
 -- Built-in Function:  randp ("state", V)
 -- Built-in Function:  randp ("state", "reset")
 -- Built-in Function: V = randp ("seed")
 -- Built-in Function:  randp ("seed", V)
 -- Built-in Function:  randp ("seed", "reset")
 -- Built-in Function:  randp (..., "single")
 -- Built-in Function:  randp (..., "double")
     Return a matrix with Poisson distributed random elements with mean
     value parameter given by the first argument, L.  The arguments are
     handled the same as the arguments for `rand', except for the
     argument L.

     Five different algorithms are used depending on the range of L and
     whether or not L is a scalar or a matrix.

    For scalar L <= 12, use direct method.
          W.H. Press, et al., `Numerical Recipes in C', Cambridge
          University Press, 1992.

    For scalar L > 12, use rejection method.[1]
          W.H. Press, et al., `Numerical Recipes in C', Cambridge
          University Press, 1992.

    For matrix L <= 10, use inversion method.[2]
          E. Stadlober, et al., WinRand source code, available via FTP.

    For matrix L > 10, use patchwork rejection method.
          E. Stadlober, et al., WinRand source code, available via FTP,
          or H. Zechner, `Efficient sampling from continuous and
          discrete unimodal distributions', Doctoral Dissertation,
          156pp., Technical University Graz, Austria, 1994.

    For L > 1e8, use normal approximation.
          L. Montanet, et al., `Review of Particle Properties',
          Physical Review D 50 p1284, 1994.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     See also: *note rand: XREFrand, *note randn: XREFrandn, *note
     rande: XREFrande, *note randg: XREFrandg.


 -- Built-in Function:  randg (N)
 -- Built-in Function:  randg (N, M, ...)
 -- Built-in Function:  randg ([N M ...])
 -- Built-in Function: V = randg ("state")
 -- Built-in Function:  randg ("state", V)
 -- Built-in Function:  randg ("state", "reset")
 -- Built-in Function: V = randg ("seed")
 -- Built-in Function:  randg ("seed", V)
 -- Built-in Function:  randg ("seed", "reset")
 -- Built-in Function:  randg (..., "single")
 -- Built-in Function:  randg (..., "double")
     Return a matrix with `gamma (A,1)' distributed random elements.
     The arguments are handled the same as the arguments for `rand',
     except for the argument A.

     This can be used to generate many distributions:

    `gamma (a, b)' for `a > -1', `b > 0'
               r = b * randg (a)

    `beta (a, b)' for `a > -1', `b > -1'
               r1 = randg (a, 1)
               r = r1 / (r1 + randg (b, 1))

    `Erlang (a, n)'
               r = a * randg (n)

    `chisq (df)' for `df > 0'
               r = 2 * randg (df / 2)

    `t (df)' for `0 < df < inf' (use randn if df is infinite)
               r = randn () / sqrt (2 * randg (df / 2) / df)

    `F (n1, n2)' for `0 < n1', `0 < n2'
               ## r1 equals 1 if n1 is infinite
               r1 = 2 * randg (n1 / 2) / n1
               ## r2 equals 1 if n2 is infinite
               r2 = 2 * randg (n2 / 2) / n2
               r = r1 / r2

    negative `binomial (n, p)' for `n > 0', `0 < p <= 1'
               r = randp ((1 - p) / p * randg (n))

    non-central `chisq (df, L)', for `df >= 0' and `L > 0'
          (use chisq if `L = 0')

               r = randp (L / 2)
               r(r > 0) = 2 * randg (r(r > 0))
               r(df > 0) += 2 * randg (df(df > 0)/2)

    `Dirichlet (a1, ... ak)'
               r = (randg (a1), ..., randg (ak))
               r = r / sum (r)


     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     See also: *note rand: XREFrand, *note randn: XREFrandn, *note
     rande: XREFrande, *note randp: XREFrandp.


   The generators operate in the new or old style together, it is not
possible to mix the two.  Initializing any generator with "state" or
"seed" causes the others to switch to the same style for future calls.

   The state of each generator is independent and calls to different
generators can be interleaved without affecting the final result.  For
example,

     rand ("state", [11, 22, 33]);
     randn ("state", [44, 55, 66]);
     u = rand (100, 1);
     n = randn (100, 1);

and

     rand ("state", [11, 22, 33]);
     randn ("state", [44, 55, 66]);
     u = zeros (100, 1);
     n = zeros (100, 1);
     for i = 1:100
       u(i) = rand ();
       n(i) = randn ();
     end

produce equivalent results.  When the generators are initialized in the
old style with "seed" only `rand' and `randn' are independent, because
the old `rande', `randg' and `randp' generators make calls to `rand'
and `randn'.

   The generators are initialized with random states at start-up, so
that the sequences of random numbers are not the same each time you run
Octave.(1) If you really do need to reproduce a sequence of numbers
exactly, you can set the state or seed to a specific value.

   If invoked without arguments, `rand' and `randn' return a single
element of a random sequence.

   The original `rand' and `randn' functions use Fortran code from
RANLIB, a library of Fortran routines for random number generation,
compiled by Barry W. Brown and James Lovato of the Department of
Biomathematics at The University of Texas, M.D. Anderson Cancer Center,
Houston, TX 77030.

 -- Built-in Function:  randperm (N)
 -- Built-in Function:  randperm (N, M)
     Return a row vector containing a random permutation of `1:N'.  If
     M is supplied, return M unique entries, sampled without
     replacement from `1:N'.  The complexity is O(N) in memory and O(M)
     in time, unless M < N/5, in which case O(M) memory is used as
     well.  The randomization is performed using rand().  All
     permutations are equally likely.

     See also: *note perms: XREFperms.


   ---------- Footnotes ----------

   (1) The old versions of `rand' and `randn' obtain their initial
seeds from the system clock.


File: octave.info,  Node: Famous Matrices,  Prev: Special Utility Matrices,  Up: Matrix Manipulation

16.4 Famous Matrices
====================

The following functions return famous matrix forms.

 -- Function File:  gallery (NAME)
 -- Function File:  gallery (NAME, ARGS)
     Create interesting matrices for testing.


 -- Function File: C = gallery ("cauchy", X)
 -- Function File: C = gallery ("cauchy", X, Y)
     Create a Cauchy matrix.


 -- Function File: C = gallery ("chebspec", N)
 -- Function File: C = gallery ("chebspec", N, K)
     Create a Chebyshev spectral differentiation matrix.


 -- Function File: C = gallery ("chebvand", P)
 -- Function File: C = gallery ("chebvand", M, P)
     Create a Vandermonde-like matrix for the Chebyshev polynomials.


 -- Function File: A = gallery ("chow", N)
 -- Function File: A = gallery ("chow", N, ALPHA)
 -- Function File: A = gallery ("chow", N, ALPHA, DELTA)
     Create a Chow matrix - a singular Toeplitz lower Hessenberg matrix.


 -- Function File: C = gallery ("circul", V)
     Create a circulant matrix.


 -- Function File: A = gallery ("clement", N)
 -- Function File: A = gallery ("clement", N, K)
     Create a tridiagonal matrix with zero diagonal entries.


 -- Function File: C = gallery ("compar", A)
 -- Function File: C = gallery ("compar", A, K)
     Create a comparison matrix.


 -- Function File: A = gallery ("condex", N)
 -- Function File: A = gallery ("condex", N, K)
 -- Function File: A = gallery ("condex", N, K, THETA)
     Create a `counterexample' matrix to a condition estimator.


 -- Function File: A = gallery ("cycol", [M N])
 -- Function File: A = gallery ("cycol", N)
 -- Function File: A = gallery (..., K)
     Create a matrix whose columns repeat cyclically.


 -- Function File: [C, D, E] = gallery ("dorr", N)
 -- Function File: [C, D, E] = gallery ("dorr", N, THETA)
 -- Function File: A = gallery ("dorr", ...)
     Create a diagonally dominant, ill conditioned, tridiagonal matrix.


 -- Function File: A = gallery ("dramadah", N)
 -- Function File: A = gallery ("dramadah", N, K)
     Create a (0, 1) matrix whose inverse has large integer entries.


 -- Function File: A = gallery ("fiedler", C)
     Create a symmetric Fiedler matrix.


 -- Function File: A = gallery ("forsythe", N)
 -- Function File: A = gallery ("forsythe", N, ALPHA)
 -- Function File: A = gallery ("forsythe", N, ALPHA, LAMBDA)
     Create a Forsythe matrix (a perturbed Jordan block).


 -- Function File: F = gallery ("frank", N)
 -- Function File: F = gallery ("frank", N, K)
     Create a Frank matrix (ill conditioned eigenvalues).


 -- Function File: C = gallery ("gcdmat", N)
     Create a greatest common divisor matrix.

     C is an N-by-N matrix whose values correspond to the greatest
     common divisor of its coordinate values, i.e., C(i,j) correspond
     `gcd (i, j)'.

 -- Function File: A = gallery ("gearmat", N)
 -- Function File: A = gallery ("gearmat", N, I)
 -- Function File: A = gallery ("gearmat", N, I, J)
     Create a Gear matrix.


 -- Function File: G = gallery ("grcar", N)
 -- Function File: G = gallery ("grcar", N, K)
     Create a Toeplitz matrix with sensitive eigenvalues.


 -- Function File: A = gallery ("hanowa", N)
 -- Function File: A = gallery ("hanowa", N, D)
     Create a matrix whose eigenvalues lie on a vertical line in the
     complex plane.


 -- Function File: V = gallery ("house", X)
 -- Function File: [V, BETA] = gallery ("house", X)
     Create a householder matrix.


 -- Function File: A = gallery ("integerdata", IMAX, [M N ...], J)
 -- Function File: A = gallery ("integerdata", IMAX, M, N, ..., J)
 -- Function File: A = gallery ("integerdata", [IMIN, IMAX], [M N ...],
          J)
 -- Function File: A = gallery ("integerdata", [IMIN, IMAX], M, N, ...,
          J)
 -- Function File: A = gallery ("integerdata", ..., "CLASS")
     Create a matrix with random integers in the range [1, IMAX].  If
     IMIN is given then the integers are in the range [IMIN, IMAX].

     The second input is a matrix of dimensions describing the size of
     the output.  The dimensions can also be input as comma-separated
     arguments.

     The input J is an integer index in the range [0, 2^32-1].  The
     values of the output matrix are always exactly the same
     (reproducibility) for a given size input and J index.

     The final optional argument determines the class of the resulting
     matrix.  Possible values for CLASS: "uint8", "uint16", "uint32",
     "int8", "int16", int32", "single", "double".  The default is
     "double".


 -- Function File: A = gallery ("invhess", X)
 -- Function File: A = gallery ("invhess", X, Y)
     Create the inverse of an upper Hessenberg matrix.


 -- Function File: A = gallery ("invol", N)
     Create an involutory matrix.


 -- Function File: A = gallery ("ipjfact", N)
 -- Function File: A = gallery ("ipjfact", N, K)
     Create an Hankel matrix with factorial elements.


 -- Function File: A = gallery ("jordbloc", N)
 -- Function File: A = gallery ("jordbloc", N, LAMBDA)
     Create a Jordan block.


 -- Function File: U = gallery ("kahan", N)
 -- Function File: U = gallery ("kahan", N, THETA)
 -- Function File: U = gallery ("kahan", N, THETA, PERT)
     Create a Kahan matrix (upper trapezoidal).


 -- Function File: A = gallery ("kms", N)
 -- Function File: A = gallery ("kms", N, RHO)
     Create a Kac-Murdock-Szego Toeplitz matrix.


 -- Function File: B = gallery ("krylov", A)
 -- Function File: B = gallery ("krylov", A, X)
 -- Function File: B = gallery ("krylov", A, X, J)
     Create a Krylov matrix.


 -- Function File: A = gallery ("lauchli", N)
 -- Function File: A = gallery ("lauchli", N, MU)
     Create a Lauchli matrix (rectangular).


 -- Function File: A = gallery ("lehmer", N)
     Create a Lehmer matrix (symmetric positive definite).


 -- Function File: T = gallery ("lesp", N)
     Create a tridiagonal matrix with real, sensitive eigenvalues.


 -- Function File: A = gallery ("lotkin", N)
     Create a Lotkin matrix.


 -- Function File: A = gallery ("minij", N)
     Create a symmetric positive definite matrix MIN(i,j).


 -- Function File: A = gallery ("moler", N)
 -- Function File: A = gallery ("moler", N, ALPHA)
     Create a Moler matrix (symmetric positive definite).


 -- Function File: [A, T] = gallery ("neumann", N)
     Create a singular matrix from the discrete Neumann problem
     (sparse).


 -- Function File: A = gallery ("normaldata", [M N ...], J)
 -- Function File: A = gallery ("normaldata", M, N, ..., J)
 -- Function File: A = gallery ("normaldata", ..., "CLASS")
     Create a matrix with random samples from the standard normal
     distribution (mean = 0, std = 1).

     The first input is a matrix of dimensions describing the size of
     the output.  The dimensions can also be input as comma-separated
     arguments.

     The input J is an integer index in the range [0, 2^32-1].  The
     values of the output matrix are always exactly the same
     (reproducibility) for a given size input and J index.

     The final optional argument determines the class of the resulting
     matrix.  Possible values for CLASS: "single", "double".  The
     default is "double".


 -- Function File: Q = gallery ("orthog", N)
 -- Function File: Q = gallery ("orthog", N, K)
     Create orthogonal and nearly orthogonal matrices.


 -- Function File: A = gallery ("parter", N)
     Create a Parter matrix (a Toeplitz matrix with singular values
     near pi).


 -- Function File: P = gallery ("pei", N)
 -- Function File: P = gallery ("pei", N, ALPHA)
     Create a Pei matrix.


 -- Function File: A = gallery ("Poisson", N)
     Create a block tridiagonal matrix from Poisson's equation (sparse).


 -- Function File: A = gallery ("prolate", N)
 -- Function File: A = gallery ("prolate", N, W)
     Create a prolate matrix (symmetric, ill-conditioned Toeplitz
     matrix).


 -- Function File: H = gallery ("randhess", X)
     Create a random, orthogonal upper Hessenberg matrix.


 -- Function File: A = gallery ("rando", N)
 -- Function File: A = gallery ("rando", N, K)
     Create a random matrix with elements -1, 0 or 1.


 -- Function File: A = gallery ("randsvd", N)
 -- Function File: A = gallery ("randsvd", N, KAPPA)
 -- Function File: A = gallery ("randsvd", N, KAPPA, MODE)
 -- Function File: A = gallery ("randsvd", N, KAPPA, MODE, KL)
 -- Function File: A = gallery ("randsvd", N, KAPPA, MODE, KL, KU)
     Create a random matrix with pre-assigned singular values.


 -- Function File: A = gallery ("redheff", N)
     Create a zero and ones matrix of Redheffer associated with the
     Riemann hypothesis.


 -- Function File: A = gallery ("riemann", N)
     Create a matrix associated with the Riemann hypothesis.


 -- Function File: A = gallery ("ris", N)
     Create a symmetric Hankel matrix.


 -- Function File: A = gallery ("smoke", N)
 -- Function File: A = gallery ("smoke", N, K)
     Create a complex matrix, with a `smoke ring' pseudospectrum.


 -- Function File: T = gallery ("toeppd", N)
 -- Function File: T = gallery ("toeppd", N, M)
 -- Function File: T = gallery ("toeppd", N, M, W)
 -- Function File: T = gallery ("toeppd", N, M, W, THETA)
     Create a symmetric positive definite Toeplitz matrix.


 -- Function File: P = gallery ("toeppen", N)
 -- Function File: P = gallery ("toeppen", N, A)
 -- Function File: P = gallery ("toeppen", N, A, B)
 -- Function File: P = gallery ("toeppen", N, A, B, C)
 -- Function File: P = gallery ("toeppen", N, A, B, C, D)
 -- Function File: P = gallery ("toeppen", N, A, B, C, D, E)
     Create a pentadiagonal Toeplitz matrix (sparse).


 -- Function File: A = gallery ("tridiag", X, Y, Z)
 -- Function File: A = gallery ("tridiag", N)
 -- Function File: A = gallery ("tridiag", N, C, D, E)
     Create a tridiagonal matrix (sparse).


 -- Function File: T = gallery ("triw", N)
 -- Function File: T = gallery ("triw", N, ALPHA)
 -- Function File: T = gallery ("triw", N, ALPHA, K)
     Create an upper triangular matrix discussed by Kahan, Golub and
     Wilkinson.


 -- Function File: A = gallery ("uniformdata", [M N ...], J)
 -- Function File: A = gallery ("uniformdata", M, N, ..., J)
 -- Function File: A = gallery ("uniformdata", ..., "CLASS")
     Create a matrix with random samples from the standard uniform
     distribution (range [0,1]).

     The first input is a matrix of dimensions describing the size of
     the output.  The dimensions can also be input as comma-separated
     arguments.

     The input J is an integer index in the range [0, 2^32-1].  The
     values of the output matrix are always exactly the same
     (reproducibility) for a given size input and J index.

     The final optional argument determines the class of the resulting
     matrix.  Possible values for CLASS: "single", "double".  The
     default is "double".


 -- Function File: A = gallery ("wathen", NX, NY)
 -- Function File: A = gallery ("wathen", NX, NY, K)
     Create the Wathen matrix.


 -- Function File: [A, B] = gallery ("wilk", N)
     Create various specific matrices devised/discussed by Wilkinson.


 -- Function File:  hadamard (N)
     Construct a Hadamard matrix (Hn) of size N-by-N.  The size N must
     be of the form 2^k * p in which p is one of 1, 12, 20 or 28.  The
     returned matrix is normalized, meaning `Hn(:,1) == 1' and
     `Hn(1,:) == 1'.

     Some of the properties of Hadamard matrices are:

        * `kron (Hm, Hn)' is a Hadamard matrix of size M-by-N.

        * `Hn * Hn' = N * eye (N)'.

        * The rows of Hn are orthogonal.

        * `det (A) <= abs (det (Hn))' for all A with
          `abs (A(i, j)) <= 1'.

        * Multiplying any row or column by -1 and the matrix will
          remain a Hadamard matrix.

     See also: *note compan: XREFcompan, *note hankel: XREFhankel,
     *note toeplitz: XREFtoeplitz.


 -- Function File:  hankel (C)
 -- Function File:  hankel (C, R)
     Return the Hankel matrix constructed from the first column C, and
     (optionally) the last row R.  If the last element of C is not the
     same as the first element of R, the last element of C is used.  If
     the second argument is omitted, it is assumed to be a vector of
     zeros with the same size as C.

     A Hankel matrix formed from an m-vector C, and an n-vector R, has
     the elements

          H(i,j) = c(i+j-1),  i+j-1 <= m;
          H(i,j) = r(i+j-m),  otherwise

     See also: *note hadamard: XREFhadamard, *note toeplitz:
     XREFtoeplitz.


 -- Function File:  hilb (N)
     Return the Hilbert matrix of order N.  The i,j element of a
     Hilbert matrix is defined as

          H(i, j) = 1 / (i + j - 1)

     Hilbert matrices are close to being singular which make them
     difficult to invert with numerical routines.  Comparing the
     condition number of a random matrix 5x5 matrix with that of a
     Hilbert matrix of order 5 reveals just how difficult the problem
     is.

          cond (rand (5))
             => 14.392
          cond (hilb (5))
             => 4.7661e+05

     See also: *note invhilb: XREFinvhilb.


 -- Function File:  invhilb (N)
     Return the inverse of the Hilbert matrix of order N.  This can be
     computed exactly using


                      (i+j)         /n+i-1\  /n+j-1\   /i+j-2\ 2
           A(i,j) = -1      (i+j-1)(       )(       ) (       )
                                    \ n-j /  \ n-i /   \ i-2 /

                  = p(i) p(j) / (i+j-1)

     where

                       k  /k+n-1\   /n\
              p(k) = -1  (       ) (   )
                          \ k-1 /   \k/

     The validity of this formula can easily be checked by expanding
     the binomial coefficients in both formulas as factorials.  It can
     be derived more directly via the theory of Cauchy matrices.  See
     J. W. Demmel, `Applied Numerical Linear Algebra', p. 92.

     Compare this with the numerical calculation of `inverse (hilb
     (n))', which suffers from the ill-conditioning of the Hilbert
     matrix, and the finite precision of your computer's floating point
     arithmetic.

     See also: *note hilb: XREFhilb.


 -- Function File:  magic (N)
     Create an N-by-N magic square.  A magic square is an arrangement
     of the integers `1:n^2' such that the row sums, column sums, and
     diagonal sums are all equal to the same value.

     Note: N must be greater than 2 for the magic square to exist.

 -- Function File:  pascal (N)
 -- Function File:  pascal (N, T)
     Return the Pascal matrix of order N if `T = 0'.  T defaults to 0.
     Return the pseudo-lower triangular Cholesky factor of the Pascal
     matrix if `T = 1' (The sign of some columns may be negative).
     This matrix is its own inverse, that is `pascal (N, 1) ^ 2 == eye
     (N)'.  If `T = -1', return the true Cholesky factor with strictly
     positive values on the diagonal.  If `T = 2', return a transposed
     and permuted version of `pascal (N, 1)', which is the cube root of
     the identity matrix.  That is, `pascal (N, 2) ^ 3 == eye (N)'.

     See also: *note chol: XREFchol.


 -- Function File:  rosser ()
     Return the Rosser matrix.  This is a difficult test case used to
     evaluate eigenvalue algorithms.

     See also: *note wilkinson: XREFwilkinson, *note eig: XREFeig.


 -- Function File:  toeplitz (C)
 -- Function File:  toeplitz (C, R)
     Return the Toeplitz matrix constructed from the first column C,
     and (optionally) the first row R.  If the first element of R is
     not the same as the first element of C, the first element of C is
     used.  If the second argument is omitted, the first row is taken
     to be the same as the first column.

     A square Toeplitz matrix has the form:

          c(0)  r(1)   r(2)  ...  r(n)
          c(1)  c(0)   r(1)  ... r(n-1)
          c(2)  c(1)   c(0)  ... r(n-2)
           .     .      .   .      .
           .     .      .     .    .
           .     .      .       .  .
          c(n) c(n-1) c(n-2) ...  c(0)

     See also: *note hankel: XREFhankel.


 -- Function File:  vander (C)
 -- Function File:  vander (C, N)
     Return the Vandermonde matrix whose next to last column is C.  If
     N is specified, it determines the number of columns; otherwise, N
     is taken to be equal to the length of C.

     A Vandermonde matrix has the form:

          c(1)^(n-1) ... c(1)^2  c(1)  1
          c(2)^(n-1) ... c(2)^2  c(2)  1
              .     .      .      .    .
              .       .    .      .    .
              .         .  .      .    .
          c(n)^(n-1) ... c(n)^2  c(n)  1

     See also: *note polyfit: XREFpolyfit.


 -- Function File:  wilkinson (N)
     Return the Wilkinson matrix of order N.  Wilkinson matrices are
     symmetric and tridiagonal with pairs of nearly, but not exactly,
     equal eigenvalues.  They are useful in testing the behavior and
     performance of eigenvalue solvers.

     See also: *note rosser: XREFrosser, *note eig: XREFeig.



File: octave.info,  Node: Arithmetic,  Next: Linear Algebra,  Prev: Matrix Manipulation,  Up: Top

17 Arithmetic
*************

Unless otherwise noted, all of the functions described in this chapter
will work for real and complex scalar, vector, or matrix arguments.
Functions described as "mapping functions" apply the given operation
individually to each element when given a matrix argument.  For example:

     sin ([1, 2; 3, 4])
          =>  0.84147   0.90930
              0.14112  -0.75680

* Menu:

* Exponents and Logarithms::
* Complex Arithmetic::
* Trigonometry::
* Sums and Products::
* Utility Functions::
* Special Functions::
* Rational Approximations::
* Coordinate Transformations::
* Mathematical Constants::


File: octave.info,  Node: Exponents and Logarithms,  Next: Complex Arithmetic,  Up: Arithmetic

17.1 Exponents and Logarithms
=============================

 -- Mapping Function:  exp (X)
     Compute `e^x' for each element of X.  To compute the matrix
     exponential, see *note Linear Algebra::.

     See also: *note log: XREFlog.


 -- Mapping Function:  expm1 (X)
     Compute `exp (X) - 1' accurately in the neighborhood of zero.

     See also: *note exp: XREFexp.


 -- Mapping Function:  log (X)
     Compute the natural logarithm, `ln (X)', for each element of X.
     To compute the matrix logarithm, see *note Linear Algebra::.

     See also: *note exp: XREFexp, *note log1p: XREFlog1p, *note log2:
     XREFlog2, *note log10: XREFlog10, *note logspace: XREFlogspace.


 -- Function File:  reallog (X)
     Return the real-valued natural logarithm of each element of X.
     Report an error if any element results in a complex return value.

     See also: *note log: XREFlog, *note realpow: XREFrealpow, *note
     realsqrt: XREFrealsqrt.


 -- Mapping Function:  log1p (X)
     Compute `log (1 + X)' accurately in the neighborhood of zero.

     See also: *note log: XREFlog, *note exp: XREFexp, *note expm1:
     XREFexpm1.


 -- Mapping Function:  log10 (X)
     Compute the base-10 logarithm of each element of X.

     See also: *note log: XREFlog, *note log2: XREFlog2, *note
     logspace: XREFlogspace, *note exp: XREFexp.


 -- Mapping Function:  log2 (X)
 -- Mapping Function: [F, E] = log2 (X)
     Compute the base-2 logarithm of each element of X.

     If called with two output arguments, split X into binary mantissa
     and exponent so that `1/2 <= abs(f) < 1' and E is an integer.  If
     `x = 0', `f = e = 0'.

     See also: *note pow2: XREFpow2, *note log: XREFlog, *note log10:
     XREFlog10, *note exp: XREFexp.


 -- Mapping Function:  pow2 (X)
 -- Mapping Function:  pow2 (F, E)
     With one argument, computes 2 .^ x for each element of X.

     With two arguments, returns f .* (2 .^ e).

     See also: *note log2: XREFlog2, *note nextpow2: XREFnextpow2.


 -- Function File:  nextpow2 (X)
     If X is a scalar, return the first integer N such that 2^n >= abs
     (x).

     If X is a vector, return `nextpow2 (length (X))'.

     See also: *note pow2: XREFpow2, *note log2: XREFlog2.


 -- Function File:  realpow (X, Y)
     Compute the real-valued, element-by-element power operator.  This
     is equivalent to `X .^ Y', except that `realpow' reports an error
     if any return value is complex.

     See also: *note reallog: XREFreallog, *note realsqrt: XREFrealsqrt.


 -- Mapping Function:  sqrt (X)
     Compute the square root of each element of X.  If X is negative, a
     complex result is returned.  To compute the matrix square root, see
     *note Linear Algebra::.

     See also: *note realsqrt: XREFrealsqrt, *note nthroot: XREFnthroot.


 -- Function File:  realsqrt (X)
     Return the real-valued square root of each element of X.  Report an
     error if any element results in a complex return value.

     See also: *note sqrt: XREFsqrt, *note realpow: XREFrealpow, *note
     reallog: XREFreallog.


 -- Mapping Function:  cbrt (X)
     Compute the real cube root of each element of X.  Unlike
     `X^(1/3)', the result will be negative if X is negative.

     See also: *note nthroot: XREFnthroot.


 -- Function File:  nthroot (X, N)
     Compute the n-th root of X, returning real results for real
     components of X.  For example:

          nthroot (-1, 3)
          => -1
          (-1) ^ (1 / 3)
          => 0.50000 - 0.86603i

     X must have all real entries.  N must be a scalar.  If N is an
     even integer and X has negative entries, an error is produced.

     See also: *note realsqrt: XREFrealsqrt, *note sqrt: XREFsqrt,
     *note cbrt: XREFcbrt.



File: octave.info,  Node: Complex Arithmetic,  Next: Trigonometry,  Prev: Exponents and Logarithms,  Up: Arithmetic

17.2 Complex Arithmetic
=======================

In the descriptions of the following functions, Z is the complex number
X + IY, where I is defined as `sqrt (-1)'.

 -- Mapping Function:  abs (Z)
     Compute the magnitude of Z, defined as |Z| = `sqrt (x^2 + y^2)'.

     For example:

          abs (3 + 4i)
               => 5

 -- Mapping Function:  arg (Z)
 -- Mapping Function:  angle (Z)
     Compute the argument of Z, defined as, THETA = `atan2 (Y, X)', in
     radians.

     For example:

          arg (3 + 4i)
               => 0.92730

 -- Mapping Function:  conj (Z)
     Return the complex conjugate of Z, defined as `conj (Z)' = X - IY.

     See also: *note real: XREFreal, *note imag: XREFimag.


 -- Function File:  cplxpair (Z)
 -- Function File:  cplxpair (Z, TOL)
 -- Function File:  cplxpair (Z, TOL, DIM)
     Sort the numbers Z into complex conjugate pairs ordered by
     increasing real part.  Place the negative imaginary complex number
     first within each pair.  Place all the real numbers (those with
     `abs (imag (Z) / Z) < TOL)') after the complex pairs.

     If TOL is unspecified the default value is 100*`eps'.

     By default the complex pairs are sorted along the first
     non-singleton dimension of Z.  If DIM is specified, then the
     complex pairs are sorted along this dimension.

     Signal an error if some complex numbers could not be paired.
     Signal an error if all complex numbers are not exact conjugates
     (to within TOL).  Note that there is no defined order for pairs
     with identical real parts but differing imaginary parts.

          cplxpair (exp(2i*pi*[0:4]'/5)) == exp(2i*pi*[3; 2; 4; 1; 0]/5)

 -- Mapping Function:  imag (Z)
     Return the imaginary part of Z as a real number.

     See also: *note real: XREFreal, *note conj: XREFconj.


 -- Mapping Function:  real (Z)
     Return the real part of Z.

     See also: *note imag: XREFimag, *note conj: XREFconj.



File: octave.info,  Node: Trigonometry,  Next: Sums and Products,  Prev: Complex Arithmetic,  Up: Arithmetic

17.3 Trigonometry
=================

Octave provides the following trigonometric functions where angles are
specified in radians.  To convert from degrees to radians multiply by
`pi/180' (e.g., `sin (30 * pi/180)' returns the sine of 30 degrees).  As
an alternative, Octave provides a number of trigonometric functions
which work directly on an argument specified in degrees.  These
functions are named after the base trigonometric function with a `d'
suffix.  For example, `sin' expects an angle in radians while `sind'
expects an angle in degrees.

   Octave uses the C library trigonometric functions.  It is expected
that these functions are defined by the ISO/IEC 9899 Standard.  This
Standard is available at:
`http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf'.  Section
F.9.1 deals with the trigonometric functions.  The behavior of most of
the functions is relatively straightforward.  However, there are some
exceptions to the standard behavior.  Many of the exceptions involve the
behavior for -0.  The most complex case is atan2.  Octave exactly
implements the behavior given in the Standard.  Including `atan2(+- 0,
0)' returns `+- pi'.

   It should be noted that MATLAB uses different definitions which
apparently do not distinguish -0.

 -- Mapping Function:  sin (X)
     Compute the sine for each element of X in radians.

     See also: *note asin: XREFasin, *note sind: XREFsind, *note sinh:
     XREFsinh.


 -- Mapping Function:  cos (X)
     Compute the cosine for each element of X in radians.

     See also: *note acos: XREFacos, *note cosd: XREFcosd, *note cosh:
     XREFcosh.


 -- Mapping Function:  tan (Z)
     Compute the tangent for each element of X in radians.

     See also: *note atan: XREFatan, *note tand: XREFtand, *note tanh:
     XREFtanh.


 -- Mapping Function:  sec (X)
     Compute the secant for each element of X in radians.

     See also: *note asec: XREFasec, *note secd: XREFsecd, *note sech:
     XREFsech.


 -- Mapping Function:  csc (X)
     Compute the cosecant for each element of X in radians.

     See also: *note acsc: XREFacsc, *note cscd: XREFcscd, *note csch:
     XREFcsch.


 -- Mapping Function:  cot (X)
     Compute the cotangent for each element of X in radians.

     See also: *note acot: XREFacot, *note cotd: XREFcotd, *note coth:
     XREFcoth.


 -- Mapping Function:  asin (X)
     Compute the inverse sine in radians for each element of X.

     See also: *note sin: XREFsin, *note asind: XREFasind.


 -- Mapping Function:  acos (X)
     Compute the inverse cosine in radians for each element of X.

     See also: *note cos: XREFcos, *note acosd: XREFacosd.


 -- Mapping Function:  atan (X)
     Compute the inverse tangent in radians for each element of X.

     See also: *note tan: XREFtan, *note atand: XREFatand.


 -- Mapping Function:  asec (X)
     Compute the inverse secant in radians for each element of X.

     See also: *note sec: XREFsec, *note asecd: XREFasecd.


 -- Mapping Function:  acsc (X)
     Compute the inverse cosecant in radians for each element of X.

     See also: *note csc: XREFcsc, *note acscd: XREFacscd.


 -- Mapping Function:  acot (X)
     Compute the inverse cotangent in radians for each element of X.

     See also: *note cot: XREFcot, *note acotd: XREFacotd.


 -- Mapping Function:  sinh (X)
     Compute the hyperbolic sine for each element of X.

     See also: *note asinh: XREFasinh, *note cosh: XREFcosh, *note
     tanh: XREFtanh.


 -- Mapping Function:  cosh (X)
     Compute the hyperbolic cosine for each element of X.

     See also: *note acosh: XREFacosh, *note sinh: XREFsinh, *note
     tanh: XREFtanh.


 -- Mapping Function:  tanh (X)
     Compute hyperbolic tangent for each element of X.

     See also: *note atanh: XREFatanh, *note sinh: XREFsinh, *note
     cosh: XREFcosh.


 -- Mapping Function:  sech (X)
     Compute the hyperbolic secant of each element of X.

     See also: *note asech: XREFasech.


 -- Mapping Function:  csch (X)
     Compute the hyperbolic cosecant of each element of X.

     See also: *note acsch: XREFacsch.


 -- Mapping Function:  coth (X)
     Compute the hyperbolic cotangent of each element of X.

     See also: *note acoth: XREFacoth.


 -- Mapping Function:  asinh (X)
     Compute the inverse hyperbolic sine for each element of X.

     See also: *note sinh: XREFsinh.


 -- Mapping Function:  acosh (X)
     Compute the inverse hyperbolic cosine for each element of X.

     See also: *note cosh: XREFcosh.


 -- Mapping Function:  atanh (X)
     Compute the inverse hyperbolic tangent for each element of X.

     See also: *note tanh: XREFtanh.


 -- Mapping Function:  asech (X)
     Compute the inverse hyperbolic secant of each element of X.

     See also: *note sech: XREFsech.


 -- Mapping Function:  acsch (X)
     Compute the inverse hyperbolic cosecant of each element of X.

     See also: *note csch: XREFcsch.


 -- Mapping Function:  acoth (X)
     Compute the inverse hyperbolic cotangent of each element of X.

     See also: *note coth: XREFcoth.


 -- Mapping Function:  atan2 (Y, X)
     Compute atan (Y / X) for corresponding elements of Y and X.
     Signal an error if Y and X do not match in size and orientation.

     See also: *note tan: XREFtan, *note tand: XREFtand, *note tanh:
     XREFtanh, *note atanh: XREFatanh.


   Octave provides the following trigonometric functions where angles
are specified in degrees.  These functions produce true zeros at the
appropriate intervals rather than the small round-off error that occurs
when using radians.  For example:

     cosd (90)
          => 0
     cos (pi/2)
          => 6.1230e-17

 -- Function File:  sind (X)
     Compute the sine for each element of X in degrees.  Returns zero
     for elements where `X/180' is an integer.

     See also: *note asind: XREFasind, *note sin: XREFsin.


 -- Function File:  cosd (X)
     Compute the cosine for each element of X in degrees.  Returns zero
     for elements where `(X-90)/180' is an integer.

     See also: *note acosd: XREFacosd, *note cos: XREFcos.


 -- Function File:  tand (X)
     Compute the tangent for each element of X in degrees.  Returns zero
     for elements where `X/180' is an integer and `Inf' for elements
     where `(X-90)/180' is an integer.

     See also: *note atand: XREFatand, *note tan: XREFtan.


 -- Function File:  secd (X)
     Compute the secant for each element of X in degrees.

     See also: *note asecd: XREFasecd, *note sec: XREFsec.


 -- Function File:  cscd (X)
     Compute the cosecant for each element of X in degrees.

     See also: *note acscd: XREFacscd, *note csc: XREFcsc.


 -- Function File:  cotd (X)
     Compute the cotangent for each element of X in degrees.

     See also: *note acotd: XREFacotd, *note cot: XREFcot.


 -- Function File:  asind (X)
     Compute the inverse sine in degrees for each element of X.

     See also: *note sind: XREFsind, *note asin: XREFasin.


 -- Function File:  acosd (X)
     Compute the inverse cosine in degrees for each element of X.

     See also: *note cosd: XREFcosd, *note acos: XREFacos.


 -- Function File:  atand (X)
     Compute the inverse tangent in degrees for each element of X.

     See also: *note tand: XREFtand, *note atan: XREFatan.


 -- Function File:  atan2d (Y, X)
     Compute atan2 (Y / X) in degrees for corresponding elements from Y
     and X.

     See also: *note tand: XREFtand, *note atan2: XREFatan2.


 -- Function File:  asecd (X)
     Compute the inverse secant in degrees for each element of X.

     See also: *note secd: XREFsecd, *note asec: XREFasec.


 -- Function File:  acscd (X)
     Compute the inverse cosecant in degrees for each element of X.

     See also: *note cscd: XREFcscd, *note acsc: XREFacsc.


 -- Function File:  acotd (X)
     Compute the inverse cotangent in degrees for each element of X.

     See also: *note cotd: XREFcotd, *note acot: XREFacot.



File: octave.info,  Node: Sums and Products,  Next: Utility Functions,  Prev: Trigonometry,  Up: Arithmetic

17.4 Sums and Products
======================

 -- Built-in Function:  sum (X)
 -- Built-in Function:  sum (X, DIM)
 -- Built-in Function:  sum (..., "native")
 -- Built-in Function:  sum (..., "double")
 -- Built-in Function:  sum (..., "extra")
     Sum of elements along dimension DIM.  If DIM is omitted, it
     defaults to the first non-singleton dimension.

     If the optional argument "native" is given, then the sum is
     performed in the same type as the original argument, rather than
     in the default double type.  For example:

          sum ([true, true])
             => 2
          sum ([true, true], "native")
             => true

     On the contrary, if "double" is given, the sum is performed in
     double precision even for single precision inputs.

     For double precision inputs, "extra" indicates that a more accurate
     algorithm than straightforward summation is to be used.  For
     single precision inputs, "extra" is the same as "double".
     Otherwise, "extra" has no effect.

     See also: *note cumsum: XREFcumsum, *note sumsq: XREFsumsq, *note
     prod: XREFprod.


 -- Built-in Function:  prod (X)
 -- Built-in Function:  prod (X, DIM)
     Product of elements along dimension DIM.  If DIM is omitted, it
     defaults to the first non-singleton dimension.

     See also: *note cumprod: XREFcumprod, *note sum: XREFsum.


 -- Built-in Function:  cumsum (X)
 -- Built-in Function:  cumsum (X, DIM)
 -- Built-in Function:  cumsum (..., "native")
 -- Built-in Function:  cumsum (..., "double")
 -- Built-in Function:  cumsum (..., "extra")
     Cumulative sum of elements along dimension DIM.  If DIM is
     omitted, it defaults to the first non-singleton dimension.

     See `sum' for an explanation of the optional parameters "native",
     "double", and "extra".

     See also: *note sum: XREFsum, *note cumprod: XREFcumprod.


 -- Built-in Function:  cumprod (X)
 -- Built-in Function:  cumprod (X, DIM)
     Cumulative product of elements along dimension DIM.  If DIM is
     omitted, it defaults to the first non-singleton dimension.

     See also: *note prod: XREFprod, *note cumsum: XREFcumsum.


 -- Built-in Function:  sumsq (X)
 -- Built-in Function:  sumsq (X, DIM)
     Sum of squares of elements along dimension DIM.  If DIM is
     omitted, it defaults to the first non-singleton dimension.

     This function is conceptually equivalent to computing

          sum (x .* conj (x), dim)

     but it uses less memory and avoids calling `conj' if X is real.

     See also: *note sum: XREFsum, *note prod: XREFprod.



File: octave.info,  Node: Utility Functions,  Next: Special Functions,  Prev: Sums and Products,  Up: Arithmetic

17.5 Utility Functions
======================

 -- Mapping Function:  ceil (X)
     Return the smallest integer not less than X.  This is equivalent to
     rounding towards positive infinity.  If X is complex, return `ceil
     (real (X)) + ceil (imag (X)) * I'.

          ceil ([-2.7, 2.7])
              => -2    3

     See also: *note floor: XREFfloor, *note round: XREFround, *note
     fix: XREFfix.


 -- Mapping Function:  fix (X)
     Truncate fractional portion of X and return the integer portion.
     This is equivalent to rounding towards zero.  If X is complex,
     return `fix (real (X)) + fix (imag (X)) * I'.

          fix ([-2.7, 2.7])
             => -2    2

     See also: *note ceil: XREFceil, *note floor: XREFfloor, *note
     round: XREFround.


 -- Mapping Function:  floor (X)
     Return the largest integer not greater than X.  This is equivalent
     to rounding towards negative infinity.  If X is complex, return
     `floor (real (X)) + floor (imag (X)) * I'.

          floor ([-2.7, 2.7])
               => -3    2

     See also: *note ceil: XREFceil, *note round: XREFround, *note fix:
     XREFfix.


 -- Mapping Function:  round (X)
     Return the integer nearest to X.  If X is complex, return `round
     (real (X)) + round (imag (X)) * I'.  If there are two nearest
     integers, return the one further away from zero.

          round ([-2.7, 2.7])
               => -3    3

     See also: *note ceil: XREFceil, *note floor: XREFfloor, *note fix:
     XREFfix, *note roundb: XREFroundb.


 -- Mapping Function:  roundb (X)
     Return the integer nearest to X.  If there are two nearest
     integers, return the even one (banker's rounding).  If X is
     complex, return `roundb (real (X)) + roundb (imag (X)) * I'.

     See also: *note round: XREFround.


 -- Built-in Function:  max (X)
 -- Built-in Function:  max (X, Y)
 -- Built-in Function:  max (X, [], DIM)
 -- Built-in Function:  max (X, Y, DIM)
 -- Built-in Function: [W, IW] = max (X)
     For a vector argument, return the maximum value.  For a matrix
     argument, return the maximum value from each column, as a row
     vector, or over the dimension DIM if defined, in which case Y
     should be set to the empty matrix (it's ignored otherwise).  For
     two matrices (or a matrix and scalar), return the pair-wise
     maximum.  Thus,

          max (max (X))

     returns the largest element of the matrix X, and

          max (2:5, pi)
              =>  3.1416  3.1416  4.0000  5.0000

     compares each element of the range `2:5' with `pi', and returns a
     row vector of the maximum values.

     For complex arguments, the magnitude of the elements are used for
     comparison.

     If called with one input and two output arguments, `max' also
     returns the first index of the maximum value(s).  Thus,

          [x, ix] = max ([1, 3, 5, 2, 5])
              =>  x = 5
                  ix = 3

     See also: *note min: XREFmin, *note cummax: XREFcummax, *note
     cummin: XREFcummin.


 -- Built-in Function:  min (X)
 -- Built-in Function:  min (X, Y)
 -- Built-in Function:  min (X, [], DIM)
 -- Built-in Function:  min (X, Y, DIM)
 -- Built-in Function: [W, IW] = min (X)
     For a vector argument, return the minimum value.  For a matrix
     argument, return the minimum value from each column, as a row
     vector, or over the dimension DIM if defined, in which case Y
     should be set to the empty matrix (it's ignored otherwise).  For
     two matrices (or a matrix and scalar), return the pair-wise
     minimum.  Thus,

          min (min (X))

     returns the smallest element of X, and

          min (2:5, pi)
              =>  2.0000  3.0000  3.1416  3.1416

     compares each element of the range `2:5' with `pi', and returns a
     row vector of the minimum values.

     For complex arguments, the magnitude of the elements are used for
     comparison.

     If called with one input and two output arguments, `min' also
     returns the first index of the minimum value(s).  Thus,

          [x, ix] = min ([1, 3, 0, 2, 0])
              =>  x = 0
                  ix = 3

     See also: *note max: XREFmax, *note cummin: XREFcummin, *note
     cummax: XREFcummax.


 -- Built-in Function:  cummax (X)
 -- Built-in Function:  cummax (X, DIM)
 -- Built-in Function: [W, IW] = cummax (X)
     Return the cumulative maximum values along dimension DIM.  If DIM
     is unspecified it defaults to column-wise operation.  For example:

          cummax ([1 3 2 6 4 5])
             =>  1  3  3  6  6  6

     The call

          [w, iw] = cummax (x, dim)

     with `x' a vector, is equivalent to the following code:

          w = iw = zeros (size (x));
          for i = 1:length (x)
            [w(i), iw(i)] = max (x(1:i));
          endfor

     but computed in a much faster manner.

     See also: *note cummin: XREFcummin, *note max: XREFmax, *note min:
     XREFmin.


 -- Built-in Function:  cummin (X)
 -- Built-in Function:  cummin (X, DIM)
 -- Built-in Function: [W, IW] = cummin (X)
     Return the cumulative minimum values along dimension DIM.  If DIM
     is unspecified it defaults to column-wise operation.  For example:

          cummin ([5 4 6 2 3 1])
             =>  5  4  4  2  2  1

     The call

            [w, iw] = cummin (x)

     with `x' a vector, is equivalent to the following code:

          w = iw = zeros (size (x));
          for i = 1:length (x)
            [w(i), iw(i)] = max (x(1:i));
          endfor

     but computed in a much faster manner.

     See also: *note cummax: XREFcummax, *note min: XREFmin, *note max:
     XREFmax.


 -- Built-in Function:  hypot (X, Y)
 -- Built-in Function:  hypot (X, Y, Z, ...)
     Compute the element-by-element square root of the sum of the
     squares of X and Y.  This is equivalent to `sqrt (X.^2 + Y.^2)',
     but calculated in a manner that avoids overflows for large values
     of X or Y.  `hypot' can also be called with more than 2 arguments;
     in this case, the arguments are accumulated from left to right:

          hypot (hypot (X, Y), Z)
          hypot (hypot (hypot (X, Y), Z), W), etc.

 -- Function File: DX = gradient (M)
 -- Function File: [DX, DY, DZ, ...] = gradient (M)
 -- Function File: [...] = gradient (M, S)
 -- Function File: [...] = gradient (M, X, Y, Z, ...)
 -- Function File: [...] = gradient (F, X0)
 -- Function File: [...] = gradient (F, X0, S)
 -- Function File: [...] = gradient (F, X0, X, Y, ...)
     Calculate the gradient of sampled data or a function.  If M is a
     vector, calculate the one-dimensional gradient of M.  If M is a
     matrix the gradient is calculated for each dimension.

     `[DX, DY] = gradient (M)' calculates the one dimensional gradient
     for X and Y direction if M is a matrix.  Additional return
     arguments can be use for multi-dimensional matrices.

     A constant spacing between two points can be provided by the S
     parameter.  If S is a scalar, it is assumed to be the spacing for
     all dimensions.  Otherwise, separate values of the spacing can be
     supplied by the X, ... arguments.  Scalar values specify an
     equidistant spacing.  Vector values for the X, ... arguments
     specify the coordinate for that dimension.  The length must match
     their respective dimension of M.

     At boundary points a linear extrapolation is applied.  Interior
     points are calculated with the first approximation of the
     numerical gradient

          y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).

     If the first argument F is a function handle, the gradient of the
     function at the points in X0 is approximated using central
     difference.  For example, `gradient (@cos, 0)' approximates the
     gradient of the cosine function in the point x0 = 0.  As with
     sampled data, the spacing values between the points from which the
     gradient is estimated can be set via the S or DX, DY, ...
     arguments.  By default a spacing of 1 is used.

     See also: *note diff: XREFdiff, *note del2: XREFdel2.


 -- Built-in Function:  dot (X, Y, DIM)
     Compute the dot product of two vectors.  If X and Y are matrices,
     calculate the dot products along the first non-singleton
     dimension.  If the optional argument DIM is given, calculate the
     dot products along this dimension.

     This is equivalent to `sum (conj (X) .* Y, DIM)', but avoids
     forming a temporary array and is faster.  When X and Y are column
     vectors, the result is equivalent to `X' * Y'.

     See also: *note cross: XREFcross, *note divergence: XREFdivergence.


 -- Function File:  cross (X, Y)
 -- Function File:  cross (X, Y, DIM)
     Compute the vector cross product of two 3-dimensional vectors X
     and Y.

          cross ([1,1,0], [0,1,1])
               => [ 1; -1; 1 ]

     If X and Y are matrices, the cross product is applied along the
     first dimension with 3 elements.  The optional argument DIM forces
     the cross product to be calculated along the specified dimension.

     See also: *note dot: XREFdot, *note curl: XREFcurl, *note
     divergence: XREFdivergence.


 -- Function File: DIV = divergence (X, Y, Z, FX, FY, FZ)
 -- Function File: DIV = divergence (FX, FY, FZ)
 -- Function File: DIV = divergence (X, Y, FX, FY)
 -- Function File: DIV = divergence (FX, FY)
     Calculate divergence of a vector field given by the arrays FX, FY,
     and FZ or FX, FY respectively.

                            d               d               d
          div F(x,y,z)  =   -- F(x,y,z)  +  -- F(x,y,z)  +  -- F(x,y,z)
                            dx              dy              dz

     The coordinates of the vector field can be given by the arguments
     X, Y, Z or X, Y respectively.

     See also: *note curl: XREFcurl, *note gradient: XREFgradient,
     *note del2: XREFdel2, *note dot: XREFdot.


 -- Function File: [CX, CY, CZ, V] = curl (X, Y, Z, FX, FY, FZ)
 -- Function File: [CZ, V] = curl (X, Y, FX, FY)
 -- Function File: [...] = curl (FX, FY, FZ)
 -- Function File: [...] = curl (FX, FY)
 -- Function File: V = curl (...)
     Calculate curl of vector field given by the arrays FX, FY, and FZ
     or FX, FY respectively.

                            / d         d       d         d       d         d     \
          curl F(x,y,z)  =  | -- Fz  -  -- Fy,  -- Fx  -  -- Fz,  -- Fy  -  -- Fx |
                            \ dy        dz      dz        dx      dx        dy    /

     The coordinates of the vector field can be given by the arguments
     X, Y, Z or X, Y respectively.  V calculates the scalar component
     of the angular velocity vector in direction of the z-axis for
     two-dimensional input.  For three-dimensional input the scalar
     rotation is calculated at each grid point in direction of the
     vector field at that point.

     See also: *note divergence: XREFdivergence, *note gradient:
     XREFgradient, *note del2: XREFdel2, *note cross: XREFcross.


 -- Function File: D = del2 (M)
 -- Function File: D = del2 (M, H)
 -- Function File: D = del2 (M, DX, DY, ...)
     Calculate the discrete Laplace operator.  For a 2-dimensional
     matrix M this is defined as

                1    / d^2            d^2         \
          D  = --- * | ---  M(x,y) +  ---  M(x,y) |
                4    \ dx^2           dy^2        /

     For N-dimensional arrays the sum in parentheses is expanded to
     include second derivatives over the additional higher dimensions.

     The spacing between evaluation points may be defined by H, which
     is a scalar defining the equidistant spacing in all dimensions.
     Alternatively, the spacing in each dimension may be defined
     separately by DX, DY, etc.  A scalar spacing argument defines
     equidistant spacing, whereas a vector argument can be used to
     specify variable spacing.  The length of the spacing vectors must
     match the respective dimension of M.  The default spacing value is
     1.

     At least 3 data points are needed for each dimension.  Boundary
     points are calculated from the linear extrapolation of interior
     points.

     See also: *note gradient: XREFgradient, *note diff: XREFdiff.


 -- Function File:  factorial (N)
     Return the factorial of N where N is a positive integer.  If N is
     a scalar, this is equivalent to `prod (1:N)'.  For vector or
     matrix arguments, return the factorial of each element in the
     array.  For non-integers see the generalized factorial function
     `gamma'.

     See also: *note prod: XREFprod, *note gamma: XREFgamma.


 -- Function File: P = factor (Q)
 -- Function File: [P, N] = factor (Q)
     Return prime factorization of Q.  That is, `prod (P) == Q' and
     every element of P is a prime number.  If `Q == 1', return 1.

     With two output arguments, return the unique primes P and their
     multiplicities.  That is, `prod (P .^ N) == Q'.

     See also: *note gcd: XREFgcd, *note lcm: XREFlcm.


 -- Built-in Function: G = gcd (A1, A2, ...)
 -- Built-in Function: [G, V1, ...] = gcd (A1, A2, ...)
     Compute the greatest common divisor of A1, A2, ....  If more than
     one argument is given all arguments must be the same size or
     scalar.  In this case the greatest common divisor is calculated
     for each element individually.  All elements must be ordinary or
     Gaussian (complex) integers.  Note that for Gaussian integers, the
     gcd is not unique up to units (multiplication by 1, -1, I or -I),
     so an arbitrary greatest common divisor amongst four possible is
     returned.

     Example code:

          gcd ([15, 9], [20, 18])
             =>  5  9

     Optional return arguments V1, etc., contain integer vectors such
     that,

          G = V1 .* A1 + V2 .* A2 + ...

     See also: *note lcm: XREFlcm, *note factor: XREFfactor.


 -- Mapping Function:  lcm (X, Y)
 -- Mapping Function:  lcm (X, Y, ...)
     Compute the least common multiple of X and Y, or of the list of
     all arguments.  All elements must be the same size or scalar.

     See also: *note factor: XREFfactor, *note gcd: XREFgcd.


 -- Function File:  chop (X, NDIGITS, BASE)
     Truncate elements of X to a length of NDIGITS such that the
     resulting numbers are exactly divisible by BASE.  If BASE is not
     specified it defaults to 10.

          chop (-pi, 5, 10)
             => -3.14200000000000
          chop (-pi, 5, 5)
             => -3.14150000000000

 -- Mapping Function:  rem (X, Y)
 -- Mapping Function:  fmod (X, Y)
     Return the remainder of the division `X / Y', computed using the
     expression

          x - y .* fix (x ./ y)

     An error message is printed if the dimensions of the arguments do
     not agree, or if either of the arguments is complex.

     See also: *note mod: XREFmod.


 -- Mapping Function:  mod (X, Y)
     Compute the modulo of X and Y.  Conceptually this is given by

          x - y .* floor (x ./ y)

     and is written such that the correct modulus is returned for
     integer types.  This function handles negative values correctly.
     That is, `mod (-1, 3)' is 2, not -1, as `rem (-1, 3)' returns.
     `mod (X, 0)' returns X.

     An error results if the dimensions of the arguments do not agree,
     or if either of the arguments is complex.

     See also: *note rem: XREFrem.


 -- Function File:  primes (N)
     Return all primes up to N.

     The algorithm used is the Sieve of Eratosthenes.

     Note that if you need a specific number of primes you can use the
     fact that the distance from one prime to the next is, on average,
     proportional to the logarithm of the prime.  Integrating, one finds
     that there are about k primes less than k*log (5*k).

     See also: *note list_primes: XREFlist_primes, *note isprime:
     XREFisprime.


 -- Function File:  list_primes ()
 -- Function File:  list_primes (N)
     List the first N primes.  If N is unspecified, the first 25 primes
     are listed.

     The algorithm used is from page 218 of the TeXbook.

     See also: *note primes: XREFprimes, *note isprime: XREFisprime.


 -- Mapping Function:  sign (X)
     Compute the "signum" function, which is defined as

                     -1, x < 0;
          sign (x) =  0, x = 0;
                      1, x > 0.

     For complex arguments, `sign' returns `x ./ abs (X)'.

     Note that `sign (-0.0)' is 0.  Although IEEE 754 floating point
     allows zero to be signed, 0.0 and -0.0 compare equal.  If you must
     test whether zero is signed, use the `signbit' function.

     See also: *note signbit: XREFsignbit.


 -- Mapping Function:  signbit (X)
     Return logical true if the value of X has its sign bit set.
     Otherwise return logical false.  This behavior is consistent with
     the other logical functions.  See*note Logical Values::.  The
     behavior differs from the C language function which returns
     non-zero if the sign bit is set.

     This is not the same as `x < 0.0', because IEEE 754 floating point
     allows zero to be signed.  The comparison `-0.0 < 0.0' is false,
     but `signbit (-0.0)' will return a nonzero value.

     See also: *note sign: XREFsign.



File: octave.info,  Node: Special Functions,  Next: Rational Approximations,  Prev: Utility Functions,  Up: Arithmetic

17.6 Special Functions
======================

 -- Built-in Function: [A, IERR] = airy (K, Z, OPT)
     Compute Airy functions of the first and second kind, and their
     derivatives.

           K   Function   Scale factor (if 'opt' is supplied)
          ---  --------   ---------------------------------------
           0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
           1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
           2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))
           3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))

     The function call `airy (Z)' is equivalent to `airy (0, Z)'.

     The result is the same size as Z.

     If requested, IERR contains the following status information and
     is the same size as the result.

       0. Normal return.

       1. Input error, return `NaN'.

       2. Overflow, return `Inf'.

       3. Loss of significance by argument reduction results in less
          than half  of machine accuracy.

       4. Complete loss of significance by argument reduction, return
          `NaN'.

       5. Error--no computation, algorithm termination condition not
          met, return `NaN'.

 -- Built-in Function: [J, IERR] = besselj (ALPHA, X, OPT)
 -- Built-in Function: [Y, IERR] = bessely (ALPHA, X, OPT)
 -- Built-in Function: [I, IERR] = besseli (ALPHA, X, OPT)
 -- Built-in Function: [K, IERR] = besselk (ALPHA, X, OPT)
 -- Built-in Function: [H, IERR] = besselh (ALPHA, K, X, OPT)
     Compute Bessel or Hankel functions of various kinds:

    `besselj'
          Bessel functions of the first kind.  If the argument OPT is
          supplied, the result is multiplied by `exp (-abs (imag (X)))'.

    `bessely'
          Bessel functions of the second kind.  If the argument OPT is
          supplied, the result is multiplied by `exp (-abs (imag (X)))'.

    `besseli'
          Modified Bessel functions of the first kind.  If the argument
          OPT is supplied, the result is multiplied by `exp (-abs (real
          (X)))'.

    `besselk'
          Modified Bessel functions of the second kind.  If the
          argument OPT is supplied, the result is multiplied by `exp
          (X)'.

    `besselh'
          Compute Hankel functions of the first (K = 1) or second (K =
          2) kind.  If the argument OPT is supplied, the result is
          multiplied by `exp (-I*X)' for K = 1 or `exp (I*X)' for K = 2.

     If ALPHA is a scalar, the result is the same size as X.  If X is a
     scalar, the result is the same size as ALPHA.  If ALPHA is a row
     vector and X is a column vector, the result is a matrix with
     `length (X)' rows and `length (ALPHA)' columns.  Otherwise, ALPHA
     and X must conform and the result will be the same size.

     The value of ALPHA must be real.  The value of X may be complex.

     If requested, IERR contains the following status information and
     is the same size as the result.

       0. Normal return.

       1. Input error, return `NaN'.

       2. Overflow, return `Inf'.

       3. Loss of significance by argument reduction results in less
          than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return
          `NaN'.

       5. Error--no computation, algorithm termination condition not
          met, return `NaN'.

 -- Mapping Function:  beta (A, B)
     For real inputs, return the Beta function,

          beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).

     See also: *note betaln: XREFbetaln, *note betainc: XREFbetainc.


 -- Mapping Function:  betainc (X, A, B)
     Return the regularized incomplete Beta function,

                                             x
                                    1       /
          betainc (x, a, b) = -----------   | t^(a-1) (1-t)^(b-1) dt.
                              beta (a, b)   /
                                         t=0

     If X has more than one component, both A and B must be scalars.
     If X is a scalar, A and B must be of compatible dimensions.

     See also: *note betaincinv: XREFbetaincinv, *note beta: XREFbeta,
     *note betaln: XREFbetaln.


 -- Mapping Function:  betaincinv (Y, A, B)
     Compute the inverse of the incomplete Beta function, i.e., X such
     that

          Y == betainc (X, A, B)

     See also: *note betainc: XREFbetainc, *note beta: XREFbeta, *note
     betaln: XREFbetaln.


 -- Mapping Function:  betaln (A, B)
     Return the natural logarithm of the Beta function,

          betaln (a, b) = log (beta (a, b))

     calculated in a way to reduce the occurrence of underflow.

     See also: *note beta: XREFbeta, *note betainc: XREFbetainc, *note
     gammaln: XREFgammaln.


 -- Mapping Function:  bincoeff (N, K)
     Return the binomial coefficient of N and K, defined as

           /   \
           | n |    n (n-1) (n-2) ... (n-k+1)
           |   |  = -------------------------
           | k |               k!
           \   /

     For example:

          bincoeff (5, 2)
             => 10

     In most cases, the `nchoosek' function is faster for small scalar
     integer arguments.  It also warns about loss of precision for big
     arguments.

     See also: *note nchoosek: XREFnchoosek.


 -- Function File:  commutation_matrix (M, N)
     Return the commutation matrix  K(m,n)  which is the unique M*N by
     M*N  matrix such that K(m,n) * vec(A) = vec(A')  for all m by n
     matrices A.

     If only one argument M is given, K(m,m)  is returned.

     See Magnus and Neudecker (1988), `Matrix Differential Calculus with
     Applications in Statistics and Econometrics.'

 -- Function File:  duplication_matrix (N)
     Return the duplication matrix Dn  which is the unique n^2 by
     n*(n+1)/2  matrix such that Dn vech (A) = vec (A)  for all
     symmetric n by n  matrices A.

     See Magnus and Neudecker (1988), Matrix differential calculus with
     applications in statistics and econometrics.

 -- Mapping Function:  dawson (Z)
     Compute the Dawson (scaled imaginary error) function,

          (sqrt (pi) / 2) * exp (-z^2) * erfi (z)

     See also: *note erfc: XREFerfc, *note erf: XREFerf, *note erfcx:
     XREFerfcx, *note erfi: XREFerfi, *note erfinv: XREFerfinv, *note
     erfcinv: XREFerfcinv.


 -- Built-in Function: [SN, CN, DN, ERR] = ellipj (U, M)
 -- Built-in Function: [SN, CN, DN, ERR] = ellipj (U, M, TOL)
     Compute the Jacobi elliptic functions SN, CN, and DN of complex
     argument U and real parameter M.

     If M is a scalar, the results are the same size as U.  If U is a
     scalar, the results are the same size as M.  If U is a column
     vector and M is a row vector, the results are matrices with
     `length (U)' rows and `length (M)' columns.  Otherwise, U and M
     must conform and the results will be the same size.

     The value of U may be complex.  The value of M must be 0 <= m <= 1.

     TOL is currently ignored (MATLAB uses this to allow faster, less
     accurate approximation).

     If requested, ERR contains the following status information and is
     the same size as the result.

       0. Normal return.

       1. Error--no computation, algorithm termination condition not
          met, return `NaN'.
           Ref: Abramowitz, Milton and Stegun, Irene A       Handbook
     of Mathematical Functions, Dover, 1965       Chapter 16 (Sections
     16.4, 16.13 and 16.15)

     See also: *note ellipke: XREFellipke.


 -- Function File:  ellipke (M)
 -- Function File:  ellipke (M, TOL)
 -- Function File: [K, E] = ellipke (...)
     Compute complete elliptic integral of the first K(M) and second
     E(M) kind.

     M is either real array or scalar with 0 <= m <= 1.

     TOL is currently ignored (MATLAB uses this to allow faster, less
     accurate approximation).

     Ref: Abramowitz, Milton and Stegun, Irene A. Handbook of
     Mathematical Functions, Dover, 1965, Chapter 17.

     See also: *note ellipj: XREFellipj.


 -- Mapping Function:  erf (Z)
     Compute the error function,

                                  z
                        2        /
          erf (z) = --------- *  | e^(-t^2) dt
                    sqrt (pi)    /
                              t=0

     See also: *note erfc: XREFerfc, *note erfcx: XREFerfcx, *note
     erfi: XREFerfi, *note dawson: XREFdawson, *note erfinv:
     XREFerfinv, *note erfcinv: XREFerfcinv.


 -- Mapping Function:  erfc (Z)
     Compute the complementary error function, `1 - erf (Z)'.

     See also: *note erfcinv: XREFerfcinv, *note erfcx: XREFerfcx,
     *note erfi: XREFerfi, *note dawson: XREFdawson, *note erf:
     XREFerf, *note erfinv: XREFerfinv.


 -- Mapping Function:  erfcx (Z)
     Compute the scaled complementary error function,

          exp (z^2) * erfc (z)

     See also: *note erfc: XREFerfc, *note erf: XREFerf, *note erfi:
     XREFerfi, *note dawson: XREFdawson, *note erfinv: XREFerfinv,
     *note erfcinv: XREFerfcinv.


 -- Mapping Function:  erfi (Z)
     Compute the imaginary error function,

          -i * erf (i*z)

     See also: *note erfc: XREFerfc, *note erf: XREFerf, *note erfcx:
     XREFerfcx, *note dawson: XREFdawson, *note erfinv: XREFerfinv,
     *note erfcinv: XREFerfcinv.


 -- Mapping Function:  erfinv (X)
     Compute the inverse error function, i.e., Y such that

          erf (Y) == X

     See also: *note erf: XREFerf, *note erfc: XREFerfc, *note erfcx:
     XREFerfcx, *note erfi: XREFerfi, *note dawson: XREFdawson, *note
     erfcinv: XREFerfcinv.


 -- Mapping Function:  erfcinv (X)
     Compute the inverse complementary error function, i.e., Y such that

          erfc (Y) == X

     See also: *note erfc: XREFerfc, *note erf: XREFerf, *note erfcx:
     XREFerfcx, *note erfi: XREFerfi, *note dawson: XREFdawson, *note
     erfinv: XREFerfinv.


 -- Function File:  expint (X)
     Compute the exponential integral,

                        infinity
                       /
          expint (x) = | exp (-t)/t dt
                       /
                      x


 -- Mapping Function:  gamma (Z)
     Compute the Gamma function,

                       infinity
                      /
          gamma (z) = | t^(z-1) exp (-t) dt.
                      /
                   t=0

     See also: *note gammainc: XREFgammainc, *note lgamma: XREFlgamma.


 -- Mapping Function:  gammainc (X, A)
 -- Mapping Function:  gammainc (X, A, "lower")
 -- Mapping Function:  gammainc (X, A, "upper")
     Compute the normalized incomplete gamma function,

                                          x
                                 1       /
          gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                            gamma (a)    /
                                      t=0

     with the limiting value of 1 as X approaches infinity.  The
     standard notation is P(a,x), e.g., Abramowitz and Stegun (6.5.1).

     If A is scalar, then `gammainc (X, A)' is returned for each
     element of X and vice versa.

     If neither X nor A is scalar, the sizes of X and A must agree, and
     `gammainc' is applied element-by-element.

     By default the incomplete gamma function integrated from 0 to X is
     computed.  If "upper" is given then the complementary function
     integrated from X to infinity is calculated.  It should be noted
     that

          gammainc (X, A) == 1 - gammainc (X, A, "upper")

     See also: *note gamma: XREFgamma, *note lgamma: XREFlgamma.


 -- Function File: L = legendre (N, X)
 -- Function File: L = legendre (N, X, NORMALIZATION)
     Compute the Legendre function of degree N and order M = 0 ... N.
     The optional argument, NORMALIZATION, may be one of "unnorm",
     "sch", or "norm".  The default is "unnorm".  The value of N must
     be a non-negative scalar integer.

     If the optional argument NORMALIZATION is missing or is "unnorm",
     compute the Legendre function of degree N and order M and return
     all values for M = 0 ... N.  The return value has one dimension
     more than X.

     The Legendre Function of degree N and order M:

           m        m       2  m/2   d^m
          P(x) = (-1) * (1-x  )    * ----  P(x)
           n                         dx^m   n

     with Legendre polynomial of degree N:

                    1    d^n   2    n
          P(x) = ------ [----(x - 1) ]
           n     2^n n!  dx^n

     `legendre (3, [-1.0, -0.9, -0.8])' returns the matrix:

           x  |   -1.0   |   -0.9   |   -0.8
          ------------------------------------
          m=0 | -1.00000 | -0.47250 | -0.08000
          m=1 |  0.00000 | -1.99420 | -1.98000
          m=2 |  0.00000 | -2.56500 | -4.32000
          m=3 |  0.00000 | -1.24229 | -3.24000

     If the optional argument `normalization' is "sch", compute the
     Schmidt semi-normalized associated Legendre function.  The Schmidt
     semi-normalized associated Legendre function is related to the
     unnormalized Legendre functions by the following:

     For Legendre functions of degree n and order 0:

            0      0
          SP(x) = P(x)
            n      n

     For Legendre functions of degree n and order m:

            m      m         m    2(n-m)! 0.5
          SP(x) = P(x) * (-1)  * [-------]
            n      n              (n+m)!

     If the optional argument NORMALIZATION is "norm", compute the
     fully normalized associated Legendre function.  The fully
     normalized associated Legendre function is related to the
     unnormalized Legendre functions by the following:

     For Legendre functions of degree N and order M

            m      m         m    (n+0.5)(n-m)! 0.5
          NP(x) = P(x) * (-1)  * [-------------]
            n      n                  (n+m)!


 -- Mapping Function:  lgamma (X)
 -- Mapping Function:  gammaln (X)
     Return the natural logarithm of the gamma function of X.

     See also: *note gamma: XREFgamma, *note gammainc: XREFgammainc.


