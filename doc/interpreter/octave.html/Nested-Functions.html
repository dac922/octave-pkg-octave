<html lang="en">
<head>
<title>Nested Functions - GNU Octave</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Octave">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Function-Files.html#Function-Files" title="Function Files">
<link rel="prev" href="Private-Functions.html#Private-Functions" title="Private Functions">
<link rel="next" href="Overloading-and-Autoloading.html#Overloading-and-Autoloading" title="Overloading and Autoloading">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Nested-Functions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Overloading-and-Autoloading.html#Overloading-and-Autoloading">Overloading and Autoloading</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Private-Functions.html#Private-Functions">Private Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Function-Files.html#Function-Files">Function Files</a>
<hr>
</div>

<h4 class="subsection">11.9.4 Nested Functions</h4>

<p>Nested functions are similar to subfunctions in that only the main function is
visible outside the file.  However, they also allow for child functions to
access the local variables in their parent function.  This shared access mimics
using a global variable to share information &mdash; but a global variable which is
not visible to the rest of Octave.  As a programming strategy, sharing data
this way can create code which is difficult to maintain.  It is recommended to
use subfunctions in place of nested functions when possible.

   <p>As a simple example, consider a parent function <code>foo</code>, that calls a nested
child function <code>bar</code>, with a shared variable <var>x</var>.

<pre class="example">     function y = foo ()
       x = 10;
       bar ();
       y = x;
     
       function bar ()
         x = 20;
       endfunction
     endfunction
     
     foo ()
      &rArr; 20
</pre>
   <p class="noindent">Notice that there is no special syntax for sharing <var>x</var>.  This can lead to
problems with accidental variable sharing between a parent function and its
child.  While normally variables are inherited, child function parameters and
return values are local to the child function.

   <p>Now consider the function <code>foobar</code> that uses variables <var>x</var> and
<var>y</var>.  <code>foobar</code> calls a nested function <code>foo</code> which takes
<var>x</var> as a parameter and returns <var>y</var>.  <code>foo</code> then calls <code>bat</code>
which does some computation.

<pre class="example">     function z = foobar ()
       x = 0;
       y = 0;
       z = foo (5);
       z += x + y;
     
       function y = foo (x)
         y = x + bat ();
     
         function z = bat ()
           z = x;
         endfunction
       endfunction
     endfunction
     
     foobar ()
         &rArr; 10
</pre>
   <p class="noindent">It is important to note that the <var>x</var> and <var>y</var> in <code>foobar</code> remain
zero, as in <code>foo</code> they are a return value and parameter respectively.  The
<var>x</var> in <code>bat</code> refers to the <var>x</var> in <code>foo</code>.

   <p>Variable inheritance leads to a problem for <code>eval</code> and scripts.  If a
new variable is created in a parent function, it is not clear what should happen
in nested child functions.  For example, consider a parent function <code>foo</code>
with a nested child function <code>bar</code>:

<pre class="example">     function y = foo (to_eval)
       bar ();
       eval (to_eval);
     
       function bar ()
         eval ("x = 100;");
         eval ("y = x;");
       endfunction
     endfunction
     
     foo ("x = 5;")
         &rArr; error: can not add variable "x" to a static workspace
     
     foo ("y = 10;")
         &rArr; 10
     
     foo ("")
         &rArr; 100
</pre>
   <p class="noindent">The parent function <code>foo</code> is unable to create a new variable
<var>x</var>, but the child function <code>bar</code> was successful.  Furthermore, even
in an <code>eval</code> statement <var>y</var> in <code>bar</code> is the same <var>y</var> as in its
parent function <code>foo</code>.  The use of <code>eval</code> in conjunction with nested
functions is best avoided.

   <p>As with subfunctions, only the first nested function in a file may be called
from the outside.  Inside a function the rules are more complicated.  In
general a nested function may call:

     <ol type=1 start=0>
<li>Globally visible functions

     <li>Any function that the nested function's parent can call

     <li>Sibling functions (functions that have the same parents)

     <li>Direct children

        </ol>

   <p>As a complex example consider a parent function <code>ex_top</code> with two
child functions, <code>ex_a</code> and <code>ex_b</code>.  In addition, <code>ex_a</code> has two
more child functions, <code>ex_aa</code> and <code>ex_ab</code>.  For example:

<pre class="example">     function ex_top ()
       ## Can call: ex_top, ex_a, and ex_b
       ## Can NOT call: ex_aa and ex_ab
     
       function ex_a ()
         ## Call call everything
     
         function ex_aa ()
           ## Can call everything
         endfunction
     
         function ex_ab ()
           ## Can call everything
         endfunction
       endfunction
     
       function ex_b ()
         ## Can call: ex_top, ex_a, and ex_b
         ## Can NOT call: ex_aa and ex_ab
       endfunction
     endfunction
</pre>
   </body></html>

