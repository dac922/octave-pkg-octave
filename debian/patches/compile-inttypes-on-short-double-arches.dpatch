#! /bin/sh /usr/share/dpatch/dpatch-run
## -*- diff -*-
## compile-inttypes-on-short-double-arches.dpatch by Rafael Laboissiere <rafael@debian.org>
##
## DP: Workaround gcc 4.3 explicit instantiation bug in octave_int_cmp_op.
## DP: This was causing FTBFS on architectures with no long double type,
## DP. like mipsel and hppa. Thanks to Jaroslav Hajek for the patch.

@DPATCH@
# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1235374787 -3600
# Node ID 527d53c475f2f05059a5564f10d5bf7561ff598a
# Parent  d79edebd8f4526e4c67abc18996028151f91fc58
workaround gcc 4.3 explicit instantiation bug in octave_int_cmp_op

diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -56,7 +56,7 @@
 
 template <class xop> 
 OCTAVE_API bool 
-octave_int_cmp_op::mop (uint64_t x, double y)
+octave_int_cmp_op::emulate_mop (uint64_t x, double y)
 {
   static const double xxup = std::numeric_limits<uint64_t>::max ();
   // This converts to the nearest double. Unless there's an equality, the
@@ -76,7 +76,7 @@
 
 template <class xop> 
 OCTAVE_API bool 
-octave_int_cmp_op::mop (int64_t x, double y)
+octave_int_cmp_op::emulate_mop (int64_t x, double y)
 {
   static const double xxup = std::numeric_limits<int64_t>::max ();
   static const double xxlo = std::numeric_limits<int64_t>::min ();
@@ -123,7 +123,7 @@
 
 template <class xop> 
 OCTAVE_API bool 
-octave_int_cmp_op::mop (double x, uint64_t y)
+octave_int_cmp_op::emulate_mop (double x, uint64_t y)
 {
   typedef typename rev_op<xop>::op rop;
   return mop<rop> (y, x);
@@ -131,7 +131,7 @@
 
 template <class xop> 
 OCTAVE_API bool 
-octave_int_cmp_op::mop (double x, int64_t y)
+octave_int_cmp_op::emulate_mop (double x, int64_t y)
 {
   typedef typename rev_op<xop>::op rop;
   return mop<rop> (y, x);
@@ -499,8 +499,8 @@
 }
 
 #define INSTANTIATE_INT64_DOUBLE_CMP_OP0(OP,T1,T2) \
-  template OCTAVE_API bool \
-  octave_int_cmp_op::mop<octave_int_cmp_op::OP> (T1 x, T2 y)
+  template bool \
+  octave_int_cmp_op::emulate_mop<octave_int_cmp_op::OP> (T1 x, T2 y)
 
 #define INSTANTIATE_INT64_DOUBLE_CMP_OP(OP) \
   INSTANTIATE_INT64_DOUBLE_CMP_OP0(OP, double, int64_t); \
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -192,20 +192,29 @@
       return xop::op (static_cast<long double> (x), \
                       static_cast<long double> (y)); \
     }
+#else 
+  // ... otherwise, use external handlers
+
+  // FIXME: We could declare directly the mop methods as external,
+  // but we can't do this because bugs in gcc (<= 4.3) prevent
+  // explicit instantiations later in that case.
+#define DEFINE_LONG_DOUBLE_CMP_OP(T1, T2) \
+  template <class xop> static OCTAVE_API bool \
+  emulate_mop (T1, T2); \
+  template <class xop> \
+  static bool \
+  mop (T1 x, T2 y) \
+    { \
+      return emulate_mop<xop> (x, y); \
+    }
+#endif
+
   DEFINE_LONG_DOUBLE_CMP_OP(double, uint64_t)
   DEFINE_LONG_DOUBLE_CMP_OP(double, int64_t)
   DEFINE_LONG_DOUBLE_CMP_OP(int64_t, double)
   DEFINE_LONG_DOUBLE_CMP_OP(uint64_t, double)
+
 #undef DEFINE_LONG_DOUBLE_CMP_OP
-
-#else
-  // ... otherwise, use external handlers
-  template <class xop> static OCTAVE_API bool mop (uint64_t, double);
-  template <class xop> static OCTAVE_API bool mop (int64_t, double);
-  template <class xop> static OCTAVE_API bool mop (double, uint64_t);
-  template <class xop> static OCTAVE_API bool mop (double, int64_t);
-#endif
-
 };
 
 // Base integer class. No data, just conversion methods and exception flags.
