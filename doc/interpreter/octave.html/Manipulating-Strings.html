<html lang="en">
<head>
<title>Manipulating Strings - GNU Octave</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Octave">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Strings.html#Strings" title="Strings">
<link rel="prev" href="Comparing-Strings.html#Comparing-Strings" title="Comparing Strings">
<link rel="next" href="String-Conversions.html#String-Conversions" title="String Conversions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Manipulating-Strings"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="String-Conversions.html#String-Conversions">String Conversions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Comparing-Strings.html#Comparing-Strings">Comparing Strings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Strings.html#Strings">Strings</a>
<hr>
</div>

<h3 class="section">5.5 Manipulating Strings</h3>

<p>Octave supports a wide range of functions for manipulating strings. 
Since a string is just a matrix, simple manipulations can be accomplished
using standard operators.  The following example shows how to replace
all blank characters with underscores.

<pre class="example">     quote = ...
       "First things first, but not necessarily in that order";
     quote( quote == " " ) = "_"
     &rArr; quote =
         First_things_first,_but_not_necessarily_in_that_order
</pre>
   <p>For more complex manipulations, such as searching, replacing, and
general regular expressions, the following functions come with Octave.

<!-- deblank scripts/strings/deblank.m -->
   <p><a name="XREFdeblank"></a>

<div class="defun">
&mdash; Function File:  <b>deblank</b> (<var>s</var>)<var><a name="index-deblank-385"></a></var><br>
<blockquote><p>Remove trailing whitespace and nulls from <var>s</var>.  If <var>s</var>
is a matrix, <var>deblank</var> trims each row to the length of longest
string.  If <var>s</var> is a cell array of strings, operate recursively on each
string element.

        <p>Examples:

     <pre class="example">          deblank ("    abc  ")
               &rArr;  "    abc"
          
          deblank ([" abc   "; "   def   "])
               &rArr;  [" abc  " ; "   def"]
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFstrtrim.html#XREFstrtrim">strtrim</a>.

        </blockquote></div>

<!-- strtrim scripts/strings/strtrim.m -->
   <p><a name="XREFstrtrim"></a>

<div class="defun">
&mdash; Function File:  <b>strtrim</b> (<var>s</var>)<var><a name="index-strtrim-386"></a></var><br>
<blockquote><p>Remove leading and trailing whitespace from <var>s</var>.  If
<var>s</var> is a matrix, <var>strtrim</var> trims each row to the length of
longest string.  If <var>s</var> is a cell array of strings, operate recursively
on each string element.  For example:

     <pre class="example">          strtrim ("    abc  ")
               &rArr;  "abc"
          
          strtrim ([" abc   "; "   def   "])
               &rArr;  ["abc  "  ; "  def"]
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFdeblank.html#XREFdeblank">deblank</a>.

        </blockquote></div>

<!-- strtrunc scripts/strings/strtrunc.m -->
   <p><a name="XREFstrtrunc"></a>

<div class="defun">
&mdash; Function File:  <b>strtrunc</b> (<var>s, n</var>)<var><a name="index-strtrunc-387"></a></var><br>
<blockquote><p>Truncate the character string <var>s</var> to length <var>n</var>.  If <var>s</var>
is a character matrix, then the number of columns is adjusted. 
If <var>s</var> is a cell array of strings, then the operation is performed
on each cell element and the new cell array is returned. 
</p></blockquote></div>

<!-- findstr scripts/strings/findstr.m -->
   <p><a name="XREFfindstr"></a>

<div class="defun">
&mdash; Function File:  <b>findstr</b> (<var>s, t</var>)<var><a name="index-findstr-388"></a></var><br>
&mdash; Function File:  <b>findstr</b> (<var>s, t, overlap</var>)<var><a name="index-findstr-389"></a></var><br>
<blockquote><p>Return the vector of all positions in the longer of the two strings
<var>s</var> and <var>t</var> where an occurrence of the shorter of the two starts. 
If the optional argument <var>overlap</var> is true, the returned vector
can include overlapping positions (this is the default).  For example:

     <pre class="example">          findstr ("ababab", "a")
               &rArr; [1, 3, 5];
          findstr ("abababa", "aba", 0)
               &rArr; [1, 5]
</pre>
        <p><strong>Caution:</strong> <code>findstr</code> is scheduled for deprecation.  Use
<code>strfind</code> in all new code.

     <p class="noindent"><strong>See also:</strong> <a href="XREFstrfind.html#XREFstrfind">strfind</a>, <a href="XREFstrmatch.html#XREFstrmatch">strmatch</a>, <a href="XREFstrcmp.html#XREFstrcmp">strcmp</a>, <a href="XREFstrncmp.html#XREFstrncmp">strncmp</a>, <a href="XREFstrcmpi.html#XREFstrcmpi">strcmpi</a>, <a href="XREFstrncmpi.html#XREFstrncmpi">strncmpi</a>, <a href="XREFfind.html#XREFfind">find</a>.

        </blockquote></div>

<!-- strchr scripts/strings/strchr.m -->
   <p><a name="XREFstrchr"></a>

<div class="defun">
&mdash; Function File: <var>idx</var> = <b>strchr</b> (<var>str, chars</var>)<var><a name="index-strchr-390"></a></var><br>
&mdash; Function File: <var>idx</var> = <b>strchr</b> (<var>str, chars, n</var>)<var><a name="index-strchr-391"></a></var><br>
&mdash; Function File: <var>idx</var> = <b>strchr</b> (<var>str, chars, n, direction</var>)<var><a name="index-strchr-392"></a></var><br>
&mdash; Function File: [<var>i</var>, <var>j</var>] = <b>strchr</b> (<var><small class="dots">...</small></var>)<var><a name="index-strchr-393"></a></var><br>
<blockquote><p>Search for the string <var>str</var> for occurrences of characters from
the set <var>chars</var>.  The return value(s), as well as the <var>n</var> and
<var>direction</var> arguments behave identically as in <code>find</code>.

        <p>This will be faster than using regexp in most cases.

     <p class="noindent"><strong>See also:</strong> <a href="XREFfind.html#XREFfind">find</a>.

        </blockquote></div>

<!-- index scripts/strings/index.m -->
   <p><a name="XREFindex"></a>

<div class="defun">
&mdash; Function File:  <b>index</b> (<var>s, t</var>)<var><a name="index-index-394"></a></var><br>
&mdash; Function File:  <b>index</b> (<var>s, t, direction</var>)<var><a name="index-index-395"></a></var><br>
<blockquote><p>Return the position of the first occurrence of the string <var>t</var> in the
string <var>s</var>, or 0 if no occurrence is found.  <var>s</var> may also be a
string array or cell array of strings.

        <p>For example:

     <pre class="example">          index ("Teststring", "t")
              &rArr; 4
</pre>
        <p>If <var>direction</var> is <code>"first"</code>, return the first element found. 
If <var>direction</var> is <code>"last"</code>, return the last element found.

     <p class="noindent"><strong>See also:</strong> <a href="XREFfind.html#XREFfind">find</a>, <a href="XREFrindex.html#XREFrindex">rindex</a>.

        </blockquote></div>

<!-- rindex scripts/strings/rindex.m -->
   <p><a name="XREFrindex"></a>

<div class="defun">
&mdash; Function File:  <b>rindex</b> (<var>s, t</var>)<var><a name="index-rindex-396"></a></var><br>
<blockquote><p>Return the position of the last occurrence of the character string
<var>t</var> in the character string <var>s</var>, or 0 if no occurrence is
found.  <var>s</var> may also be a string array or cell array of strings.

        <p>For example:

     <pre class="example">          rindex ("Teststring", "t")
               &rArr; 6
</pre>
        <p>The <code>rindex</code> function is equivalent to <code>index</code> with
<var>direction</var> set to <code>"last"</code>.

     <p class="noindent"><strong>See also:</strong> <a href="XREFfind.html#XREFfind">find</a>, <a href="XREFindex.html#XREFindex">index</a>.

        </blockquote></div>

<!-- strfind libinterp/corefcn/strfind.cc -->
   <p><a name="XREFstrfind"></a>

<div class="defun">
&mdash; Built-in Function: <var>idx</var> = <b>strfind</b> (<var>str, pattern</var>)<var><a name="index-strfind-397"></a></var><br>
&mdash; Built-in Function: <var>idx</var> = <b>strfind</b> (<var>cellstr, pattern</var>)<var><a name="index-strfind-398"></a></var><br>
<blockquote><p>Search for <var>pattern</var> in the string <var>str</var> and return the
starting index of every such occurrence in the vector <var>idx</var>. 
If there is no such occurrence, or if <var>pattern</var> is longer
than <var>str</var>, then <var>idx</var> is the empty array <code>[]</code>.

        <p>If a cell array of strings <var>cellstr</var> is specified
then <var>idx</var> is a cell array of vectors, as specified
above.  Examples:

     <pre class="example">          strfind ("abababa", "aba")
               &rArr; [1, 3, 5]
          
          strfind ({"abababa", "bebebe", "ab"}, "aba")
               &rArr;
                  {
                    [1,1] =
          
                       1   3   5
          
                    [1,2] = [](1x0)
                    [1,3] = [](1x0)
                  }
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFfindstr.html#XREFfindstr">findstr</a>, <a href="XREFstrmatch.html#XREFstrmatch">strmatch</a>, <a href="XREFregexp.html#XREFregexp">regexp</a>, <a href="XREFregexpi.html#XREFregexpi">regexpi</a>, <a href="XREFfind.html#XREFfind">find</a>.

        </blockquote></div>

<!-- strjoin scripts/strings/strjoin.m -->
   <p><a name="XREFstrjoin"></a>

<div class="defun">
&mdash; Function File: <var>str</var> = <b>strjoin</b> (<var>cstr</var>)<var><a name="index-strjoin-399"></a></var><br>
&mdash; Function File: <var>str</var> = <b>strjoin</b> (<var>cstr, delimiter</var>)<var><a name="index-strjoin-400"></a></var><br>
<blockquote><p>Join the elements of the cell-string array, <var>cstr</var>, into a single
string.

        <p>If no <var>delimiter</var> is specified, the elements of <var>cstr</var>
separated by a space.

        <p>If <var>delimiter</var> is specified as a string, the cell-string array is
joined using the string.  Escape sequences are supported.

        <p>If <var>delimiter</var> is a cell-string array whose length is one less
than <var>cstr</var>, then the elements of <var>cstr</var> are joined by
interleaving the cell-string elements of <var>delimiter</var>.  Escape
sequences are not supported.

     <pre class="example">          strjoin ({'Octave','Scilab','Lush','Yorick'}, '*')
                &rArr; 'Octave*Scilab*Lush*Yorick'
</pre>
        <p class="noindent"><strong>See also:</strong> strsplit.

        </blockquote></div>

<!-- strmatch scripts/strings/strmatch.m -->
   <p><a name="XREFstrmatch"></a>

<div class="defun">
&mdash; Function File:  <b>strmatch</b> (<var>s, A</var>)<var><a name="index-strmatch-401"></a></var><br>
&mdash; Function File:  <b>strmatch</b> (<var>s, A, "exact"</var>)<var><a name="index-strmatch-402"></a></var><br>
<blockquote><p>Return indices of entries of <var>A</var> which begin with the string <var>s</var>. 
The second argument <var>A</var> must be a string, character matrix, or a cell
array of strings.  If the third argument <code>"exact"</code> is not given, then
<var>s</var> only needs to match <var>A</var> up to the length of <var>s</var>. 
Trailing spaces and nulls in <var>s</var> and <var>A</var> are ignored when matching.

        <p>For example:

     <pre class="example">          strmatch ("apple", "apple juice")
               &rArr; 1
          
          strmatch ("apple", ["apple  "; "apple juice"; "an apple"])
               &rArr; [1; 2]
          
          strmatch ("apple", ["apple  "; "apple juice"; "an apple"], "exact")
               &rArr; [1]
</pre>
        <p><strong>Caution:</strong> <code>strmatch</code> is scheduled for deprecation.  Use
<code>strncmp</code> (normal case), or <code>strcmp</code> (<code>"exact"</code> case), or
<code>regexp</code> in all new code.

     <p class="noindent"><strong>See also:</strong> <a href="XREFstrfind.html#XREFstrfind">strfind</a>, <a href="XREFfindstr.html#XREFfindstr">findstr</a>, <a href="XREFstrcmp.html#XREFstrcmp">strcmp</a>, <a href="XREFstrncmp.html#XREFstrncmp">strncmp</a>, <a href="XREFstrcmpi.html#XREFstrcmpi">strcmpi</a>, <a href="XREFstrncmpi.html#XREFstrncmpi">strncmpi</a>, <a href="XREFfind.html#XREFfind">find</a>.

        </blockquote></div>

<!-- strtok scripts/strings/strtok.m -->
   <p><a name="XREFstrtok"></a>

<div class="defun">
&mdash; Function File: [<var>tok</var>, <var>rem</var>] = <b>strtok</b> (<var>str</var>)<var><a name="index-strtok-403"></a></var><br>
&mdash; Function File: [<var>tok</var>, <var>rem</var>] = <b>strtok</b> (<var>str, delim</var>)<var><a name="index-strtok-404"></a></var><br>
<blockquote>
        <p>Find all characters in the string <var>str</var> up to, but not including, the
first character which is in the string <var>delim</var>.  If <var>rem</var> is
requested, it contains the remainder of the string, starting at the first
delimiter.  Leading delimiters are ignored.  If <var>delim</var> is not
specified, whitespace is assumed.  <var>str</var> may also be a cell array of
strings in which case the function executes on every individual string
and returns a cell array of tokens and remainders.

        <p>Examples:

     <pre class="example">          strtok ("this is the life")
               &rArr; "this"
          
          [tok, rem] = strtok ("14*27+31", "+-*/")
               &rArr;
                  tok = 14
                  rem = *27+31
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFindex.html#XREFindex">index</a>, <a href="XREFstrsplit.html#XREFstrsplit">strsplit</a>, <a href="XREFstrchr.html#XREFstrchr">strchr</a>, <a href="XREFisspace.html#XREFisspace">isspace</a>.

        </blockquote></div>

<!-- strsplit scripts/strings/strsplit.m -->
   <p><a name="XREFstrsplit"></a>

<div class="defun">
&mdash; Function File: [<var>cstr</var>] = <b>strsplit</b> (<var>s</var>)<var><a name="index-strsplit-405"></a></var><br>
&mdash; Function File: [<var>cstr</var>] = <b>strsplit</b> (<var>s, del</var>)<var><a name="index-strsplit-406"></a></var><br>
&mdash; Function File: [<var>cstr</var>] = <b>strsplit</b> (<var><small class="dots">...</small>, name, value</var>)<var><a name="index-strsplit-407"></a></var><br>
&mdash; Function File: [<var>cstr</var>, <var>matches</var>] = <b>strsplit</b> (<var><small class="dots">...</small></var>)<var><a name="index-strsplit-408"></a></var><br>
<blockquote><p>Split the string <var>s</var> using the delimiters specified by <var>del</var>
and return a cell-string array of sub-strings.  If a delimiter is not
specified the string, <var>s</var>, is split at whitespace.  The delimiter,
<var>del</var> may be a string, a scalar cell-string, or cell-string array. 
<var>del</var> must be a cell-string array.  By default, consecutive
delimiters in the input string, <var>s</var>, are collapsed into one.

        <p>The second output, <var>matches</var>, returns the delmiters which were matched
in the original string.

        <p>Example:

     <pre class="example">          strsplit ("a b c")
                &rArr;
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }
          
          strsplit ("a,b,c", ",")
                &rArr;
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }
          
          strsplit ("a foo b,bar c", {"\s", "foo", "bar"})
                &rArr;
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }
          
          strsplit ("a,,b, c", {",", " "}, false)
                &rArr;
                    {
                      [1,1] = a
                      [1,2] =
                      [1,3] = b
                      [1,4] =
                      [1,5] = c
                    }
          
</pre>
        <p>Supported <var>name</var>/<var>value</var> pair arguments are;

          <ul>
<li><var>collapsedelimiters</var> may take the value of <var>true</var> or
<var>false</var> with the default being <var>false</var>.

          <li><var>delimitertype</var> may take the value of <code>simple</code> or
<code>regularexpression</code>.  The default is <var>delimitertype</var> is
<code>simple</code>. 
</ul>

        <p>Example:

     <pre class="example">          strsplit ("a foo b,bar c", ",|\\s|foo|bar", "delimitertype", "regularexpression")
                &rArr;
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }
          
          strsplit ("a,,b, c", "[, ]", false, "delimitertype", "regularexpression")
                &rArr;
                    {
                      [1,1] = a
                      [1,2] =
                      [1,3] = b
                      [1,4] =
                      [1,5] = c
                    }
          
          strsplit ("a,\t,b, c", {',', '\s'}, "delimitertype", "regularexpression")
                &rArr;
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }
          
          strsplit ("a,\t,b, c", {',', ' ', '\t'}, "collapsedelimiters", false)
                &rArr;
                    {
                      [1,1] = a
                      [1,2] =
                      [1,3] =
                      [1,4] = b
                      [1,5] =
                      [1,6] = c
                    }
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFostrsplit.html#XREFostrsplit">ostrsplit</a>, <a href="XREFstrjoin.html#XREFstrjoin">strjoin</a>, <a href="XREFstrtok.html#XREFstrtok">strtok</a>, <a href="XREFregexp.html#XREFregexp">regexp</a>.

        </blockquote></div>

<!-- ostrsplit scripts/strings/ostrsplit.m -->
   <p><a name="XREFostrsplit"></a>

<div class="defun">
&mdash; Function File: [<var>cstr</var>] = <b>ostrsplit</b> (<var>s, sep</var>)<var><a name="index-ostrsplit-409"></a></var><br>
&mdash; Function File: [<var>cstr</var>] = <b>ostrsplit</b> (<var>s, sep, strip_empty</var>)<var><a name="index-ostrsplit-410"></a></var><br>
<blockquote><p>Split the string <var>s</var> using one or more separators <var>sep</var> and return
a cell array of strings.  Consecutive separators and separators at
boundaries result in empty strings, unless <var>strip_empty</var> is true. 
The default value of <var>strip_empty</var> is false.

        <p>2-D character arrays are split at separators and at the original column
boundaries.

        <p>Example:

     <pre class="example">          ostrsplit ("a,b,c", ",")
                &rArr;
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }
          
          ostrsplit (["a,b" ; "cde"], ",")
                &rArr;
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = cde
                    }
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFstrsplit.html#XREFstrsplit">strsplit</a>, <a href="XREFstrtok.html#XREFstrtok">strtok</a>.

        </blockquote></div>

<!-- strread scripts/io/strread.m -->
   <p><a name="XREFstrread"></a>

<div class="defun">
&mdash; Function File: [<var>a</var>, <small class="dots">...</small>] = <b>strread</b> (<var>str</var>)<var><a name="index-strread-411"></a></var><br>
&mdash; Function File: [<var>a</var>, <small class="dots">...</small>] = <b>strread</b> (<var>str, format</var>)<var><a name="index-strread-412"></a></var><br>
&mdash; Function File: [<var>a</var>, <small class="dots">...</small>] = <b>strread</b> (<var>str, format, format_repeat</var>)<var><a name="index-strread-413"></a></var><br>
&mdash; Function File: [<var>a</var>, <small class="dots">...</small>] = <b>strread</b> (<var>str, format, prop1, value1, <small class="dots">...</small></var>)<var><a name="index-strread-414"></a></var><br>
&mdash; Function File: [<var>a</var>, <small class="dots">...</small>] = <b>strread</b> (<var>str, format, format_repeat, prop1, value1, <small class="dots">...</small></var>)<var><a name="index-strread-415"></a></var><br>
<blockquote><p>Read data from a string.

        <p>The string <var>str</var> is split into words that are repeatedly matched to the
specifiers in <var>format</var>.  The first word is matched to the first
specifier, the second to the second specifier and so forth.  If there are
more words than specifiers, the process is repeated until all words have
been processed.

        <p>The string <var>format</var> describes how the words in <var>str</var> should be
parsed. 
It may contain any combination of the following specifiers:

          <dl>
<dt><code>%s</code><dd>The word is parsed as a string.

          <br><dt><code>%f</code><dt><code>%n</code><dd>The word is parsed as a number and converted to double.

          <br><dt><code>%d</code><dt><code>%u</code><dd>The word is parsed as a number and converted to int32.

          <br><dt><code>%*', '%*f', '%*s</code><dd>The word is skipped.

          <p>For %s and %d, %f, %n, %u and the associated %*s <small class="dots">...</small> specifiers an
optional width can be specified as %Ns, etc. where N is an integer &gt; 1. 
For %f, format specifiers like %N.Mf are allowed.

          <br><dt><code>literals</code><dd>In addition the format may contain literal character strings; these will be
skipped during reading. 
</dl>

        <p>Parsed word corresponding to the first specifier are returned in the first
output argument and likewise for the rest of the specifiers.

        <p>By default, <var>format</var> is <tt>"%f"</tt>, meaning that numbers are read from
<var>str</var>.  This will do if <var>str</var> contains only numeric fields.

        <p>For example, the string

     <pre class="example">          <var>str</var> = "\
          Bunny Bugs   5.5\n\
          Duck Daffy  -7.5e-5\n\
          Penguin Tux   6"
</pre>
        <p class="noindent">can be read using

     <pre class="example">          [<var>a</var>, <var>b</var>, <var>c</var>] = strread (<var>str</var>, "%s %s %f");
</pre>
        <p>Optional numeric argument <var>format_repeat</var> can be used for
limiting the number of items read:

          <dl>
<dt>-1<dd>(default) read all of the string until the end.

          <br><dt>N<dd>Read N times <var>nargout</var> items.  0 (zero) is an acceptable
value for <var>format_repeat</var>. 
</dl>

        <p>The behavior of <code>strread</code> can be changed via property-value
pairs.  The following properties are recognized:

          <dl>
<dt><code>"commentstyle"</code><dd>Parts of <var>str</var> are considered comments and will be skipped. 
<var>value</var> is the comment style and can be any of the following.

               <ul>
<li><code>"shell"</code>
Everything from <code>#</code> characters to the nearest end-of-line is skipped.

               <li><code>"c"</code>
Everything between <code>/*</code> and <code>*/</code> is skipped.

               <li><code>"c++"</code>
Everything from <code>//</code> characters to the nearest end-of-line is skipped.

               <li><code>"matlab"</code>
Everything from <code>%</code> characters to the nearest end-of-line is skipped.

               <li>user-supplied.  Two options:
(1) One string, or 1x1 cell string: Skip everything to the right of it;
(2) 2x1 cell string array: Everything between the left and right strings
is skipped. 
</ul>

          <br><dt><code>"delimiter"</code><dd>Any character in <var>value</var> will be used to split <var>str</var> into words
(default value = any whitespace).

          <br><dt><code>"emptyvalue"</code>:<dd>Value to return for empty numeric values in non-whitespace delimited data. 
The default is NaN.  When the data type does not support NaN
(int32 for example), then default is zero.

          <br><dt><code>"multipledelimsasone"</code><dd>Treat a series of consecutive delimiters, without whitespace in between,
as a single delimiter.  Consecutive delimiter series need not be vertically
<code>"aligned"</code>.

          <br><dt><code>"treatasempty"</code><dd>Treat single occurrences (surrounded by delimiters or whitespace) of the
string(s) in <var>value</var> as missing values.

          <br><dt><code>"returnonerror"</code><dd>If <var>value</var> true (1, default), ignore read errors and return normally. 
If false (0), return an error.

          <br><dt><code>"whitespace"</code><dd>Any character in <var>value</var> will be interpreted as whitespace and
trimmed; the string defining whitespace must be enclosed in double
quotes for proper processing of special characters like \t. 
The default value for whitespace = <code>" brnt"</code> (note the space). 
Unless whitespace is set to &rdquo; (empty) AND at least one <code>"%s"</code> format
conversion specifier is supplied, a space is always part of whitespace.

        </dl>

        <p>When the number of words in <var>str</var> doesn't match an exact multiple
of the number of format conversion specifiers, strread's behavior
depends on the last character of <var>str</var>:

          <dl>
<dt>last character = <code>"n"</code><dd>Data columns are padded with empty fields or Nan so that all columns
have equal length

          <br><dt>last character is not <code>"n"</code><dd>Data columns are not padded; strread returns columns of unequal length

        </dl>

     <p class="noindent"><strong>See also:</strong> <a href="XREFtextscan.html#XREFtextscan">textscan</a>, <a href="XREFtextread.html#XREFtextread">textread</a>, <a href="XREFload.html#XREFload">load</a>, <a href="XREFdlmread.html#XREFdlmread">dlmread</a>, <a href="XREFfscanf.html#XREFfscanf">fscanf</a>.

        </blockquote></div>

<!-- strrep libinterp/corefcn/strfind.cc -->
   <p><a name="XREFstrrep"></a>

<div class="defun">
&mdash; Built-in Function:  <b>strrep</b> (<var>s, ptn, rep</var>)<var><a name="index-strrep-416"></a></var><br>
&mdash; Built-in Function:  <b>strrep</b> (<var>s, ptn, rep, "overlaps", o</var>)<var><a name="index-strrep-417"></a></var><br>
<blockquote><p>Replace all occurrences of the substring <var>ptn</var> in the string <var>s</var>
with the string <var>rep</var> and return the result.  For example:

     <pre class="example">          strrep ("This is a test string", "is", "&amp;%$")
              &rArr;  "Th&amp;%$ &amp;%$ a test string"
</pre>
        <p><var>s</var> may also be a cell array of strings, in which case the replacement is
done for each element and a cell array is returned.

     <p class="noindent"><strong>See also:</strong> <a href="XREFregexprep.html#XREFregexprep">regexprep</a>, <a href="XREFstrfind.html#XREFstrfind">strfind</a>, <a href="XREFfindstr.html#XREFfindstr">findstr</a>.

        </blockquote></div>

<!-- substr scripts/strings/substr.m -->
   <p><a name="XREFsubstr"></a>

<div class="defun">
&mdash; Function File:  <b>substr</b> (<var>s, offset</var>)<var><a name="index-substr-418"></a></var><br>
&mdash; Function File:  <b>substr</b> (<var>s, offset, len</var>)<var><a name="index-substr-419"></a></var><br>
<blockquote><p>Return the substring of <var>s</var> which starts at character number
<var>offset</var> and is <var>len</var> characters long.

        <p>Position numbering for offsets begins with 1.  If <var>offset</var> is negative,
extraction starts that far from the end of the string.

        <p>If <var>len</var> is omitted, the substring extends to the end of <var>S</var>.  A
negative value for <var>len</var> extracts to within <var>len</var> characters of
the end of the string

        <p>Examples:

     <pre class="example">          substr ("This is a test string", 6, 9)
               &rArr; "is a test"
          substr ("This is a test string", -11)
               &rArr; "test string"
          substr ("This is a test string", -11, -7)
               &rArr; "test"
</pre>
        <p>This function is patterned after the equivalent function in Perl. 
</p></blockquote></div>

<!-- regexp libinterp/corefcn/regexp.cc -->
   <p><a name="XREFregexp"></a>

<div class="defun">
&mdash; Built-in Function: [<var>s</var>, <var>e</var>, <var>te</var>, <var>m</var>, <var>t</var>, <var>nm</var>, <var>sp</var>] = <b>regexp</b> (<var>str, pat</var>)<var><a name="index-regexp-420"></a></var><br>
&mdash; Built-in Function: [<small class="dots">...</small>] = <b>regexp</b> (<var>str, pat, "opt1", <small class="dots">...</small></var>)<var><a name="index-regexp-421"></a></var><br>
<blockquote><p>Regular expression string matching.  Search for <var>pat</var> in <var>str</var> and
return the positions and substrings of any matches, or empty values if there
are none.

        <p>The matched pattern <var>pat</var> can include any of the standard regex
operators, including:

          <dl>
<dt><code>.</code><dd>Match any character

          <br><dt><code>* + ? {}</code><dd>Repetition operators, representing

               <dl>
<dt><code>*</code><dd>Match zero or more times

               <br><dt><code>+</code><dd>Match one or more times

               <br><dt><code>?</code><dd>Match zero or one times

               <br><dt><code>{</code><var>n</var><code>}</code><dd>Match exactly <var>n</var> times

               <br><dt><code>{</code><var>n</var><code>,}</code><dd>Match <var>n</var> or more times

               <br><dt><code>{</code><var>m</var><code>,</code><var>n</var><code>}</code><dd>Match between <var>m</var> and <var>n</var> times
</dl>

          <br><dt><code>[...] [^...]</code><dd>
List operators.  The pattern will match any character listed between "["
and "]".  If the first character is "^" then the pattern is inverted and
any character except those listed between brackets will match.

          <p>Escape sequences defined below can also be used inside list
operators.  For example, a template for a floating point number might be
<code>[-+.\d]+</code>.

          <br><dt><code>() (?:)</code><dd>Grouping operator.  The first form, parentheses only, also creates a token.

          <br><dt><code>|</code><dd>Alternation operator.  Match one of a choice of regular expressions.  The
alternatives must be delimited by the grouping operator <code>()</code> above.

          <br><dt><code>^ $</code><dd>Anchoring operators.  Requires pattern to occur at the start (<code>^</code>) or
end (<code>$</code>) of the string. 
</dl>

        <p>In addition, the following escaped characters have special meaning.

          <dl>
<dt><code>\d</code><dd>Match any digit

          <br><dt><code>\D</code><dd>Match any non-digit

          <br><dt><code>\s</code><dd>Match any whitespace character

          <br><dt><code>\S</code><dd>Match any non-whitespace character

          <br><dt><code>\w</code><dd>Match any word character

          <br><dt><code>\W</code><dd>Match any non-word character

          <br><dt><code>\&lt;</code><dd>Match the beginning of a word

          <br><dt><code>\&gt;</code><dd>Match the end of a word

          <br><dt><code>\B</code><dd>Match within a word
</dl>

        <p>Implementation Note: For compatibility with <span class="sc">matlab</span>, ordinary escape
sequences (e.g., <code>"n"</code> =&gt; newline) are processed in <var>pat</var>
regardless of whether <var>pat</var> has been defined within single quotes.  Use
a second backslash to stop interpolation of the escape sequence (e.g.,
"\\n") or use the <code>regexptranslate</code> function.

        <p>The outputs of <code>regexp</code> default to the order given below

          <dl>
<dt><var>s</var><dd>The start indices of each matching substring

          <br><dt><var>e</var><dd>The end indices of each matching substring

          <br><dt><var>te</var><dd>The extents of each matched token surrounded by <code>(...)</code> in
<var>pat</var>

          <br><dt><var>m</var><dd>A cell array of the text of each match

          <br><dt><var>t</var><dd>A cell array of the text of each token matched

          <br><dt><var>nm</var><dd>A structure containing the text of each matched named token, with the name
being used as the fieldname.  A named token is denoted by
<code>(?&lt;name&gt;...)</code>.

          <br><dt><var>sp</var><dd>A cell array of the text not returned by match, i.e., what remains if you
split the string based on <var>pat</var>. 
</dl>

        <p>Particular output arguments, or the order of the output arguments, can be
selected by additional <var>opt</var> arguments.  These are strings and the
correspondence between the output arguments and the optional argument
are

        <p><table summary=""><tr align="left"><td valign="top" width="20%"></td><td valign="top" width="30%"><code>'start'</code>        </td><td valign="top" width="30%"><var>s</var>  </td><td valign="top" width="20%">
<br></td></tr><tr align="left"><td valign="top" width="20%"></td><td valign="top" width="30%"><code>'end'</code>          </td><td valign="top" width="30%"><var>e</var>  </td><td valign="top" width="20%">
<br></td></tr><tr align="left"><td valign="top" width="20%"></td><td valign="top" width="30%"><code>'tokenExtents'</code> </td><td valign="top" width="30%"><var>te</var> </td><td valign="top" width="20%">
<br></td></tr><tr align="left"><td valign="top" width="20%"></td><td valign="top" width="30%"><code>'match'</code>        </td><td valign="top" width="30%"><var>m</var>  </td><td valign="top" width="20%">
<br></td></tr><tr align="left"><td valign="top" width="20%"></td><td valign="top" width="30%"><code>'tokens'</code>       </td><td valign="top" width="30%"><var>t</var>  </td><td valign="top" width="20%">
<br></td></tr><tr align="left"><td valign="top" width="20%"></td><td valign="top" width="30%"><code>'names'</code>        </td><td valign="top" width="30%"><var>nm</var> </td><td valign="top" width="20%">
<br></td></tr><tr align="left"><td valign="top" width="20%"></td><td valign="top" width="30%"><code>'split'</code>        </td><td valign="top" width="30%"><var>sp</var> </td><td valign="top" width="20%">
        <br></td></tr></table>

        <p>Additional arguments are summarized below.

          <dl>
<dt>&lsquo;<samp><span class="samp">once</span></samp>&rsquo;<dd>Return only the first occurrence of the pattern.

          <br><dt>&lsquo;<samp><span class="samp">matchcase</span></samp>&rsquo;<dd>Make the matching case sensitive.  (default)

          <p>Alternatively, use (?-i) in the pattern.

          <br><dt>&lsquo;<samp><span class="samp">ignorecase</span></samp>&rsquo;<dd>Ignore case when matching the pattern to the string.

          <p>Alternatively, use (?i) in the pattern.

          <br><dt>&lsquo;<samp><span class="samp">stringanchors</span></samp>&rsquo;<dd>Match the anchor characters at the beginning and end of the string. 
(default)

          <p>Alternatively, use (?-m) in the pattern.

          <br><dt>&lsquo;<samp><span class="samp">lineanchors</span></samp>&rsquo;<dd>Match the anchor characters at the beginning and end of the line.

          <p>Alternatively, use (?m) in the pattern.

          <br><dt>&lsquo;<samp><span class="samp">dotall</span></samp>&rsquo;<dd>The pattern <code>.</code> matches all characters including the newline character. 
 (default)

          <p>Alternatively, use (?s) in the pattern.

          <br><dt>&lsquo;<samp><span class="samp">dotexceptnewline</span></samp>&rsquo;<dd>The pattern <code>.</code> matches all characters except the newline character.

          <p>Alternatively, use (?-s) in the pattern.

          <br><dt>&lsquo;<samp><span class="samp">literalspacing</span></samp>&rsquo;<dd>All characters in the pattern, including whitespace, are significant and are
used in pattern matching.  (default)

          <p>Alternatively, use (?-x) in the pattern.

          <br><dt>&lsquo;<samp><span class="samp">freespacing</span></samp>&rsquo;<dd>The pattern may include arbitrary whitespace and also comments beginning with
the character &lsquo;<samp><span class="samp">#</span></samp>&rsquo;.

          <p>Alternatively, use (?x) in the pattern.

          <br><dt>&lsquo;<samp><span class="samp">noemptymatch</span></samp>&rsquo;<dd>Zero-length matches are not returned.  (default)

          <br><dt>&lsquo;<samp><span class="samp">emptymatch</span></samp>&rsquo;<dd>Return zero-length matches.

          <p><code>regexp ('a', 'b*', 'emptymatch')</code> returns <code>[1 2]</code> because there
are zero or more <code>'b'</code> characters at positions 1 and end-of-string.

        </dl>

     <p class="noindent"><strong>See also:</strong> <a href="XREFregexpi.html#XREFregexpi">regexpi</a>, <a href="XREFstrfind.html#XREFstrfind">strfind</a>, <a href="XREFregexprep.html#XREFregexprep">regexprep</a>.

        </blockquote></div>

<!-- regexpi libinterp/corefcn/regexp.cc -->
   <p><a name="XREFregexpi"></a>

<div class="defun">
&mdash; Built-in Function: [<var>s</var>, <var>e</var>, <var>te</var>, <var>m</var>, <var>t</var>, <var>nm</var>, <var>sp</var>] = <b>regexpi</b> (<var>str, pat</var>)<var><a name="index-regexpi-422"></a></var><br>
&mdash; Built-in Function: [<small class="dots">...</small>] = <b>regexpi</b> (<var>str, pat, "opt1", <small class="dots">...</small></var>)<var><a name="index-regexpi-423"></a></var><br>
<blockquote>
        <p>Case insensitive regular expression string matching.  Search for <var>pat</var> in
<var>str</var> and return the positions and substrings of any matches, or empty
values if there are none.  See <a href="XREFregexp.html#XREFregexp">regexp</a>, for details on the
syntax of the search pattern.

     <p class="noindent"><strong>See also:</strong> <a href="XREFregexp.html#XREFregexp">regexp</a>.

        </blockquote></div>

<!-- regexprep libinterp/corefcn/regexp.cc -->
   <p><a name="XREFregexprep"></a>

<div class="defun">
&mdash; Built-in Function: <var>outstr</var> = <b>regexprep</b> (<var>string, pat, repstr</var>)<var><a name="index-regexprep-424"></a></var><br>
&mdash; Built-in Function: <var>outstr</var> = <b>regexprep</b> (<var>string, pat, repstr, "opt1", <small class="dots">...</small></var>)<var><a name="index-regexprep-425"></a></var><br>
<blockquote><p>Replace occurrences of pattern <var>pat</var> in <var>string</var> with <var>repstr</var>.

        <p>The pattern is a regular expression as documented for <code>regexp</code>. 
See <a href="XREFregexp.html#XREFregexp">regexp</a>.

        <p>The replacement string may contain <code>$i</code>, which substitutes
for the ith set of parentheses in the match string.  For example,

     <pre class="example">          regexprep ("Bill Dunn", '(\w+) (\w+)', '$2, $1')
</pre>
        <p class="noindent">returns "Dunn, Bill"

        <p>Options in addition to those of <code>regexp</code> are

          <dl>
<dt>&lsquo;<samp><span class="samp">once</span></samp>&rsquo;<dd>Replace only the first occurrence of <var>pat</var> in the result.

          <br><dt>&lsquo;<samp><span class="samp">warnings</span></samp>&rsquo;<dd>This option is present for compatibility but is ignored.

        </dl>

        <p>Implementation Note: For compatibility with <span class="sc">matlab</span>, ordinary escape
sequences (e.g., <code>"n"</code> =&gt; newline) are processed in both <var>pat</var>
and <var>repstr</var> regardless of whether they were defined within single
quotes.  Use a second backslash to stop interpolation of the escape sequence
(e.g., "\\n") or use the <code>regexptranslate</code> function.

     <p class="noindent"><strong>See also:</strong> <a href="XREFregexp.html#XREFregexp">regexp</a>, <a href="XREFregexpi.html#XREFregexpi">regexpi</a>, <a href="XREFstrrep.html#XREFstrrep">strrep</a>.

        </blockquote></div>

<!-- regexptranslate scripts/strings/regexptranslate.m -->
   <p><a name="XREFregexptranslate"></a>

<div class="defun">
&mdash; Function File:  <b>regexptranslate</b> (<var>op, s</var>)<var><a name="index-regexptranslate-426"></a></var><br>
<blockquote><p>Translate a string for use in a regular expression.  This may
include either wildcard replacement or special character escaping. 
The behavior is controlled by <var>op</var> which can take the following
values

          <dl>
<dt><code>"wildcard"</code><dd>The wildcard characters <code>.</code>, <code>*</code>, and <code>?</code> are replaced
with wildcards that are appropriate for a regular expression. 
For example:

          <pre class="example">               regexptranslate ("wildcard", "*.m")
                    &rArr; ".*\.m"
</pre>
          <br><dt><code>"escape"</code><dd>The characters <code>$.?[]</code>, that have special meaning for regular
expressions are escaped so that they are treated literally.  For example:

          <pre class="example">               regexptranslate ("escape", "12.5")
                    &rArr; "12\.5"
</pre>
          </dl>

     <p class="noindent"><strong>See also:</strong> <a href="XREFregexp.html#XREFregexp">regexp</a>, <a href="XREFregexpi.html#XREFregexpi">regexpi</a>, <a href="XREFregexprep.html#XREFregexprep">regexprep</a>.

        </blockquote></div>

<!-- untabify scripts/strings/untabify.m -->
   <p><a name="XREFuntabify"></a>

<div class="defun">
&mdash; Function File:  <b>untabify</b> (<var>t</var>)<var><a name="index-untabify-427"></a></var><br>
&mdash; Function File:  <b>untabify</b> (<var>t, tw</var>)<var><a name="index-untabify-428"></a></var><br>
&mdash; Function File:  <b>untabify</b> (<var>t, tw, deblank</var>)<var><a name="index-untabify-429"></a></var><br>
<blockquote><p>Replace TAB characters in <var>t</var>, with spaces. 
The tab width is specified by <var>tw</var>, or defaults to eight. 
The input, <var>t</var>, may be either a 2-D character array, or a cell
array of character strings.  The output is the same class
as the input.

        <p>If the optional argument <var>deblank</var> is true, then the spaces will
be removed from the end of the character data.

        <p>The following example reads a file and writes an untabified version
of the same file with trailing spaces stripped.

     <pre class="example">          fid = fopen ("tabbed_script.m");
          text = char (fread (fid, "uchar")');
          fclose (fid);
          fid = fopen ("untabified_script.m", "w");
          text = untabify (strsplit (text, "\n"), 8, true);
          fprintf (fid, "%s\n", text{:});
          fclose (fid);
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFstrjust.html#XREFstrjust">strjust</a>, <a href="XREFstrsplit.html#XREFstrsplit">strsplit</a>, <a href="XREFdeblank.html#XREFdeblank">deblank</a>.

        </blockquote></div>

   </body></html>

