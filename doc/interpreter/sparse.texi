@c DO NOT EDIT!  Generated automatically by munge-texi.

@c Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 David Bateman
@c
@c This file is part of Octave.
@c
@c Octave is free software; you can redistribute it and/or modify it
@c under the terms of the GNU General Public License as published by the
@c Free Software Foundation; either version 3 of the License, or (at
@c your option) any later version.
@c 
@c Octave is distributed in the hope that it will be useful, but WITHOUT
@c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
@c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
@c for more details.
@c 
@c You should have received a copy of the GNU General Public License
@c along with Octave; see the file COPYING.  If not, see
@c <http://www.gnu.org/licenses/>.

@ifhtml
@set htmltex
@end ifhtml
@iftex
@set htmltex
@end iftex

@node Sparse Matrices 
@chapter Sparse Matrices

@menu
* Basics::                      Creation and Manipulation of Sparse Matrices
* Sparse Linear Algebra::       Linear Algebra on Sparse Matrices
* Iterative Techniques::        Iterative Techniques
* Real Life Example::           Using Sparse Matrices
@end menu

@node Basics
@section The Creation and Manipulation of Sparse Matrices

The size of mathematical problems that can be treated at any particular
time is generally limited by the available computing resources.  Both,
the speed of the computer and its available memory place limitation on
the problem size. 

There are many classes of mathematical problems which give rise to
matrices, where a large number of the elements are zero.  In this case
it makes sense to have a special matrix type to handle this class of
problems where only the non-zero elements of the matrix are
stored.  Not only does this reduce the amount of memory to store the
matrix, but it also means that operations on this type of matrix can
take advantage of the a-priori knowledge of the positions of the
non-zero elements to accelerate their calculations.

A matrix type that stores only the non-zero elements is generally called
sparse.  It is the purpose of this document to discuss the basics of the
storage and creation of sparse matrices and the fundamental operations
on them.

@menu
* Storage of Sparse Matrices::
* Creating Sparse Matrices::
* Information::
* Operators and Functions::
@end menu

@node Storage of Sparse Matrices
@subsection Storage of Sparse Matrices

It is not strictly speaking necessary for the user to understand how
sparse matrices are stored.  However, such an understanding will help
to get an understanding of the size of sparse matrices.  Understanding
the storage technique is also necessary for those users wishing to 
create their own oct-files. 

There are many different means of storing sparse matrix data.  What all
of the methods have in common is that they attempt to reduce the complexity
and storage given a-priori knowledge of the particular class of problems
that will be solved.  A good summary of the available techniques for storing
sparse matrix is given by Saad @footnote{Youcef Saad "SPARSKIT: A basic toolkit
for sparse matrix computation", 1994,
@url{http://www-users.cs.umn.edu/~saad/software/SPARSKIT/paper.ps}}.
With full matrices, knowledge of the point of an element of the matrix
within the matrix is implied by its position in the computers memory. 
However, this is not the case for sparse matrices, and so the positions
of the non-zero elements of the matrix must equally be stored. 

An obvious way to do this is by storing the elements of the matrix as
triplets, with two elements being their position in the array 
(rows and column) and the third being the data itself.  This is conceptually
easy to grasp, but requires more storage than is strictly needed.

The storage technique used within Octave is the compressed column
format.  In this format the position of each element in a row and the
data are stored as previously.  However, if we assume that all elements
in the same column are stored adjacent in the computers memory, then
we only need to store information on the number of non-zero elements
in each column, rather than their positions.  Thus assuming that the
matrix has more non-zero elements than there are columns in the
matrix, we win in terms of the amount of memory used.

In fact, the column index contains one more element than the number of
columns, with the first element always being zero.  The advantage of
this is a simplification in the code, in that there is no special case
for the first or last columns.  A short example, demonstrating this in
C is.

@example
@group
  for (j = 0; j < nc; j++)
    for (i = cidx (j); i < cidx(j+1); i++)
       printf ("non-zero element (%i,%i) is %d\n", 
	   ridx(i), j, data(i));
@end group
@end example

A clear understanding might be had by considering an example of how the
above applies to an example matrix.  Consider the matrix

@example
@group
    1   2   0  0
    0   0   0  3
    0   0   0  4
@end group
@end example

The non-zero elements of this matrix are

@example
@group
   (1, 1)  @result{} 1
   (1, 2)  @result{} 2
   (2, 4)  @result{} 3
   (3, 4)  @result{} 4
@end group
@end example

This will be stored as three vectors @var{cidx}, @var{ridx} and @var{data},
representing the column indexing, row indexing and data respectively.  The
contents of these three vectors for the above matrix will be

@example
@group
  @var{cidx} = [0, 1, 2, 2, 4]
  @var{ridx} = [0, 0, 1, 2]
  @var{data} = [1, 2, 3, 4]
@end group
@end example

Note that this is the representation of these elements with the first row
and column assumed to start at zero, while in Octave itself the row and 
column indexing starts at one.  Thus the number of elements in the 
@var{i}-th column is given by @code{@var{cidx} (@var{i} + 1) - 
@var{cidx} (@var{i})}.

Although Octave uses a compressed column format, it should be noted
that compressed row formats are equally possible.  However, in the
context of mixed operations between mixed sparse and dense matrices,
it makes sense that the elements of the sparse matrices are in the
same order as the dense matrices.  Octave stores dense matrices in
column major ordering, and so sparse matrices are equally stored in
this manner.

A further constraint on the sparse matrix storage used by Octave is that 
all elements in the rows are stored in increasing order of their row
index, which makes certain operations faster.  However, it imposes
the need to sort the elements on the creation of sparse matrices.  Having
disordered elements is potentially an advantage in that it makes operations
such as concatenating two sparse matrices together easier and faster, however
it adds complexity and speed problems elsewhere.

@node Creating Sparse Matrices
@subsection Creating Sparse Matrices

There are several means to create sparse matrix.

@table @asis
@item Returned from a function
There are many functions that directly return sparse matrices.  These include
@dfn{speye}, @dfn{sprand}, @dfn{diag}, etc.
@item Constructed from matrices or vectors
The function @dfn{sparse} allows a sparse matrix to be constructed from 
three vectors representing the row, column and data.  Alternatively, the
function @dfn{spconvert} uses a three column matrix format to allow easy
importation of data from elsewhere.
@item Created and then filled
The function @dfn{sparse} or @dfn{spalloc} can be used to create an empty
matrix that is then filled by the user
@item From a user binary program
The user can directly create the sparse matrix within an oct-file.
@end table

There are several basic functions to return specific sparse
matrices.  For example the sparse identity matrix, is a matrix that is
often needed.  It therefore has its own function to create it as
@code{speye (@var{n})} or @code{speye (@var{r}, @var{c})}, which
creates an @var{n}-by-@var{n} or @var{r}-by-@var{c} sparse identity
matrix.

Another typical sparse matrix that is often needed is a random distribution
of random elements.  The functions @dfn{sprand} and @dfn{sprandn} perform
this for uniform and normal random distributions of elements.  They have exactly
the same calling convention, where @code{sprand (@var{r}, @var{c}, @var{d})},
creates an @var{r}-by-@var{c} sparse matrix with a density of filled
elements of @var{d}.

Other functions of interest that directly create sparse matrices, are
@dfn{diag} or its generalization @dfn{spdiags}, that can take the
definition of the diagonals of the matrix and create the sparse matrix 
that corresponds to this.  For example

@example
s = diag (sparse(randn(1,n)), -1);
@end example

creates a sparse (@var{n}+1)-by-(@var{n}+1) sparse matrix with a single
diagonal defined.


@c ./sparse/spdiags.m
@anchor{doc-spdiags}
@deftypefn {Function File} {[@var{b}, @var{c}] =} spdiags (@var{a})
@deftypefnx {Function File} {@var{b} =} spdiags (@var{a}, @var{c})
@deftypefnx {Function File} {@var{b} =} spdiags (@var{v}, @var{c}, @var{a})
@deftypefnx {Function File} {@var{b} =} spdiags (@var{v}, @var{c}, @var{m}, @var{n})
A generalization of the function @code{diag}.  Called with a single
input argument, the non-zero diagonals @var{c} of @var{A} are extracted.
With two arguments the diagonals to extract are given by the vector 
@var{c}.

The other two forms of @code{spdiags} modify the input matrix by
replacing the diagonals.  They use the columns of @var{v} to replace
the columns represented by the vector @var{c}.  If the sparse matrix
@var{a} is defined then the diagonals of this matrix are replaced.
Otherwise a matrix of @var{m} by @var{n} is created with the
diagonals given by @var{v}.

Negative values of @var{c} represent diagonals below the main
diagonal, and positive values of @var{c} diagonals above the main
diagonal.

For example

@example
@group
spdiags (reshape (1:12, 4, 3), [-1 0 1], 5, 4)
@result{}    5 10  0  0
      1  6 11  0
      0  2  7 12
      0  0  3  8
      0  0  0  4
@end group
@end example

@end deftypefn


@c ./sparse/speye.m
@anchor{doc-speye}
@deftypefn {Function File} {@var{y} =} speye (@var{m})
@deftypefnx {Function File} {@var{y} =} speye (@var{m}, @var{n})
@deftypefnx {Function File} {@var{y} =} speye (@var{sz})
Returns a sparse identity matrix.  This is significantly more
efficient than @code{sparse (eye (@var{m}))} as the full matrix
is not constructed.

Called with a single argument a square matrix of size @var{m} by
@var{m} is created.  Otherwise a matrix of @var{m} by @var{n} is
created.  If called with a single vector argument, this argument 
is taken to be the size of the matrix to create.
@end deftypefn


@c ./sparse/spfun.m
@anchor{doc-spfun}
@deftypefn {Function File} {@var{y} =} spfun (@var{f},@var{x})
Compute @code{f(@var{x})} for the non-zero values of @var{x}.
This results in a sparse matrix with the same structure as 
@var{x}.  The function @var{f} can be passed as a string, a
function handle or an inline function.
@end deftypefn


@c ./deprecated/spmax.m
@anchor{doc-spmax}
@deftypefn {Mapping Function} {} spmax (@var{x}, @var{y}, @var{dim})
@deftypefnx {Mapping Function} {[@var{w}, @var{iw}] =} spmax (@var{x})
This function has been deprecated.  Use @code{max} instead.
@end deftypefn


@c ./deprecated/spmin.m
@anchor{doc-spmin}
@deftypefn {Mapping Function} {} spmin (@var{x}, @var{y}, @var{dim})
@deftypefnx {Mapping Function} {[@var{w}, @var{iw}] =} spmin (@var{x})
This function has been deprecated.  Use @code{min} instead.
@end deftypefn


@c ./sparse/spones.m
@anchor{doc-spones}
@deftypefn {Function File} {@var{y} =} spones (@var{x})
Replace the non-zero entries of @var{x} with ones.  This creates a
sparse matrix with the same structure as @var{x}.
@end deftypefn


@c ./sparse/sprand.m
@anchor{doc-sprand}
@deftypefn {Function File} {} sprand (@var{m}, @var{n}, @var{d})
@deftypefnx {Function File} {} sprand (@var{s})
Generate a random sparse matrix.  The size of the matrix will be
@var{m} by @var{n}, with a density of values given by @var{d}.
@var{d} should be between 0 and 1. Values will be uniformly
distributed between 0 and 1.

Note: sometimes the actual density may be a bit smaller than @var{d}. 
This is unlikely to happen for large really sparse matrices.

If called with a single matrix argument, a random sparse matrix is
generated wherever the matrix @var{S} is non-zero.
@seealso{@ref{doc-sprandn,,sprandn}}
@end deftypefn


@c ./sparse/sprandn.m
@anchor{doc-sprandn}
@deftypefn {Function File} {} sprandn (@var{m}, @var{n}, @var{d})
@deftypefnx {Function File} {} sprandn (@var{s})
Generate a random sparse matrix.  The size of the matrix will be
@var{m} by @var{n}, with a density of values given by @var{d}.
@var{d} should be between 0 and 1. Values will be normally
distributed with mean of zero and variance 1.

Note: sometimes the actual density may be a bit smaller than @var{d}. 
This is unlikely to happen for large really sparse matrices.

If called with a single matrix argument, a random sparse matrix is
generated wherever the matrix @var{S} is non-zero.
@seealso{@ref{doc-sprand,,sprand}}
@end deftypefn


@c ./sparse/sprandsym.m
@anchor{doc-sprandsym}
@deftypefn {Function File} {} sprandsym (@var{n}, @var{d})
@deftypefnx {Function File} {} sprandsym (@var{s})
Generate a symmetric random sparse matrix.  The size of the matrix will be
@var{n} by @var{n}, with a density of values given by @var{d}.
@var{d} should be between 0 and 1. Values will be normally
distributed with mean of zero and variance 1.

Note: sometimes the actual density may be a bit smaller than @var{d}. 
This is unlikely to happen for large really sparse matrices.

If called with a single matrix argument, a random sparse matrix is
generated wherever the matrix @var{S} is non-zero in its lower
triangular part.
@seealso{@ref{doc-sprand,,sprand}, @ref{doc-sprandn,,sprandn}}
@end deftypefn


The recommended way for the user to create a sparse matrix, is to create 
two vectors containing the row and column index of the data and a third
vector of the same size containing the data to be stored.  For example

@example
@group
  ri = ci = d = [];
  for j = 1:c
    ri = [ri; randperm(r)(1:n)'];
    ci = [ci; j*ones(n,1)];
    d = [d; rand(n,1)];
  endfor
  s = sparse (ri, ci, d, r, c);
@end group
@end example

creates an @var{r}-by-@var{c} sparse matrix with a random distribution
of @var{n} (<@var{r}) elements per column.  The elements of the vectors
do not need to be sorted in any particular order as Octave will sort
them prior to storing the data.  However, pre-sorting the data will
make the creation of the sparse matrix faster.

The function @dfn{spconvert} takes a three or four column real matrix.
The first two columns represent the row and column index respectively and
the third and four columns, the real and imaginary parts of the sparse
matrix.  The matrix can contain zero elements and the elements can be 
sorted in any order.  Adding zero elements is a convenient way to define
the size of the sparse matrix.  For example

@example
@group
s = spconvert ([1 2 3 4; 1 3 4 4; 1 2 3 0]')
@result{} Compressed Column Sparse (rows=4, cols=4, nnz=3)
      (1 , 1) -> 1
      (2 , 3) -> 2
      (3 , 4) -> 3
@end group
@end example

An example of creating and filling a matrix might be

@example
@group
k = 5;
nz = r * k;
s = spalloc (r, c, nz)
for j = 1:c
  idx = randperm (r);
  s (:, j) = [zeros(r - k, 1); ...
        rand(k, 1)] (idx);
endfor
@end group
@end example

It should be noted, that due to the way that the Octave
assignment functions are written that the assignment will reallocate
the memory used by the sparse matrix at each iteration of the above loop. 
Therefore the @dfn{spalloc} function ignores the @var{nz} argument and 
does not preassign the memory for the matrix.  Therefore, it is vitally
important that code using to above structure should be vectorized
as much as possible to minimize the number of assignments and reduce the
number of memory allocations.

@c data.cc
@anchor{doc-full}
@deftypefn {Loadable Function} {@var{FM} =} full (@var{SM})
 returns a full storage matrix from a sparse, diagonal, permutation matrix or a range.
@seealso{@ref{doc-sparse,,sparse}}
@end deftypefn


@c ./sparse/spalloc.m
@anchor{doc-spalloc}
@deftypefn {Function File} {@var{s} =} spalloc (@var{r}, @var{c}, @var{nz})
Returns an empty sparse matrix of size @var{r}-by-@var{c}.  As Octave
resizes sparse matrices at the first opportunity, so that no additional 
space is needed, the argument @var{nz} is ignored.  This function is 
provided only for compatibility reasons.

It should be noted that this means that code like

@example
@group
k = 5;
nz = r * k;
s = spalloc (r, c, nz)
for j = 1:c
  idx = randperm (r);
  s (:, j) = [zeros(r - k, 1); rand(k, 1)] (idx);
endfor
@end group
@end example

will reallocate memory at each step.  It is therefore vitally important
that code like this is vectorized as much as possible.
@seealso{@ref{doc-sparse,,sparse}, @ref{doc-nzmax,,nzmax}}
@end deftypefn


@c ./DLD-FUNCTIONS/sparse.cc
@anchor{doc-sparse}
@deftypefn {Loadable Function} {@var{s} =} sparse (@var{a})
@deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n}, @var{nzmax})
@deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv})
@deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{s}, @var{m}, @var{n}, "unique")
@deftypefnx {Loadable Function} {@var{s} =} sparse (@var{m}, @var{n})
Create a sparse matrix from the full matrix or row, column, value triplets.
If @var{a} is a full matrix, convert it to a sparse matrix representation,
removing all zero values in the process.

Given the integer index vectors @var{i} and @var{j}, a 1-by-@code{nnz} vector
of real of complex values @var{sv}, overall dimensions @var{m} and @var{n}
of the sparse matrix.  The argument @code{nzmax} is ignored but accepted for
compatibility with @sc{matlab}.  If @var{m} or @var{n} are not specified their
values are derived from the maximum index in the vectors @var{i} and @var{j}
as given by @code{@var{m} = max (@var{i})}, @code{@var{n} = max (@var{j})}.

@strong{Note}: if multiple values are specified with the same
@var{i}, @var{j} indices, the corresponding values in @var{s} will
be added.

The following are all equivalent:

@example
@group
s = sparse (i, j, s, m, n)
s = sparse (i, j, s, m, n, "summation")
s = sparse (i, j, s, m, n, "sum")
@end group
@end example

Given the option "unique". if more than two values are specified for the
same @var{i}, @var{j} indices, the last specified value will be used.

@code{sparse(@var{m}, @var{n})} is equivalent to
@code{sparse ([], [], [], @var{m}, @var{n}, 0)}

If any of @var{sv}, @var{i} or @var{j} are scalars, they are expanded
to have a common size.
@seealso{@ref{doc-full,,full}}
@end deftypefn


@c ./sparse/spconvert.m
@anchor{doc-spconvert}
@deftypefn {Function File} {@var{x} =} spconvert (@var{m})
This function converts for a simple sparse matrix format easily
produced by other programs into Octave's internal sparse format.  The
input @var{x} is either a 3 or 4 column real matrix, containing
the row, column, real and imaginary parts of the elements of the
sparse matrix.  An element with a zero real and imaginary part can
be used to force a particular matrix size.
@end deftypefn


The above problem of memory reallocation can be avoided in
oct-files.  However, the construction of a sparse matrix from an oct-file
is more complex than can be discussed here, and
you are referred to chapter @ref{Dynamically Linked Functions}, to have
a full description of the techniques involved.

@node Information
@subsection Finding out Information about Sparse Matrices

There are a number of functions that allow information concerning
sparse matrices to be obtained.  The most basic of these is
@dfn{issparse} that identifies whether a particular Octave object is
in fact a sparse matrix.

Another very basic function is @dfn{nnz} that returns the number of
non-zero entries there are in a sparse matrix, while the function
@dfn{nzmax} returns the amount of storage allocated to the sparse
matrix.  Note that Octave tends to crop unused memory at the first
opportunity for sparse objects.  There are some cases of user created
sparse objects where the value returned by @dfn{nzmax} will not be
the same as @dfn{nnz}, but in general they will give the same
result.  The function @dfn{spstats} returns some basic statistics on
the columns of a sparse matrix including the number of elements, the
mean and the variance of each column.

@c ./DLD-FUNCTIONS/sparse.cc
@anchor{doc-issparse}
@deftypefn {Loadable Function} {} issparse (@var{expr})
Return 1 if the value of the expression @var{expr} is a sparse matrix.
@end deftypefn


@c data.cc
@anchor{doc-nnz}
@deftypefn {Built-in Function} {@var{scalar} =} nnz (@var{a})
Returns the number of non zero elements in @var{a}.
@seealso{@ref{doc-sparse,,sparse}}
@end deftypefn


@c ./sparse/nonzeros.m
@anchor{doc-nonzeros}
@deftypefn {Function File} {} nonzeros (@var{s})
Returns a vector of the non-zero values of the sparse matrix @var{s}.
@end deftypefn


@c data.cc
@anchor{doc-nzmax}
@deftypefn {Built-in Function} {@var{scalar} =} nzmax (@var{SM})
Return the amount of storage allocated to the sparse matrix @var{SM}.
Note that Octave tends to crop unused memory at the first opportunity
for sparse objects.  There are some cases of user created sparse objects
where the value returned by @dfn{nzmax} will not be the same as @dfn{nnz},
but in general they will give the same result.
@seealso{@ref{doc-sparse,,sparse}, @ref{doc-spalloc,,spalloc}}
@end deftypefn


@c ./sparse/spstats.m
@anchor{doc-spstats}
@deftypefn {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{s})
@deftypefnx {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{s}, @var{j})
Return the stats for the non-zero elements of the sparse matrix @var{s}.
@var{count} is the number of non-zeros in each column, @var{mean}
is the mean of the non-zeros in each column, and @var{var} is the  
variance of the non-zeros in each column.

Called with two input arguments, if @var{s} is the data and @var{j}
is the bin number for the data, compute the stats for each bin.  In 
this case, bins can contain data values of zero, whereas with 
@code{spstats (@var{s})} the zeros may disappear.
@end deftypefn


When solving linear equations involving sparse matrices Octave
determines the means to solve the equation based on the type of the
matrix as discussed in @ref{Sparse Linear Algebra}.  Octave probes the
matrix type when the div (/) or ldiv (\) operator is first used with
the matrix and then caches the type.  However the @dfn{matrix_type}
function can be used to determine the type of the sparse matrix prior
to use of the div or ldiv operators.  For example

@example
@group
a = tril (sprandn(1024, 1024, 0.02), -1) ...
    + speye(1024); 
matrix_type (a);
ans = Lower
@end group
@end example

show that Octave correctly determines the matrix type for lower
triangular matrices.  @dfn{matrix_type} can also be used to force
the type of a matrix to be a particular type.  For example

@example
@group
a = matrix_type (tril (sprandn (1024, ...
   1024, 0.02), -1) + speye(1024), 'Lower');
@end group
@end example

This allows the cost of determining the matrix type to be
avoided.  However, incorrectly defining the matrix type will result in
incorrect results from solutions of linear equations, and so it is
entirely the responsibility of the user to correctly identify the
matrix type

There are several graphical means of finding out information about
sparse matrices.  The first is the @dfn{spy} command, which displays
the structure of the non-zero elements of the
matrix.  @xref{fig:spmatrix}, for an example of the use of
@dfn{spy}.  More advanced graphical information can be obtained with the
@dfn{treeplot}, @dfn{etreeplot} and @dfn{gplot} commands.

@float Figure,fig:spmatrix
@center @image{spmatrix,4in}
@caption{Structure of simple sparse matrix.}
@end float

One use of sparse matrices is in graph theory, where the
interconnections between nodes are represented as an adjacency
matrix.  That is, if the i-th node in a graph is connected to the j-th
node.  Then the ij-th node (and in the case of undirected graphs the
ji-th node) of the sparse adjacency matrix is non-zero.  If each node
is then associated with a set of coordinates, then the @dfn{gplot}
command can be used to graphically display the interconnections
between nodes.

As a trivial example of the use of @dfn{gplot}, consider the example

@example
@group
A = sparse([2,6,1,3,2,4,3,5,4,6,1,5],
    [1,1,2,2,3,3,4,4,5,5,6,6],1,6,6);
xy = [0,4,8,6,4,2;5,0,5,7,5,7]';
gplot(A,xy)
@end group
@end example

which creates an adjacency matrix @code{A} where node 1 is connected
to nodes 2 and 6, node 2 with nodes 1 and 3, etc.  The coordinates of
the nodes are given in the n-by-2 matrix @code{xy}.
@ifset htmltex 
@xref{fig:gplot}.

@float Figure,fig:gplot
@center @image{gplot,4in}
@caption{Simple use of the @dfn{gplot} command.}
@end float
@end ifset

The dependencies between the nodes of a Cholesky factorization can be
calculated in linear time without explicitly needing to calculate the
Cholesky factorization by the @code{etree} command.  This command
returns the elimination tree of the matrix and can be displayed
graphically by the command @code{treeplot(etree(A))} if @code{A} is
symmetric or @code{treeplot(etree(A+A'))} otherwise.

@c ./sparse/spy.m
@anchor{doc-spy}
@deftypefn {Function File} {} spy (@var{x})
@deftypefnx {Function File} {} spy (@dots{}, @var{markersize})
@deftypefnx {Function File} {} spy (@dots{}, @var{line_spec})
Plot the sparsity pattern of the sparse matrix @var{x}.  If the argument
@var{markersize} is given as an scalar value, it is used to determine the
point size in the plot.  If the string @var{line_spec} is given it is
passed to @code{plot} and determines the appearance of the plot.
@seealso{@ref{doc-plot,,plot}}
@end deftypefn


@c ./DLD-FUNCTIONS/colamd.cc
@anchor{doc-etree}
@deftypefn {Loadable Function} {@var{p} =} etree (@var{s})
@deftypefnx {Loadable Function} {@var{p} =} etree (@var{s}, @var{typ})
@deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{s}, @var{typ})

Returns the elimination tree for the matrix @var{s}.  By default @var{s}
is assumed to be symmetric and the symmetric elimination tree is
returned.  The argument @var{typ} controls whether a symmetric or
column elimination tree is returned.  Valid values of @var{typ} are
'sym' or 'col', for symmetric or column elimination tree respectively

Called with a second argument, @dfn{etree} also returns the postorder
permutations on the tree.
@end deftypefn


@c ./sparse/etreeplot.m
@anchor{doc-etreeplot}
@deftypefn {Function File} {} etreeplot (@var{tree})
@deftypefnx {Function File} {} etreeplot (@var{tree}, @var{node_style}, @var{edge_style})
Plot the elimination tree of the matrix @var{s} or
@code{@var{s}+@var{s}'}  if @var{s} in non-symmetric.  The optional
parameters @var{line_style} and @var{edge_style} define the output
style.
@seealso{@ref{doc-treeplot,,treeplot}, @ref{doc-gplot,,gplot}}
@end deftypefn


@c ./sparse/gplot.m
@anchor{doc-gplot}
@deftypefn {Function File} {} gplot (@var{a}, @var{xy})
@deftypefnx {Function File} {} gplot (@var{a}, @var{xy}, @var{line_style})
@deftypefnx {Function File} {[@var{x}, @var{y}] =} gplot (@var{a}, @var{xy})
Plot a graph defined by @var{A} and @var{xy} in the graph theory
sense.  @var{A} is the adjacency matrix of the array to be plotted
and @var{xy} is an @var{n}-by-2 matrix containing the coordinates of
the nodes of the graph.

The optional parameter @var{line_style} defines the output style for
the plot.  Called with no output arguments the graph is plotted
directly.  Otherwise, return the coordinates of the plot in @var{x}
and @var{y}.
@seealso{@ref{doc-treeplot,,treeplot}, @ref{doc-etreeplot,,etreeplot}, @ref{doc-spy,,spy}}
@end deftypefn


@c ./sparse/treeplot.m
@anchor{doc-treeplot}
@deftypefn {Function File} {} treeplot (@var{tree})
@deftypefnx {Function File} {} treeplot (@var{tree}, @var{line_style}, @var{edge_style})
Produces a graph of tree or forest.  The first argument is vector of
predecessors, optional parameters @var{line_style} and @var{edge_style}
define the output style.  The complexity of the algorithm is O(n) in
terms of is time and memory requirements.
@seealso{@ref{doc-etreeplot,,etreeplot}, @ref{doc-gplot,,gplot}}
@end deftypefn


@c ./sparse/treelayout.m
@anchor{doc-treelayout}
@deftypefn {Function File} {} treelayout (@var{Tree})
@deftypefnx {Function File} {} treelayout (@var{Tree}, @var{permutation})
treelayout lays out a tree or a forest.  The first argument @var{Tree} is a vector of
predecessors, optional parameter @var{permutation} is an optional postorder permutation.
The complexity of the algorithm is O(n) in
terms of time and memory requirements.
@seealso{@ref{doc-etreeplot,,etreeplot}, @ref{doc-gplot,,gplot}, @ref{doc-treeplot,,treeplot}}
@end deftypefn


@node Operators and Functions
@subsection Basic Operators and Functions on Sparse Matrices

@menu
* Sparse Functions::            
* Return Types of Operators and Functions::  
* Mathematical Considerations::  
@end menu

@node Sparse Functions
@subsubsection Sparse Functions

An important consideration in the use of the sparse functions of
Octave is that many of the internal functions of Octave, such as
@dfn{diag}, cannot accept sparse matrices as an input.  The sparse
implementation in Octave therefore uses the @dfn{dispatch}
function to overload the normal Octave functions with equivalent
functions that work with sparse matrices.  However, at any time the
sparse matrix specific version of the function can be used by
explicitly calling its function name. 

The table below lists all of the sparse functions of Octave.  Note that
the names of the 
specific sparse forms of the functions are typically the same as
the general versions with a @dfn{sp} prefix.  In the table below, and the
rest of this article the specific sparse versions of the functions are
used.

@c Table includes in comments the missing sparse functions

@table @asis
@item Generate sparse matrices:
  @dfn{spalloc}, @dfn{spdiags}, @dfn{speye}, @dfn{sprand}, 
  @dfn{sprandn}, @dfn{sprandsym}

@item Sparse matrix conversion:
  @dfn{full}, @dfn{sparse}, @dfn{spconvert}

@item Manipulate sparse matrices
  @dfn{issparse}, @dfn{nnz}, @dfn{nonzeros}, @dfn{nzmax},
  @dfn{spfun}, @dfn{spones}, @dfn{spy}

@item Graph Theory:
  @dfn{etree}, @dfn{etreeplot}, @dfn{gplot}, 
  @dfn{treeplot}
@c @dfn{treelayout}

@item Sparse matrix reordering:
  @dfn{amd}, @dfn{ccolamd}, @dfn{colamd}, @dfn{colperm}, @dfn{csymamd},
  @dfn{dmperm}, @dfn{symamd}, @dfn{randperm}, @dfn{symrcm}

@item Linear algebra:
  @dfn{condest}, @dfn{eigs}, @dfn{matrix_type}, @dfn{normest}, @dfn{sprank},
  @dfn{spaugment}, @dfn{svds}

@item Iterative techniques:
  @dfn{luinc}, @dfn{pcg}, @dfn{pcr}
@c @dfn{bicg}, @dfn{bicgstab}, @dfn{cholinc}, @dfn{cgs}, @dfn{gmres}, 
@c @dfn{lsqr}, @dfn{minres}, @dfn{qmr}, @dfn{symmlq}

@item Miscellaneous:
  @dfn{spparms}, @dfn{symbfact}, @dfn{spstats}
@end table

In addition all of the standard Octave mapper functions (i.e., basic
math functions that take a single argument) such as @dfn{abs}, etc.
can accept sparse matrices.  The reader is referred to the documentation
supplied with these functions within Octave itself for further
details.

@node Return Types of Operators and Functions
@subsubsection The Return Types of Operators and Functions

The two basic reasons to use sparse matrices are to reduce the memory 
usage and to not have to do calculations on zero elements.  The two are
closely related in that the computation time on a sparse matrix operator
or function is roughly linear with the number of non-zero elements.

Therefore, there is a certain density of non-zero elements of a matrix 
where it no longer makes sense to store it as a sparse matrix, but rather
as a full matrix.  For this reason operators and functions that have a 
high probability of returning a full matrix will always return one.  For
example adding a scalar constant to a sparse matrix will almost always
make it a full matrix, and so the example

@example
@group
speye(3) + 0
@result{}   1  0  0
  0  1  0
  0  0  1
@end group
@end example

returns a full matrix as can be seen. 


Additionally, if @code{sparse_auto_mutate} is true, all sparse functions
test the amount of memory occupied by the sparse matrix to see if the
amount of storage used is larger than the amount used by the full
equivalent.  Therefore @code{speye (2) * 1} will return a full matrix as
the memory used is smaller for the full version than the sparse version.

As all of the mixed operators and functions between full and sparse 
matrices exist, in general this does not cause any problems.  However,
one area where it does cause a problem is where a sparse matrix is
promoted to a full matrix, where subsequent operations would resparsify
the matrix.  Such cases are rare, but can be artificially created, for
example @code{(fliplr(speye(3)) + speye(3)) - speye(3)} gives a full
matrix when it should give a sparse one.  In general, where such cases 
occur, they impose only a small memory penalty.

There is however one known case where this behavior of Octave's
sparse matrices will cause a problem.  That is in the handling of the
@dfn{diag} function.  Whether @dfn{diag} returns a sparse or full matrix
depending on the type of its input arguments.  So 

@example
 a = diag (sparse([1,2,3]), -1);
@end example

should return a sparse matrix.  To ensure this actually happens, the
@dfn{sparse} function, and other functions based on it like @dfn{speye}, 
always returns a sparse matrix, even if the memory used will be larger 
than its full representation.

@c ov-base.cc
@anchor{doc-sparse_auto_mutate}
@deftypefn {Built-in Function} {@var{val} =} sparse_auto_mutate ()
@deftypefnx {Built-in Function} {@var{old_val} =} sparse_auto_mutate (@var{new_val})
Query or set the internal variable that controls whether Octave will
automatically mutate sparse matrices to real matrices to save memory.
For example,

@example
@group
s = speye(3);
sparse_auto_mutate (false)
s (:, 1) = 1;
typeinfo (s)
@result{} sparse matrix
sparse_auto_mutate (true)
s (1, :) = 1;
typeinfo (s)
@result{} matrix
@end group
@end example
@end deftypefn


Note that the @code{sparse_auto_mutate} option is incompatible with
@sc{matlab}, and so it is off by default.

@node Mathematical Considerations
@subsubsection Mathematical Considerations

The attempt has been made to make sparse matrices behave in exactly the
same manner as there full counterparts.  However, there are certain differences
and especially differences with other products sparse implementations.

Firstly, the "./" and ".^" operators must be used with care.  Consider what
the examples

@example
@group
  s = speye (4);
  a1 = s .^ 2;
  a2 = s .^ s;
  a3 = s .^ -2;
  a4 = s ./ 2;
  a5 = 2 ./ s;
  a6 = s ./ s;
@end group
@end example

will give.  The first example of @var{s} raised to the power of 2 causes
no problems.  However @var{s} raised element-wise to itself involves a
large number of terms @code{0 .^ 0} which is 1. There @code{@var{s} .^
@var{s}} is a full matrix. 

Likewise @code{@var{s} .^ -2} involves terms like @code{0 .^ -2} which
is infinity, and so @code{@var{s} .^ -2} is equally a full matrix.

For the "./" operator @code{@var{s} ./ 2} has no problems, but 
@code{2 ./ @var{s}} involves a large number of infinity terms as well
and is equally a full matrix.  The case of @code{@var{s} ./ @var{s}}
involves terms like @code{0 ./ 0} which is a @code{NaN} and so this
is equally a full matrix with the zero elements of @var{s} filled with
@code{NaN} values.

The above behavior is consistent with full matrices, but is not 
consistent with sparse implementations in other products.

A particular problem of sparse matrices comes about due to the fact that
as the zeros are not stored, the sign-bit of these zeros is equally not
stored.  In certain cases the sign-bit of zero is important.  For example

@example
@group
 a = 0 ./ [-1, 1; 1, -1];
 b = 1 ./ a
 @result{} -Inf            Inf
     Inf           -Inf
 c = 1 ./ sparse (a)
 @result{}  Inf            Inf
     Inf            Inf
@end group
@end example
 
To correct this behavior would mean that zero elements with a negative
sign-bit would need to be stored in the matrix to ensure that their 
sign-bit was respected.  This is not done at this time, for reasons of
efficiency, and so the user is warned that calculations where the sign-bit
of zero is important must not be done using sparse matrices.

In general any function or operator used on a sparse matrix will
result in a sparse matrix with the same or a larger number of non-zero
elements than the original matrix.  This is particularly true for the
important case of sparse matrix factorizations.  The usual way to
address this is to reorder the matrix, such that its factorization is
sparser than the factorization of the original matrix.  That is the
factorization of @code{L * U = P * S * Q} has sparser terms @code{L}
and @code{U} than the equivalent factorization @code{L * U = S}.

Several functions are available to reorder depending on the type of the
matrix to be factorized.  If the matrix is symmetric positive-definite,
then @dfn{symamd} or @dfn{csymamd} should be used.  Otherwise
@dfn{amd}, @dfn{colamd} or @dfn{ccolamd} should be used.  For completeness
the reordering functions @dfn{colperm} and @dfn{randperm} are
also available.

@xref{fig:simplematrix}, for an example of the structure of a simple 
positive definite matrix.

@float Figure,fig:simplematrix
@center @image{spmatrix,4in}
@caption{Structure of simple sparse matrix.}
@end float

The standard Cholesky factorization of this matrix can be
obtained by the same command that would be used for a full
matrix.  This can be visualized with the command 
@code{r = chol(A); spy(r);}.
@ifset HAVE_CHOLMOD
@ifset HAVE_COLAMD
@xref{fig:simplechol}.
@end ifset
@end ifset
The original matrix had 
@ifinfo
@ifnothtml
43
@end ifnothtml
@end ifinfo
@ifset htmltex
598
@end ifset
non-zero terms, while this Cholesky factorization has
@ifinfo
@ifnothtml
71,
@end ifnothtml
@end ifinfo
@ifset htmltex
10200,
@end ifset
with only half of the symmetric matrix being stored.  This
is a significant level of fill in, and although not an issue
for such a small test case, can represents a large overhead 
in working with other sparse matrices.

The appropriate sparsity preserving permutation of the original
matrix is given by @dfn{symamd} and the factorization using this
reordering can be visualized using the command @code{q = symamd(A);
r = chol(A(q,q)); spy(r)}.  This gives 
@ifinfo
@ifnothtml
29
@end ifnothtml
@end ifinfo
@ifset htmltex
399
@end ifset
non-zero terms which is a significant improvement.

The Cholesky factorization itself can be used to determine the
appropriate sparsity preserving reordering of the matrix during the
factorization, In that case this might be obtained with three return
arguments as r@code{[r, p, q] = chol(A); spy(r)}.

@ifset HAVE_CHOLMOD
@ifset HAVE_COLAMD
@float Figure,fig:simplechol
@center @image{spchol,4in}
@caption{Structure of the un-permuted Cholesky factorization of the above matrix.}
@end float

@float Figure,fig:simplecholperm
@center @image{spcholperm,4in}
@caption{Structure of the permuted Cholesky factorization of the above matrix.}
@end float
@end ifset
@end ifset

In the case of an asymmetric matrix, the appropriate sparsity
preserving permutation is @dfn{colamd} and the factorization using
this reordering can be visualized using the command @code{q =
colamd(A); [l, u, p] = lu(A(:,q)); spy(l+u)}.

Finally, Octave implicitly reorders the matrix when using the div (/)
and ldiv (\) operators, and so no the user does not need to explicitly
reorder the matrix to maximize performance.

@c ./DLD-FUNCTIONS/amd.cc
@anchor{doc-amd}
@deftypefn {Loadable Function} {@var{p} =} amd (@var{s})
@deftypefnx {Loadable Function} {@var{p} =} amd (@var{s}, @var{opts})

Returns the approximate minimum degree permutation of a matrix.  This
permutation such that the Cholesky factorization of @code{@var{s} (@var{p},
@var{p})} tends to be sparser than the Cholesky factorization of @var{s}
itself.  @code{amd} is typically faster than @code{symamd} but serves a
similar purpose.

The optional parameter @var{opts} is a structure that controls the
behavior of @code{amd}.  The fields of these structure are

@table @asis
@item opts.dense
Determines what @code{amd} considers to be a dense row or column of the
input matrix.  Rows or columns with more than @code{max(16, (dense *
sqrt (@var{n})} entries, where @var{n} is the order of the matrix @var{s},
are ignored by @code{amd} during the calculation of the permutation
The value of dense must be a positive scalar and its default value is 10.0

@item opts.aggressive
If this value is a non zero scalar, then @code{amd} performs aggressive
absorption.  The default is not to perform aggressive absorption.
@end table

The author of the code itself is Timothy A. Davis (davis@@cise.ufl.edu),
University of Florida (see @url{http://www.cise.ufl.edu/research/sparse/amd}).
@seealso{@ref{doc-symamd,,symamd}, @ref{doc-colamd,,colamd}}
@end deftypefn


@c ./DLD-FUNCTIONS/ccolamd.cc
@anchor{doc-ccolamd}
@deftypefn {Loadable Function} {@var{p} =} ccolamd (@var{s})
@deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs})
@deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs}, @var{cmember})
@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} ccolamd (@dots{})

Constrained column approximate minimum degree permutation.  @code{@var{p} =
ccolamd (@var{s})} returns the column approximate minimum degree permutation
vector for the sparse matrix @var{s}.  For a non-symmetric matrix @var{s},
@code{@var{s} (:, @var{p})} tends to have sparser LU factors than @var{s}.
@code{chol (@var{s} (:, @var{p})' * @var{s} (:, @var{p}))} also tends to be
sparser than @code{chol (@var{s}' * @var{s})}.  @code{@var{p} = ccolamd
(@var{s}, 1)} optimizes the ordering for @code{lu (@var{s} (:, @var{p}))}.
The ordering is followed by a column elimination tree post-ordering.

@var{knobs} is an optional one- to five-element input vector, with a default
value of @code{[0 10 10 1 0]} if not present or empty.  Entries not present
are set to their defaults.

@table @code
@item @var{knobs}(1)
if nonzero, the ordering is optimized for @code{lu (S (:, p))}.  It will be a
poor ordering for @code{chol (@var{s} (:, @var{p})' * @var{s} (:,
@var{p}))}.  This is the most important knob for ccolamd.

@item @var{knob}(2)
if @var{s} is m-by-n, rows with more than @code{max (16, @var{knobs} (2) *
sqrt (n))} entries are ignored.

@item @var{knob}(3)
columns with more than @code{max (16, @var{knobs} (3) * sqrt (min (@var{m},
@var{n})))} entries are ignored and ordered last in the output permutation
(subject to the cmember constraints).

@item @var{knob}(4)
if nonzero, aggressive absorption is performed.

@item @var{knob}(5)
if nonzero, statistics and knobs are printed.

@end table

@var{cmember} is an optional vector of length n.  It defines the constraints
on the column ordering.  If @code{@var{cmember} (j) = @var{c}}, then column
@var{j} is in constraint set @var{c} (@var{c} must be in the range 1 to
@var{n}).  In the output permutation @var{p}, all columns in set 1 appear
first, followed by all columns in set 2, and so on.  @code{@var{cmember} =
ones(1,n)} if not present or empty.  @code{ccolamd (@var{s}, [], 1 :
@var{n})} returns @code{1 : @var{n}}

@code{@var{p} = ccolamd (@var{s})} is about the same as @code{@var{p} =
colamd (@var{s})}.  @var{knobs} and its default values differ.  @code{colamd}
always does aggressive absorption, and it finds an ordering suitable for
both @code{lu (@var{s} (:, @var{p}))} and @code{chol (@var{S} (:, @var{p})'
* @var{s} (:, @var{p}))}; it cannot optimize its ordering for
@code{lu (@var{s} (:, @var{p}))} to the extent that
@code{ccolamd (@var{s}, 1)} can.

@var{stats} is an optional 20-element output vector that provides data
about the ordering and the validity of the input matrix @var{s}.  Ordering
statistics are in @code{@var{stats} (1 : 3)}.  @code{@var{stats} (1)} and
@code{@var{stats} (2)} are the number of dense or empty rows and columns
ignored by CCOLAMD and @code{@var{stats} (3)} is the number of garbage
collections performed on the internal data structure used by CCOLAMD
(roughly of size @code{2.2 * nnz (@var{s}) + 4 * @var{m} + 7 * @var{n}}
integers).

@code{@var{stats} (4 : 7)} provide information if CCOLAMD was able to
continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if
invalid.  @code{@var{stats} (5)} is the rightmost column index that is
unsorted or contains duplicate entries, or zero if no such column exists.
@code{@var{stats} (6)} is the last seen duplicate or out-of-order row
index in the column index given by @code{@var{stats} (5)}, or zero if no
such row index exists.  @code{@var{stats} (7)} is the number of duplicate
or out-of-order row indices.  @code{@var{stats} (8 : 20)} is always zero in
the current version of CCOLAMD (reserved for future use).

The authors of the code itself are S. Larimore, T. Davis (Uni of Florida)
and S. Rajamanickam in collaboration with J. Bilbert and E. Ng.  Supported
by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),
and a grant from Sandia National Lab.  See
@url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,
colamd, symamd, and other related orderings.
@seealso{@ref{doc-colamd,,colamd}, @ref{doc-csymamd,,csymamd}}
@end deftypefn


@c ./DLD-FUNCTIONS/colamd.cc
@anchor{doc-colamd}
@deftypefn {Loadable Function} {@var{p} =} colamd (@var{s})
@deftypefnx {Loadable Function} {@var{p} =} colamd (@var{s}, @var{knobs})
@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{s})
@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{s}, @var{knobs})

Column approximate minimum degree permutation.  @code{@var{p} = colamd
(@var{s})} returns the column approximate minimum degree permutation
vector for the sparse matrix @var{s}.  For a non-symmetric matrix @var{s},
@code{@var{s} (:,@var{p})} tends to have sparser LU factors than @var{s}.
The Cholesky factorization of @code{@var{s} (:,@var{p})' * @var{s}
(:,@var{p})} also tends to be sparser than that of @code{@var{s}' *
@var{s}}.

@var{knobs} is an optional one- to three-element input vector.  If @var{s} is
m-by-n, then rows with more than @code{max(16,@var{knobs}(1)*sqrt(n))} entries
are ignored.  Columns with more than @code{max(16,knobs(2)*sqrt(min(m,n)))}
entries are removed prior to ordering, and ordered last in the output
permutation @var{p}.  Only completely dense rows or columns are removed
if @code{@var{knobs} (1)} and @code{@var{knobs} (2)} are < 0, respectively.
If @code{@var{knobs} (3)} is nonzero, @var{stats} and @var{knobs} are
printed.  The default is @code{@var{knobs} = [10 10 0]}.  Note that
@var{knobs} differs from earlier versions of colamd

@var{stats} is an optional 20-element output vector that provides data
about the ordering and the validity of the input matrix @var{s}.  Ordering
statistics are in @code{@var{stats} (1:3)}.  @code{@var{stats} (1)} and
@code{@var{stats} (2)} are the number of dense or empty rows and columns
ignored by COLAMD and @code{@var{stats} (3)} is the number of garbage
collections performed on the internal data structure used by COLAMD
(roughly of size @code{2.2 * nnz(@var{s}) + 4 * @var{m} + 7 * @var{n}}
integers).

Octave built-in functions are intended to generate valid sparse matrices,
with no duplicate entries, with ascending row indices of the nonzeros
in each column, with a non-negative number of entries in each column (!)
and so on.  If a matrix is invalid, then COLAMD may or may not be able
to continue.  If there are duplicate entries (a row index appears two or
more times in the same column) or if the row indices in a column are out
of order, then COLAMD can correct these errors by ignoring the duplicate
entries and sorting each column of its internal copy of the matrix
@var{s} (the input matrix @var{s} is not repaired, however).  If a matrix
is invalid in other ways then COLAMD cannot continue, an error message is
printed, and no output arguments (@var{p} or @var{stats}) are returned.
COLAMD is thus a simple way to check a sparse matrix to see if it's
valid.

@code{@var{stats} (4:7)} provide information if COLAMD was able to
continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if
invalid.  @code{@var{stats} (5)} is the rightmost column index that is
unsorted or contains duplicate entries, or zero if no such column exists.
@code{@var{stats} (6)} is the last seen duplicate or out-of-order row
index in the column index given by @code{@var{stats} (5)}, or zero if no
such row index exists.  @code{@var{stats} (7)} is the number of duplicate
or out-of-order row indices.  @code{@var{stats} (8:20)} is always zero in
the current version of COLAMD (reserved for future use).

The ordering is followed by a column elimination tree post-ordering.

The authors of the code itself are Stefan I. Larimore and Timothy A.
Davis (davis@@cise.ufl.edu), University of Florida.  The algorithm was
developed in collaboration with John Gilbert, Xerox PARC, and Esmond
Ng, Oak Ridge National Laboratory.  (see
@url{http://www.cise.ufl.edu/research/sparse/colamd})
@seealso{@ref{doc-colperm,,colperm}, @ref{doc-symamd,,symamd}}
@end deftypefn


@c ./sparse/colperm.m
@anchor{doc-colperm}
@deftypefn {Function File} {@var{p} =} colperm (@var{s})
Returns the column permutations such that the columns of
@code{@var{s} (:, @var{p})} are ordered in terms of increase number
of non-zero elements.  If @var{s} is symmetric, then @var{p} is chosen
such that @code{@var{s} (@var{p}, @var{p})} orders the rows and
columns with increasing number of non zeros elements.
@end deftypefn


@c ./DLD-FUNCTIONS/ccolamd.cc
@anchor{doc-csymamd}
@deftypefn {Loadable Function} {@var{p} =} csymamd (@var{s})
@deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{s}, @var{knobs})
@deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{s}, @var{knobs}, @var{cmember})
@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} csymamd (@dots{})

For a symmetric positive definite matrix @var{s}, returns the permutation
vector @var{p} such that @code{@var{s}(@var{p},@var{p})} tends to have a
sparser Cholesky factor than @var{s}.  Sometimes @code{csymamd} works well
for symmetric indefinite matrices too.  The matrix @var{s} is assumed to
be symmetric; only the strictly lower triangular part is referenced.
@var{s} must be square.  The ordering is followed by an elimination tree
post-ordering.

@var{knobs} is an optional one- to three-element input vector, with a
default value of @code{[10 1 0]} if present or empty.  Entries not
present are set to their defaults.

@table @code
@item @var{knobs}(1)
If @var{s} is n-by-n, then rows and columns with more than
@code{max(16,@var{knobs}(1)*sqrt(n))} entries are ignored, and ordered
last in the output permutation (subject to the cmember constraints).

@item @var{knobs}(2)
If nonzero, aggressive absorption is performed.

@item @var{knobs}(3)
If nonzero, statistics and knobs are printed.

@end table

@var{cmember} is an optional vector of length n. It defines the constraints
on the ordering.  If @code{@var{cmember}(j) = @var{s}}, then row/column j is
in constraint set @var{c} (@var{c} must be in the range 1 to n).  In the
output permutation @var{p}, rows/columns in set 1 appear first, followed
by all rows/columns in set 2, and so on.  @code{@var{cmember} = ones(1,n)}
if not present or empty.  @code{csymamd(@var{s},[],1:n)} returns @code{1:n}.

@code{@var{p} = csymamd(@var{s})} is about the same as @code{@var{p} =
symamd(@var{s})}.  @var{knobs} and its default values differ.

@code{@var{stats} (4:7)} provide information if CCOLAMD was able to
continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if
invalid.  @code{@var{stats} (5)} is the rightmost column index that is
unsorted or contains duplicate entries, or zero if no such column exists.
@code{@var{stats} (6)} is the last seen duplicate or out-of-order row
index in the column index given by @code{@var{stats} (5)}, or zero if no
such row index exists.  @code{@var{stats} (7)} is the number of duplicate
or out-of-order row indices.  @code{@var{stats} (8:20)} is always zero in
the current version of CCOLAMD (reserved for future use).

The authors of the code itself are S. Larimore, T. Davis (Uni of Florida)
and S. Rajamanickam in collaboration with J. Bilbert and E. Ng.  Supported
by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),
and a grant from Sandia National Lab.  See
@url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,
colamd, symamd, and other related orderings.
@seealso{@ref{doc-symamd,,symamd}, @ref{doc-ccolamd,,ccolamd}}
@end deftypefn


@c ./DLD-FUNCTIONS/dmperm.cc
@anchor{doc-dmperm}
@deftypefn {Loadable Function} {@var{p} =} dmperm (@var{s})
@deftypefnx {Loadable Function} {[@var{p}, @var{q}, @var{r}, @var{s}] =} dmperm (@var{s})

@cindex Dulmage-Mendelsohn decomposition
Perform a Dulmage-Mendelsohn permutation on the sparse matrix @var{s}.
With a single output argument @dfn{dmperm} performs the row permutations
@var{p} such that @code{@var{s} (@var{p},:)} has no zero elements on the
diagonal.

Called with two or more output arguments, returns the row and column
permutations, such that @code{@var{s} (@var{p}, @var{q})} is in block
triangular form.  The values of @var{r} and @var{s} define the boundaries
of the blocks.  If @var{s} is square then @code{@var{r} == @var{s}}.

The method used is described in: A. Pothen & C.-J. Fan. Computing the block
triangular form of a sparse matrix. ACM Trans. Math. Software,
16(4):303-324, 1990.
@seealso{@ref{doc-colamd,,colamd}, @ref{doc-ccolamd,,ccolamd}}
@end deftypefn


@c ./DLD-FUNCTIONS/colamd.cc
@anchor{doc-symamd}
@deftypefn {Loadable Function} {@var{p} =} symamd (@var{s})
@deftypefnx {Loadable Function} {@var{p} =} symamd (@var{s}, @var{knobs})
@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{s})
@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{s}, @var{knobs})

For a symmetric positive definite matrix @var{s}, returns the permutation
vector p such that @code{@var{s} (@var{p}, @var{p})} tends to have a
sparser Cholesky factor than @var{s}.  Sometimes SYMAMD works well for
symmetric indefinite matrices too.  The matrix @var{s} is assumed to be
symmetric; only the strictly lower triangular part is referenced.  @var{s}
must be square.

@var{knobs} is an optional one- to two-element input vector.  If @var{s} is
n-by-n, then rows and columns with more than
@code{max(16,@var{knobs}(1)*sqrt(n))} entries are removed prior to ordering,
and ordered last in the output permutation @var{p}.  No rows/columns are
removed if @code{@var{knobs}(1) < 0}.  If @code{@var{knobs} (2)} is nonzero,
@code{stats} and @var{knobs} are printed.  The default is @code{@var{knobs} 
= [10 0]}.  Note that @var{knobs} differs from earlier versions of symamd.

@var{stats} is an optional 20-element output vector that provides data
about the ordering and the validity of the input matrix @var{s}.  Ordering
statistics are in @code{@var{stats} (1:3)}.  @code{@var{stats} (1) =
@var{stats} (2)} is the number of dense or empty rows and columns
ignored by SYMAMD and @code{@var{stats} (3)} is the number of garbage
collections performed on the internal data structure used by SYMAMD
(roughly of size @code{8.4 * nnz (tril (@var{s}, -1)) + 9 * @var{n}}
integers).

Octave built-in functions are intended to generate valid sparse matrices,
with no duplicate entries, with ascending row indices of the nonzeros
in each column, with a non-negative number of entries in each column (!)
and so on.  If a matrix is invalid, then SYMAMD may or may not be able
to continue.  If there are duplicate entries (a row index appears two or
more times in the same column) or if the row indices in a column are out
of order, then SYMAMD can correct these errors by ignoring the duplicate
entries and sorting each column of its internal copy of the matrix S (the
input matrix S is not repaired, however).  If a matrix is invalid in
other ways then SYMAMD cannot continue, an error message is printed, and
no output arguments (@var{p} or @var{stats}) are returned.  SYMAMD is
thus a simple way to check a sparse matrix to see if it's valid.

@code{@var{stats} (4:7)} provide information if SYMAMD was able to
continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1
if invalid.  @code{@var{stats} (5)} is the rightmost column index that
is unsorted or contains duplicate entries, or zero if no such column
exists.  @code{@var{stats} (6)} is the last seen duplicate or out-of-order
row index in the column index given by @code{@var{stats} (5)}, or zero
if no such row index exists.  @code{@var{stats} (7)} is the number of
duplicate or out-of-order row indices.  @code{@var{stats} (8:20)} is
always zero in the current version of SYMAMD (reserved for future use).

The ordering is followed by a column elimination tree post-ordering.


The authors of the code itself are Stefan I. Larimore and Timothy A.
Davis (davis@@cise.ufl.edu), University of Florida.  The algorithm was
developed in collaboration with John Gilbert, Xerox PARC, and Esmond
Ng, Oak Ridge National Laboratory.  (see
@url{http://www.cise.ufl.edu/research/sparse/colamd})
@seealso{@ref{doc-colperm,,colperm}, @ref{doc-colamd,,colamd}}
@end deftypefn


@c ./DLD-FUNCTIONS/symrcm.cc
@anchor{doc-symrcm}
@deftypefn {Loadable Function} {@var{p} =} symrcm (@var{S})
Symmetric reverse Cuthill-McKee permutation of @var{S}.
Return a permutation vector @var{p} such that
@code{@var{S} (@var{p}, @var{p})} tends to have its diagonal elements
closer to the diagonal than @var{S}.  This is a good preordering for LU
or Cholesky factorization of matrices that come from 'long, skinny'
problems.  It works for both symmetric and asymmetric @var{S}.

The algorithm represents a heuristic approach to the NP-complete
bandwidth minimization problem.  The implementation is based in the
descriptions found in

E. Cuthill, J. McKee: Reducing the Bandwidth of Sparse Symmetric
Matrices. Proceedings of the 24th ACM National Conference, 157--172
1969, Brandon Press, New Jersey.

Alan George, Joseph W. H. Liu: Computer Solution of Large Sparse
Positive Definite Systems, Prentice Hall Series in Computational
Mathematics, ISBN 0-13-165274-5, 1981.

@seealso{@ref{doc-colperm,,colperm}, @ref{doc-colamd,,colamd}, @ref{doc-symamd,,symamd}}
@end deftypefn


@node Sparse Linear Algebra
@section Linear Algebra on Sparse Matrices

Octave includes a polymorphic solver for sparse matrices, where 
the exact solver used to factorize the matrix, depends on the properties
of the sparse matrix itself.  Generally, the cost of determining the matrix type
is small relative to the cost of factorizing the matrix itself, but in any
case the matrix type is cached once it is calculated, so that it is not
re-determined each time it is used in a linear equation.

The selection tree for how the linear equation is solve is

@enumerate 1
@item If the matrix is diagonal, solve directly and goto 8

@item If the matrix is a permuted diagonal, solve directly taking into
account the permutations.  Goto 8

@item If the matrix is square, banded and if the band density is less
than that given by @code{spparms ("bandden")} continue, else goto 4.

@enumerate a
@item If the matrix is tridiagonal and the right-hand side is not sparse 
continue, else goto 3b.

@enumerate
@item If the matrix is hermitian, with a positive real diagonal, attempt
      Cholesky factorization using @sc{lapack} xPTSV.

@item If the above failed or the matrix is not hermitian with a positive
      real diagonal use Gaussian elimination with pivoting using 
      @sc{lapack} xGTSV, and goto 8.
@end enumerate

@item If the matrix is hermitian with a positive real diagonal, attempt
      Cholesky factorization using @sc{lapack} xPBTRF.

@item if the above failed or the matrix is not hermitian with a positive
      real diagonal use Gaussian elimination with pivoting using 
      @sc{lapack} xGBTRF, and goto 8.
@end enumerate

@item If the matrix is upper or lower triangular perform a sparse forward
or backward substitution, and goto 8

@item If the matrix is a upper triangular matrix with column permutations
or lower triangular matrix with row permutations, perform a sparse forward 
or backward substitution, and goto 8

@item If the matrix is square, hermitian with a real positive diagonal, attempt
sparse Cholesky factorization using CHOLMOD.

@item If the sparse Cholesky factorization failed or the matrix is not
hermitian with a real positive diagonal, and the matrix is square, factorize 
using UMFPACK.

@item If the matrix is not square, or any of the previous solvers flags
a singular or near singular matrix, find a minimum norm solution using
CXSPARSE@footnote{The CHOLMOD, UMFPACK and CXSPARSE packages were
written by Tim Davis and are available at
http://www.cise.ufl.edu/research/sparse/}.
@end enumerate

The band density is defined as the number of non-zero values in the matrix
divided by the number of non-zero values in the matrix.  The banded matrix
solvers can be entirely disabled by using @dfn{spparms} to set @code{bandden}
to 1 (i.e., @code{spparms ("bandden", 1)}).

The QR solver factorizes the problem with a Dulmage-Mendelsohn, to
separate the problem into blocks that can be treated as over-determined,
multiple well determined blocks, and a final over-determined block.  For
matrices with blocks of strongly connected nodes this is a big win as
LU decomposition can be used for many blocks.  It also significantly
improves the chance of finding a solution to over-determined problems
rather than just returning a vector of @dfn{NaN}'s.

All of the solvers above, can calculate an estimate of the condition
number.  This can be used to detect numerical stability problems in the
solution and force a minimum norm solution to be used.  However, for
narrow banded, triangular or diagonal matrices, the cost of
calculating the condition number is significant, and can in fact
exceed the cost of factoring the matrix.  Therefore the condition
number is not calculated in these cases, and Octave relies on simpler
techniques to detect singular matrices or the underlying @sc{lapack} code in
the case of banded matrices.

The user can force the type of the matrix with the @code{matrix_type}
function.  This overcomes the cost of discovering the type of the matrix.
However, it should be noted that identifying the type of the matrix incorrectly
will lead to unpredictable results, and so @code{matrix_type} should be
used with care.

@c ./sparse/normest.m
@anchor{doc-normest}
@deftypefn {Function File} {[@var{n}, @var{c}] =} normest (@var{a}, @var{tol})
Estimate the 2-norm of the matrix @var{a} using a power series
analysis.  This is typically used for large matrices, where the cost
of calculating the @code{norm (@var{a})} is prohibitive and an approximation
to the 2-norm is acceptable.

@var{tol} is the tolerance to which the 2-norm is calculated.  By default
@var{tol} is 1e-6.  @var{c} returns the number of iterations needed for
@code{normest} to converge.
@end deftypefn


@c ./linear-algebra/onenormest.m
@anchor{doc-onenormest}
@deftypefn {Function File} {[@var{est}, @var{v}, @var{w}, @var{iter}] =} onenormest (@var{a}, @var{t}) 
@deftypefnx {Function File} {[@var{est}, @var{v}, @var{w}, @var{iter}] =} onenormest (@var{apply}, @var{apply_t}, @var{n}, @var{t})

Apply Higham and Tisseur's randomized block 1-norm estimator to
matrix @var{a} using @var{t} test vectors.  If @var{t} exceeds 5, then
only 5 test vectors are used.

If the matrix is not explicit, e.g., when estimating the norm of 
@code{inv (@var{A})} given an LU factorization, @code{onenormest} applies 
@var{A} and its conjugate transpose through a pair of functions 
@var{apply} and @var{apply_t}, respectively, to a dense matrix of size 
@var{n} by @var{t}.  The implicit version requires an explicit dimension 
@var{n}.

Returns the norm estimate @var{est}, two vectors @var{v} and
@var{w} related by norm
@code{(@var{w}, 1) = @var{est} * norm (@var{v}, 1)},
and the number of iterations @var{iter}.  The number of
iterations is limited to 10 and is at least 2.

References: 
@itemize
@item Nicholas J. Higham and Françoise Tisseur, "A Block Algorithm
for Matrix 1-Norm Estimation, with an Application to 1-Norm
Pseudospectra." SIMAX vol 21, no 4, pp 1185-1201.
@url{http://dx.doi.org/10.1137/S0895479899356080}
@item Nicholas J. Higham and Françoise Tisseur, "A Block Algorithm
for Matrix 1-Norm Estimation, with an Application to 1-Norm
Pseudospectra." @url{http://citeseer.ist.psu.edu/223007.html}
@end itemize

@seealso{@ref{doc-condest,,condest}, @ref{doc-norm,,norm}, @ref{doc-cond,,cond}}
@end deftypefn


@c ./linear-algebra/condest.m
@anchor{doc-condest}
@deftypefn {Function File} {[@var{est}, @var{v}] =} condest (@var{a}, @var{t}) 
@deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@var{a}, @var{solve}, @var{solve_t}, @var{t})
@deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@var{apply}, @var{apply_t}, @var{solve}, @var{solve_t}, @var{n}, @var{t})

Estimate the 1-norm condition number of a matrix @var{A}
using @var{t} test vectors using a randomized 1-norm estimator.
If @var{t} exceeds 5, then only 5 test vectors are used.

If the matrix is not explicit, e.g., when estimating the condition 
number of @var{a} given an LU factorization, @code{condest} uses the 
following functions:

@table @var
@item apply
@code{A*x} for a matrix @code{x} of size @var{n} by @var{t}.
@item apply_t
@code{A'*x} for a matrix @code{x} of size @var{n} by @var{t}.
@item solve
@code{A \ b} for a matrix @code{b} of size @var{n} by @var{t}.
@item solve_t
@code{A' \ b} for a matrix @code{b} of size @var{n} by @var{t}.
@end table

The implicit version requires an explicit dimension @var{n}.

@code{condest} uses a randomized algorithm to approximate
the 1-norms.

@code{condest} returns the 1-norm condition estimate @var{est} and
a vector @var{v} satisfying @code{norm (A*v, 1) == norm (A, 1) * norm
(@var{v}, 1) / @var{est}}.  When @var{est} is large, @var{v} is an
approximate null vector.

References: 
@itemize
@item Nicholas J. Higham and Françoise Tisseur, "A Block Algorithm
for Matrix 1-Norm Estimation, with an Application to 1-Norm
Pseudospectra." SIMAX vol 21, no 4, pp 1185-1201.
@url{http://dx.doi.org/10.1137/S0895479899356080}
@item Nicholas J. Higham and Françoise Tisseur, "A Block Algorithm
for Matrix 1-Norm Estimation, with an Application to 1-Norm
Pseudospectra." @url{http://citeseer.ist.psu.edu/223007.html}
@end itemize

@seealso{@ref{doc-cond,,cond}, @ref{doc-norm,,norm}, @ref{doc-onenormest,,onenormest}}
@end deftypefn


@c ./DLD-FUNCTIONS/spparms.cc
@anchor{doc-spparms}
@deftypefn {Loadable Function} { } spparms ()
@deftypefnx {Loadable Function} {@var{vals} =} spparms ()
@deftypefnx {Loadable Function} {[@var{keys}, @var{vals}] =} spparms ()
@deftypefnx {Loadable Function} {@var{val} =} spparms (@var{key})
@deftypefnx {Loadable Function} { } spparms (@var{vals})
@deftypefnx {Loadable Function} { } spparms ('defaults')
@deftypefnx {Loadable Function} { } spparms ('tight')
@deftypefnx {Loadable Function} { } spparms (@var{key}, @var{val})
Sets or displays the parameters used by the sparse solvers and factorization
functions.  The first four calls above get information about the current
settings, while the others change the current settings.  The parameters are
stored as pairs of keys and values, where the values are all floats and the
keys are one of the following strings:

@table @code
@item spumoni
Printing level of debugging information of the solvers (default 0)
@item ths_rel
Included for compatibility.  Not used.  (default 1)
@item ths_abs
Included for compatibility.  Not used.  (default 1)
@item exact_d
Included for compatibility.  Not used.  (default 0)
@item supernd
Included for compatibility.  Not used.  (default 3)
@item rreduce
Included for compatibility.  Not used.  (default 3)
@item wh_frac
Included for compatibility.  Not used.  (default 0.5)
@item autommd
Flag whether the LU/QR and the '\' and '/' operators will automatically
use the sparsity preserving mmd functions (default 1)
@item autoamd
Flag whether the LU and the '\' and '/' operators will automatically
use the sparsity preserving amd functions (default 1)
@item piv_tol
The pivot tolerance of the UMFPACK solvers (default 0.1)
@item sym_tol
The pivot tolerance of the UMFPACK symmetric solvers (default 0.001)
@item bandden
The density of non-zero elements in a banded matrix before it is treated
by the @sc{lapack} banded solvers (default 0.5)
@item umfpack
Flag whether the UMFPACK or mmd solvers are used for the LU, '\' and
'/' operations (default 1)
@end table

The value of individual keys can be set with @code{spparms (@var{key},
@var{val})}.  The default values can be restored with the special keyword
'defaults'.  The special keyword 'tight' can be used to set the mmd solvers
to attempt for a sparser solution at the potential cost of longer running
time.
@end deftypefn


@c ./DLD-FUNCTIONS/dmperm.cc
@anchor{doc-sprank}
@deftypefn {Loadable Function} {@var{p} =} sprank (@var{s})

@cindex Structural Rank
Calculates the structural rank of a sparse matrix @var{s}.  Note that
only the structure of the matrix is used in this calculation based on
a Dulmage-Mendelsohn permutation to block triangular form.  As such the numerical
rank of the matrix @var{s} is bounded by @code{sprank (@var{s}) >=
rank (@var{s})}.  Ignoring floating point errors @code{sprank (@var{s}) ==
rank (@var{s})}.
@seealso{@ref{doc-dmperm,,dmperm}}
@end deftypefn


@c ./DLD-FUNCTIONS/symbfact.cc
@anchor{doc-symbfact}
@deftypefn {Loadable Function} {[@var{count}, @var{h}, @var{parent}, @var{post}, @var{r}] =} symbfact (@var{s}, @var{typ}, @var{mode})

Performs a symbolic factorization analysis on the sparse matrix @var{s}.
Where

@table @asis
@item @var{s}
@var{s} is a complex or real sparse matrix.

@item @var{typ}
Is the type of the factorization and can be one of

@table @code
@item sym
Factorize @var{s}.  This is the default.

@item col
Factorize @code{@var{s}' * @var{s}}.
@item row
Factorize @code{@var{s} * @var{s}'}.
@item lo
Factorize @code{@var{s}'}
@end table

@item @var{mode}
The default is to return the Cholesky factorization for @var{r}, and if
@var{mode} is 'L', the conjugate transpose of the Cholesky factorization
is returned.  The conjugate transpose version is faster and uses less
memory, but returns the same values for @var{count}, @var{h}, @var{parent}
and @var{post} outputs.
@end table

The output variables are

@table @asis
@item @var{count}
The row counts of the Cholesky factorization as determined by @var{typ}.

@item @var{h}
The height of the elimination tree.

@item @var{parent}
The elimination tree itself.

@item @var{post}
A sparse boolean matrix whose structure is that of the Cholesky
factorization as determined by @var{typ}.
@end table
@end deftypefn


For non square matrices, the user can also utilize the @code{spaugment}
function to find a least squares solution to a linear equation.

@c ./sparse/spaugment.m
@anchor{doc-spaugment}
@deftypefn {Function File} {@var{s} =} spaugment (@var{a}, @var{c})
Creates the augmented matrix of @var{a}.  This is given by

@example
@group
[@var{c} * eye(@var{m}, @var{m}),@var{a}; @var{a}', zeros(@var{n},
@var{n})]
@end group
@end example

@noindent
This is related to the least squares solution of 
@code{@var{a} \\ @var{b}}, by

@example
@group
@var{s} * [ @var{r} / @var{c}; x] = [@var{b}, zeros(@var{n},
columns(@var{b})]
@end group
@end example

@noindent
where @var{r} is the residual error

@example
@var{r} = @var{b} - @var{a} * @var{x}
@end example

As the matrix @var{s} is symmetric indefinite it can be factorized
with @code{lu}, and the minimum norm solution can therefore be found
without the need for a @code{qr} factorization.  As the residual
error will be @code{zeros (@var{m}, @var{m})} for under determined
problems, and example can be 

@example
@group
m = 11; n = 10; mn = max(m ,n);
a = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
             [-1, 0, 1], m, n);
x0 = a \ ones (m,1);
s = spaugment (a);
[L, U, P, Q] = lu (s);
x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
x1 = x1(end - n + 1 : end);
@end group
@end example

To find the solution of an overdetermined problem needs an estimate
of the residual error @var{r} and so it is more complex to formulate
a minimum norm solution using the @code{spaugment} function.

In general the left division operator is more stable and faster than
using the @code{spaugment} function.
@end deftypefn


Finally, the function @code{eigs} can be used to calculate a limited
number of eigenvalues and eigenvectors based on a selection criteria
and likewise for @code{svds} which calculates a limited number of
singular values and vectors.

@c ./DLD-FUNCTIONS/eigs.cc
@anchor{doc-eigs}
@deftypefn {Loadable Function} {@var{d}} = eigs (@var{a})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{a}, @var{k})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{a}, @var{k}, @var{sigma})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{a}, @var{k}, @var{sigma},@var{opts})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{a}, @var{b})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{a}, @var{b}, @var{k})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{a}, @var{b}, @var{k}, @var{sigma})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{a}, @var{b}, @var{k}, @var{sigma}, @var{opts})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{af}, @var{n})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{af}, @var{n}, @var{b})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{af}, @var{n}, @var{k})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{af}, @var{n}, @var{b}, @var{k})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{af}, @var{n}, @var{k}, @var{sigma})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{af}, @var{n}, @var{b}, @var{k}, @var{sigma})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{af}, @var{n}, @var{k}, @var{sigma}, @var{opts})
@deftypefnx {Loadable Function} {@var{d}} = eigs (@var{af}, @var{n}, @var{b}, @var{k}, @var{sigma}, @var{opts})
@deftypefnx {Loadable Function} {[@var{v}, @var{d}]} = eigs (@var{a}, @dots{})
@deftypefnx {Loadable Function} {[@var{v}, @var{d}]} = eigs (@var{af}, @var{n}, @dots{})
@deftypefnx {Loadable Function} {[@var{v}, @var{d}, @var{flag}]} = eigs (@var{a}, @dots{})
@deftypefnx {Loadable Function} {[@var{v}, @var{d}, @var{flag}]} = eigs (@var{af}, @var{n}, @dots{})
Calculate a limited number of eigenvalues and eigenvectors of @var{a},
based on a selection criteria.  The number eigenvalues and eigenvectors to
calculate is given by @var{k} whose default value is 6.

By default @code{eigs} solve the equation
@iftex
@tex
$A \nu = \lambda \nu$
@end tex
@end iftex
@ifinfo
@code{A * v = lambda * v}
@end ifinfo
, where
@iftex
@tex
$\lambda$ is a scalar representing one of the eigenvalues, and $\nu$
@end tex
@end iftex
@ifinfo
@code{lambda} is a scalar representing one of the eigenvalues, and @code{v}
@end ifinfo
is the corresponding eigenvector.  If given the positive definite matrix
@var{B} then @code{eigs} solves the general eigenvalue equation
@iftex
@tex
$A \nu = \lambda B \nu$
@end tex
@end iftex
@ifinfo
@code{A * v = lambda * B * v}
@end ifinfo
.

The argument @var{sigma} determines which eigenvalues are returned.
@var{sigma} can be either a scalar or a string.  When @var{sigma} is a scalar,
the @var{k} eigenvalues closest to @var{sigma} are returned.  If @var{sigma}
is a string, it must have one of the values

@table @asis
@item 'lm'
Largest magnitude (default).

@item 'sm'
Smallest magnitude.

@item 'la'
Largest Algebraic (valid only for real symmetric problems).

@item 'sa'
Smallest Algebraic (valid only for real symmetric problems).

@item 'be'
Both ends, with one more from the high-end if @var{k} is odd (valid only for
real symmetric problems).

@item 'lr'
Largest real part (valid only for complex or unsymmetric problems).

@item 'sr'
Smallest real part (valid only for complex or unsymmetric problems).

@item 'li'
Largest imaginary part (valid only for complex or unsymmetric problems).

@item 'si'
Smallest imaginary part (valid only for complex or unsymmetric problems).
@end table

If @var{opts} is given, it is a structure defining some of the options that
@code{eigs} should use.  The fields of the structure @var{opts} are

@table @code
@item issym
If @var{af} is given, then flags whether the function @var{af} defines a
symmetric problem.  It is ignored if @var{a} is given.  The default is false.

@item isreal
If @var{af} is given, then flags whether the function @var{af} defines a
real problem.  It is ignored if @var{a} is given.  The default is true.

@item tol
Defines the required convergence tolerance, given as @code{tol * norm (A)}.
The default is @code{eps}.

@item maxit
The maximum number of iterations.  The default is 300.

@item p
The number of Lanzcos basis vectors to use.  More vectors will result in
faster convergence, but a larger amount of memory.  The optimal value of 'p'
is problem dependent and should be in the range @var{k} to @var{n}.  The
default value is @code{2 * @var{k}}.

@item v0
The starting vector for the computation.  The default is to have @sc{Arpack}
randomly generate a starting vector.

@item disp
The level of diagnostic printout.  If @code{disp} is 0 then there is no
printout.  The default value is 1.

@item cholB
Flag if @code{chol (@var{b})} is passed rather than @var{b}.  The default is
false.

@item permB
The permutation vector of the Cholesky factorization of @var{b} if
@code{cholB} is true.  That is @code{chol ( @var{b} (permB, permB))}.  The
default is @code{1:@var{n}}.

@end table

It is also possible to represent @var{a} by a function denoted @var{af}.
@var{af} must be followed by a scalar argument @var{n} defining the length
of the vector argument accepted by @var{af}.  @var{af} can be passed either
as an inline function, function handle or as a string.  In the case where
@var{af} is passed as a string, the name of the string defines the function
to use.

@var{af} is a function of the form @code{function y = af (x), y = @dots{};
endfunction}, where the required return value of @var{af} is determined by
the value of @var{sigma}, and are

@table @code
@item A * x
If @var{sigma} is not given or is a string other than 'sm'.

@item A \ x
If @var{sigma} is 'sm'.

@item (A - sigma * I) \ x
for standard eigenvalue problem, where @code{I} is the identity matrix of
the same size as @code{A}.  If @var{sigma} is zero, this reduces the
@code{A \ x}.

@item (A - sigma * B) \ x
for the general eigenvalue problem.
@end table

The return arguments of @code{eigs} depends on the number of return
arguments.  With a single return argument, a vector @var{d} of length @var{k}
is returned, represent the @var{k} eigenvalues that have been found.  With two
return arguments, @var{v} is a @var{n}-by-@var{k} matrix whose columns are
the @var{k} eigenvectors corresponding to the returned eigenvalues.  The
eigenvalues themselves are then returned in @var{d} in the form of a
@var{n}-by-@var{k} matrix, where the elements on the diagonal are the
eigenvalues.

Given a third return argument @var{flag}, @code{eigs} also returns the status
of the convergence.  If @var{flag} is 0, then all eigenvalues have converged,
otherwise not.

This function is based on the @sc{Arpack} package, written by R Lehoucq,
K Maschhoff, D Sorensen and C Yang.  For more information see
@url{http://www.caam.rice.edu/software/ARPACK/}.

@end deftypefn
@seealso{@ref{doc-eig,,eig}, @ref{doc-svds,,svds}}


@c ./sparse/svds.m
@anchor{doc-svds}
@deftypefn {Function File} {@var{s} =} svds (@var{a})
@deftypefnx {Function File} {@var{s} =} svds (@var{a}, @var{k})
@deftypefnx {Function File} {@var{s} =} svds (@var{a}, @var{k}, @var{sigma})
@deftypefnx {Function File} {@var{s} =} svds (@var{a}, @var{k}, @var{sigma}, @var{opts})
@deftypefnx {Function File} {[@var{u}, @var{s}, @var{v}, @var{flag}] =} svds (@dots{})

Find a few singular values of the matrix @var{a}.  The singular values
are calculated using 

@example
@group
[@var{m}, @var{n}] = size(@var{a})
@var{s} = eigs([sparse(@var{m}, @var{m}), @var{a}; ...
                @var{a}', sparse(@var{n}, @var{n})])
@end group
@end example

The eigenvalues returned by @code{eigs} correspond to the singular
values of @var{a}.  The number of singular values to calculate is given
by @var{k}, whose default value is 6.

The argument @var{sigma} can be used to specify which singular values
to find.  @var{sigma} can be either the string 'L', the default, in 
which case the largest singular values of @var{a} are found.  Otherwise
@var{sigma} should be a real scalar, in which case the singular values
closest to @var{sigma} are found.  Note that for relatively small values
of @var{sigma}, there is the chance that the requested number of singular
values are not returned.  In that case @var{sigma} should be increased.

If @var{opts} is given, then it is a structure that defines options
that @code{svds} will pass to @var{eigs}.  The possible fields of this
structure are therefore determined by @code{eigs}.  By default three
fields of this structure are set by @code{svds}.

@table @code
@item tol
The required convergence tolerance for the singular values.  @code{eigs}
is passed @var{tol} divided by @code{sqrt(2)}.  The default value is 
1e-10.

@item maxit
The maximum number of iterations.  The default is 300.

@item disp
The level of diagnostic printout.  If @code{disp} is 0 then there is no
printout.  The default value is 0.
@end table

If more than one output argument is given, then @code{svds} also
calculates the left and right singular vectors of @var{a}.  @var{flag}
is used to signal the convergence of @code{svds}.  If @code{svds} 
converges to the desired tolerance, then @var{flag} given by

@example
@group
norm (@var{a} * @var{v} - @var{u} * @var{s}, 1) <= ...
        @var{tol} * norm (@var{a}, 1)
@end group
@end example

will be zero.
@end deftypefn
@seealso{@ref{doc-eigs,,eigs}}


@node Iterative Techniques
@section Iterative Techniques applied to sparse matrices

The left division @code{\} and right division @code{/} operators,
discussed in the previous section, use direct solvers to resolve a
linear equation of the form @code{@var{x} = @var{A} \ @var{b}} or
@code{@var{x} = @var{b} / @var{A}}.  Octave equally includes a number of
functions to solve sparse linear equations using iterative techniques.

@c ./sparse/pcg.m
@anchor{doc-pcg}
@deftypefn {Function File} {@var{x} =} pcg (@var{a}, @var{b}, @var{tol}, @var{maxit}, @var{m1}, @var{m2}, @var{x0}, @dots{})
@deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}, @var{eigest}] =} pcg (@dots{})

Solves the linear system of equations @code{@var{a} * @var{x} =
@var{b}} by means of the Preconditioned Conjugate Gradient iterative
method.  The input arguments are

@itemize
@item
@var{a} can be either a square (preferably sparse) matrix or a
function handle, inline function or string containing the name
of a function which computes @code{@var{a} * @var{x}}.  In principle
@var{a} should be symmetric and positive definite; if @code{pcg}
finds @var{a} to not be positive definite, you will get a warning
message and the @var{flag} output parameter will be set.

@item
@var{b} is the right hand side vector.

@item
@var{tol} is the required relative tolerance for the residual error,
@code{@var{b} - @var{a} * @var{x}}.  The iteration stops if @code{norm
(@var{b} - @var{a} * @var{x}) <= @var{tol} * norm (@var{b} - @var{a} *
@var{x0})}.  If @var{tol} is empty or is omitted, the function sets
@code{@var{tol} = 1e-6} by default.

@item
@var{maxit} is the maximum allowable number of iterations; if
@code{[]} is supplied for @code{maxit}, or @code{pcg} has less
arguments, a default value equal to 20 is used.

@item
@var{m} = @var{m1} * @var{m2} is the (left) preconditioning matrix, so that the iteration is
(theoretically) equivalent to solving by @code{pcg} @code{@var{P} *
@var{x} = @var{m} \ @var{b}}, with @code{@var{P} = @var{m} \ @var{a}}.
Note that a proper choice of the preconditioner may dramatically
improve the overall performance of the method.  Instead of matrices
@var{m1} and @var{m2}, the user may pass two functions which return 
the results of applying the inverse of @var{m1} and @var{m2} to 
a vector (usually this is the preferred way of using the preconditioner). 
If @code{[]} is supplied for @var{m1}, or @var{m1} is omitted, no 
preconditioning is applied.  If @var{m2} is omitted, @var{m} = @var{m1}
will be used as preconditioner.

@item
@var{x0} is the initial guess.  If @var{x0} is empty or omitted, the 
function sets @var{x0} to a zero vector by default.
@end itemize

The arguments which follow @var{x0} are treated as parameters, and
passed in a proper way to any of the functions (@var{a} or @var{m})
which are passed to @code{pcg}.  See the examples below for further
details.  The output arguments are

@itemize
@item
@var{x} is the computed approximation to the solution of
@code{@var{a} * @var{x} = @var{b}}.

@item
@var{flag} reports on the convergence.  @code{@var{flag} = 0} means
the solution converged and the tolerance criterion given by @var{tol}
is satisfied.  @code{@var{flag} = 1} means that the @var{maxit} limit
for the iteration count was reached.  @code{@var{flag} = 3} reports that
the (preconditioned) matrix was found not positive definite.

@item
@var{relres} is the ratio of the final residual to its initial value,
measured in the Euclidean norm.

@item
@var{iter} is the actual number of iterations performed.

@item 
@var{resvec} describes the convergence history of the method.
@code{@var{resvec} (i,1)} is the Euclidean norm of the residual, and
@code{@var{resvec} (i,2)} is the preconditioned residual norm,
after the (@var{i}-1)-th iteration, @code{@var{i} =
1, 2, @dots{}, @var{iter}+1}.  The preconditioned residual norm
is defined as
@code{norm (@var{r}) ^ 2 = @var{r}' * (@var{m} \ @var{r})} where
@code{@var{r} = @var{b} - @var{a} * @var{x}}, see also the
description of @var{m}.  If @var{eigest} is not required, only
@code{@var{resvec} (:,1)} is returned.

@item
@var{eigest} returns the estimate for the smallest @code{@var{eigest}
(1)} and largest @code{@var{eigest} (2)} eigenvalues of the
preconditioned matrix @code{@var{P} = @var{m} \ @var{a}}.  In 
particular, if no preconditioning is used, the estimates for the
extreme eigenvalues of @var{a} are returned.  @code{@var{eigest} (1)}
is an overestimate and @code{@var{eigest} (2)} is an underestimate, 
so that @code{@var{eigest} (2) / @var{eigest} (1)} is a lower bound
for @code{cond (@var{P}, 2)}, which nevertheless in the limit should
theoretically be equal to the actual value of the condition number. 
The method which computes @var{eigest} works only for symmetric positive
definite @var{a} and @var{m}, and the user is responsible for
verifying this assumption. 
@end itemize

Let us consider a trivial problem with a diagonal matrix (we exploit the
sparsity of A) 

@example
@group
	n = 10; 
	a = diag (sparse (1:n));
	b = rand (n, 1);
     [l, u, p, q] = luinc (a, 1.e-3);
@end group
@end example

@sc{Example 1:} Simplest use of @code{pcg}

@example
  x = pcg(A,b)
@end example

@sc{Example 2:} @code{pcg} with a function which computes
@code{@var{a} * @var{x}}

@example
@group
  function y = apply_a (x)
    y = [1:N]'.*x; 
  endfunction

  x = pcg ("apply_a", b)
@end group
@end example

@sc{Example 3:} @code{pcg} with a preconditioner: @var{l} * @var{u}

@example
x = pcg (a, b, 1.e-6, 500, l*u);
@end example

@sc{Example 4:} @code{pcg} with a preconditioner: @var{l} * @var{u}.
Faster than @sc{Example 3} since lower and upper triangular matrices 
are easier to invert

@example
x = pcg (a, b, 1.e-6, 500, l, u);
@end example

@sc{Example 5:} Preconditioned iteration, with full diagnostics.  The
preconditioner (quite strange, because even the original matrix
@var{a} is trivial) is defined as a function

@example
@group
  function y = apply_m (x)
    k = floor (length (x) - 2);
    y = x;
    y(1:k) = x(1:k)./[1:k]';
  endfunction

  [x, flag, relres, iter, resvec, eigest] = ...
                     pcg (a, b, [], [], "apply_m");
  semilogy (1:iter+1, resvec);
@end group
@end example

@sc{Example 6:} Finally, a preconditioner which depends on a
parameter @var{k}.

@example
@group
  function y = apply_M (x, varargin)
  K = varargin@{1@}; 
  y = x;
  y(1:K) = x(1:K)./[1:K]';
  endfunction

  [x, flag, relres, iter, resvec, eigest] = ...
       pcg (A, b, [], [], "apply_m", [], [], 3)
@end group
@end example

@sc{References}

	[1] C.T.Kelley, 'Iterative methods for linear and nonlinear equations',
	SIAM, 1995 (the base PCG algorithm) 
	
	[2] Y.Saad, 'Iterative methods for sparse linear systems', PWS 1996
	(condition number estimate from PCG) Revised version of this book is
	available online at http://www-users.cs.umn.edu/~saad/books.html


@seealso{@ref{doc-sparse,,sparse}, @ref{doc-pcr,,pcr}}
@end deftypefn


@c ./sparse/pcr.m
@anchor{doc-pcr}
@deftypefn {Function File} {@var{x} =} pcr (@var{a}, @var{b}, @var{tol}, @var{maxit}, @var{m}, @var{x0}, @dots{})
@deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} pcr (@dots{})

Solves the linear system of equations @code{@var{a} * @var{x} =
@var{b}} by means of the Preconditioned Conjugate Residuals iterative
method.  The input arguments are

@itemize
@item
@var{a} can be either a square (preferably sparse) matrix or a
function handle, inline function or string containing the name
of a function which computes @code{@var{a} * @var{x}}.  In principle
@var{a} should be symmetric and non-singular; if @code{pcr}
finds @var{a} to be numerically singular, you will get a warning
message and the @var{flag} output parameter will be set.

@item
@var{b} is the right hand side vector.

@item
@var{tol} is the required relative tolerance for the residual error,
@code{@var{b} - @var{a} * @var{x}}.  The iteration stops if @code{norm
(@var{b} - @var{a} * @var{x}) <= @var{tol} * norm (@var{b} - @var{a} *
@var{x0})}.  If @var{tol} is empty or is omitted, the function sets
@code{@var{tol} = 1e-6} by default.

@item
@var{maxit} is the maximum allowable number of iterations; if
@code{[]} is supplied for @code{maxit}, or @code{pcr} has less
arguments, a default value equal to 20 is used.

@item
@var{m} is the (left) preconditioning matrix, so that the iteration is
(theoretically) equivalent to solving by @code{pcr} @code{@var{P} *
@var{x} = @var{m} \ @var{b}}, with @code{@var{P} = @var{m} \ @var{a}}.
Note that a proper choice of the preconditioner may dramatically
improve the overall performance of the method.  Instead of matrix
@var{m}, the user may pass a function which returns the results of 
applying the inverse of @var{m} to a vector (usually this is the
preferred way of using the preconditioner).  If @code{[]} is supplied
for @var{m}, or @var{m} is omitted, no preconditioning is applied.

@item
@var{x0} is the initial guess.  If @var{x0} is empty or omitted, the 
function sets @var{x0} to a zero vector by default.
@end itemize

The arguments which follow @var{x0} are treated as parameters, and
passed in a proper way to any of the functions (@var{a} or @var{m})
which are passed to @code{pcr}.  See the examples below for further
details.  The output arguments are

@itemize
@item
@var{x} is the computed approximation to the solution of
@code{@var{a} * @var{x} = @var{b}}.

@item
@var{flag} reports on the convergence.  @code{@var{flag} = 0} means
the solution converged and the tolerance criterion given by @var{tol}
is satisfied.  @code{@var{flag} = 1} means that the @var{maxit} limit
for the iteration count was reached.  @code{@var{flag} = 3} reports t
@code{pcr} breakdown, see [1] for details.

@item
@var{relres} is the ratio of the final residual to its initial value,
measured in the Euclidean norm.

@item
@var{iter} is the actual number of iterations performed.

@item 
@var{resvec} describes the convergence history of the method,
so that @code{@var{resvec} (i)} contains the Euclidean norms of the 
residual after the (@var{i}-1)-th iteration, @code{@var{i} =
1,2, @dots{}, @var{iter}+1}.
@end itemize

Let us consider a trivial problem with a diagonal matrix (we exploit the
sparsity of A) 

@example
@group
	n = 10; 
	a = sparse (diag (1:n));
	b = rand (N, 1);
@end group
@end example

@sc{Example 1:} Simplest use of @code{pcr}

@example
  x = pcr(A, b)
@end example

@sc{Example 2:} @code{pcr} with a function which computes
@code{@var{a} * @var{x}}.

@example
@group
  function y = apply_a (x) 
    y = [1:10]'.*x; 
  endfunction

  x = pcr ("apply_a", b)
@end group
@end example

@sc{Example 3:}  Preconditioned iteration, with full diagnostics.  The
preconditioner (quite strange, because even the original matrix
@var{a} is trivial) is defined as a function

@example
@group
  function y = apply_m (x)		
    k = floor (length(x)-2); 
    y = x; 
    y(1:k) = x(1:k)./[1:k]';	
  endfunction

  [x, flag, relres, iter, resvec] = ...
                     pcr (a, b, [], [], "apply_m")
  semilogy([1:iter+1], resvec);
@end group
@end example

@sc{Example 4:} Finally, a preconditioner which depends on a
parameter @var{k}.

@example
@group
  function y = apply_m (x, varargin)
    k = varargin@{1@}; 
    y = x; y(1:k) = x(1:k)./[1:k]';	 
  endfunction

  [x, flag, relres, iter, resvec] = ...
                     pcr (a, b, [], [], "apply_m"', [], 3)
@end group
@end example

@sc{References}

	[1] W. Hackbusch, "Iterative Solution of Large Sparse Systems of
 	Equations", section 9.5.4; Springer, 1994

@seealso{@ref{doc-sparse,,sparse}, @ref{doc-pcg,,pcg}}
@end deftypefn


The speed with which an iterative solver converges to a solution can be
accelerated with the use of a pre-conditioning matrix @var{M}.  In this
case the linear equation @code{@var{M}^-1 * @var{x} = @var{M}^-1 *
@var{A} \ @var{b}} is solved instead.  Typical pre-conditioning matrices
are partial factorizations of the original matrix.

@c ./DLD-FUNCTIONS/luinc.cc
@anchor{doc-luinc}
@deftypefn {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, '0')
@deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, @var{droptol})
@deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, @var{opts})
@cindex LU decomposition
Produce the incomplete LU factorization of the sparse matrix @var{a}.
Two types of incomplete factorization are possible, and the type
is determined by the second argument to @dfn{luinc}.

Called with a second argument of '0', the zero-level incomplete
LU factorization is produced.  This creates a factorization of @var{a}
where the position of the non-zero arguments correspond to the same
positions as in the matrix @var{a}.

Alternatively, the fill-in of the incomplete LU factorization can
be controlled through the variable @var{droptol} or the structure
@var{opts}.  The UMFPACK multifrontal factorization code by Tim A.
Davis is used for the incomplete LU factorization, (availability
@url{http://www.cise.ufl.edu/research/sparse/umfpack/})

@var{droptol} determines the values below which the values in the LU
factorization are dropped and replaced by zero.  It must be a positive
scalar, and any values in the factorization whose absolute value are
less than this value are dropped, expect if leaving them increase the
sparsity of the matrix.  Setting @var{droptol} to zero results in a
complete LU factorization which is the default.

@var{opts} is a structure containing one or more of the fields

@table @code
@item droptol
The drop tolerance as above.  If @var{opts} only contains @code{droptol}
then this is equivalent to using the variable @var{droptol}.

@item milu
A logical variable flagging whether to use the modified incomplete LU
factorization.  In the case that @code{milu} is true, the dropped values
are subtracted from the diagonal of the matrix U of the factorization.
The default is @code{false}.

@item udiag
A logical variable that flags whether zero elements on the diagonal of U
should be replaced with @var{droptol} to attempt to avoid singular
factors.  The default is @code{false}.

@item thresh
Defines the pivot threshold in the interval [0,1].  Values outside that
range are ignored.
@end table

All other fields in @var{opts} are ignored.  The outputs from @dfn{luinc}
are the same as for @dfn{lu}.

Given the string argument 'vector', @dfn{luinc} returns the values of @var{p}
@var{q} as vector values.
@seealso{@ref{doc-sparse,,sparse}, @ref{doc-lu,,lu}}
@end deftypefn


@node Real Life Example
@section Real Life Example of the use of Sparse Matrices

A common application for sparse matrices is in the solution of Finite
Element Models.  Finite element models allow numerical solution of
partial differential equations that do not have closed form solutions,
typically because of the complex shape of the domain.

In order to motivate this application, we consider the boundary value
Laplace equation.  This system can model scalar potential fields, such
as heat or electrical potential.  Given a medium 
@tex
$\Omega$ 
@end tex
@ifinfo
Omega
@end ifinfo
with boundary
@tex
$\partial\Omega$ 
@end tex
@ifinfo
dOmega
@end ifinfo
. At all points on the 
@tex
$\partial\Omega$ 
@end tex
@ifinfo
dOmega
@end ifinfo
the boundary conditions are known, and we wish to calculate the potential in
@tex
$\Omega$ 
@end tex
@ifinfo
Omega
@end ifinfo
. Boundary conditions may specify the potential (Dirichlet
boundary condition), its normal derivative across the boundary
(Neumann boundary condition), or a weighted sum of the potential and
its derivative (Cauchy boundary condition).

In a thermal model, we want to calculate the temperature in
@tex
$\Omega$ 
@end tex
@ifinfo
Omega
@end ifinfo
and know the boundary temperature (Dirichlet condition)
or heat flux (from which we can calculate the Neumann condition
by dividing by the thermal conductivity at the boundary).  Similarly, 
in an electrical model, we want to calculate the voltage in
@tex
$\Omega$ 
@end tex
@ifinfo
Omega
@end ifinfo
and know the boundary voltage (Dirichlet) or current
(Neumann condition after diving by the electrical conductivity).
In an electrical model, it is common for much of the boundary
to be electrically isolated; this is a Neumann boundary condition
with the current equal to zero.

The simplest finite element models will divide 
@tex
$\Omega$ 
@end tex
@ifinfo
Omega
@end ifinfo
into simplexes (triangles in 2D, pyramids in 3D).
@ifset htmltex
We take as an 3D example a cylindrical liquid filled tank with a small 
non-conductive ball from the EIDORS project@footnote{EIDORS - Electrical 
Impedance Tomography and Diffuse optical Tomography Reconstruction Software 
@url{http://eidors3d.sourceforge.net}}.  This is model is designed to reflect
an application of electrical impedance tomography, where current patterns
are applied to such a tank in order to image the internal conductivity
distribution.  In order to describe the FEM geometry, we have a matrix of 
vertices @code{nodes} and simplices @code{elems}.
@end ifset

The following example creates a simple rectangular 2D electrically
conductive medium with 10 V and 20 V imposed on opposite sides 
(Dirichlet boundary conditions).  All other edges are electrically
isolated.

@example
@group
   node_y= [1;1.2;1.5;1.8;2]*ones(1,11);
   node_x= ones(5,1)*[1,1.05,1.1,1.2, ...
             1.3,1.5,1.7,1.8,1.9,1.95,2];
   nodes= [node_x(:), node_y(:)];

   [h,w]= size(node_x);
   elems= [];
   for idx= 1:w-1
     widx= (idx-1)*h;
     elems= [elems; ...
       widx+[(1:h-1);(2:h);h+(1:h-1)]'; ...
       widx+[(2:h);h+(2:h);h+(1:h-1)]' ]; 
   endfor

   E= size(elems,1); # No. of simplices
   N= size(nodes,1); # No. of vertices
   D= size(elems,2); # dimensions+1
@end group
@end example

This creates a N-by-2 matrix @code{nodes} and a E-by-3 matrix
@code{elems} with values, which define finite element triangles:

@example
@group
  nodes(1:7,:)'
    1.00 1.00 1.00 1.00 1.00 1.05 1.05 @dots{}
    1.00 1.20 1.50 1.80 2.00 1.00 1.20 @dots{}

  elems(1:7,:)'
    1    2    3    4    2    3    4 @dots{}
    2    3    4    5    7    8    9 @dots{}
    6    7    8    9    6    7    8 @dots{}
@end group
@end example

Using a first order FEM, we approximate the electrical conductivity 
distribution in 
@tex
$\Omega$ 
@end tex
@ifinfo
Omega
@end ifinfo
as constant on each simplex (represented by the vector @code{conductivity}).
Based on the finite element geometry, we first calculate a system (or
stiffness) matrix for each simplex (represented as 3-by-3 elements on the
diagonal of the element-wise system matrix @code{SE}.  Based on @code{SE} 
and a N-by-DE connectivity matrix @code{C}, representing the connections 
between simplices and vertices, the global connectivity matrix @code{S} is
calculated.

@example
  # Element conductivity
  conductivity= [1*ones(1,16), ...
         2*ones(1,48), 1*ones(1,16)];

  # Connectivity matrix
  C = sparse ((1:D*E), reshape (elems', ...
         D*E, 1), 1, D*E, N);

  # Calculate system matrix
  Siidx = floor ([0:D*E-1]'/D) * D * ...
         ones(1,D) + ones(D*E,1)*(1:D) ;
  Sjidx = [1:D*E]'*ones(1,D);
  Sdata = zeros(D*E,D);
  dfact = factorial(D-1);
  for j=1:E
     a = inv([ones(D,1), ... 
         nodes(elems(j,:), :)]);
     const = conductivity(j) * 2 / ...
         dfact / abs(det(a));
     Sdata(D*(j-1)+(1:D),:) = const * ...
         a(2:D,:)' * a(2:D,:);
  endfor
  # Element-wise system matrix
  SE= sparse(Siidx,Sjidx,Sdata);
  # Global system matrix
  S= C'* SE *C;
@end example

The system matrix acts like the conductivity 
@tex
$S$ 
@end tex
@ifinfo
@code{S}
@end ifinfo
in Ohm's law 
@tex
$SV = I$. 
@end tex
@ifinfo
@code{S * V = I}.
@end ifinfo
Based on the Dirichlet and Neumann boundary conditions, we are able to 
solve for the voltages at each vertex @code{V}. 

@example
  # Dirichlet boundary conditions
  D_nodes=[1:5, 51:55]; 
  D_value=[10*ones(1,5), 20*ones(1,5)]; 

  V= zeros(N,1);
  V(D_nodes) = D_value;
  idx = 1:N; # vertices without Dirichlet 
             # boundary condns
  idx(D_nodes) = [];

  # Neumann boundary conditions.  Note that
  # N_value must be normalized by the
  # boundary length and element conductivity
  N_nodes=[];
  N_value=[];

  Q = zeros(N,1);
  Q(N_nodes) = N_value;

  V(idx) = S(idx,idx) \ ( Q(idx) - ...
            S(idx,D_nodes) * V(D_nodes));
@end example

Finally, in order to display the solution, we show each solved voltage 
value in the z-axis for each simplex vertex.
@ifset htmltex
@ifset HAVE_CHOLMOD
@ifset HAVE_UMFPACK
@ifset HAVE_COLAMD
@xref{fig:femmodel}.
@end ifset
@end ifset
@end ifset
@end ifset

@example
@group
  elemx = elems(:,[1,2,3,1])';
  xelems = reshape (nodes(elemx, 1), 4, E);
  yelems = reshape (nodes(elemx, 2), 4, E);
  velems = reshape (V(elemx), 4, E);
  plot3 (xelems,yelems,velems,'k'); 
  print ('grid.eps');
@end group
@end example


@ifset htmltex
@ifset HAVE_CHOLMOD
@ifset HAVE_UMFPACK
@ifset HAVE_COLAMD
@float Figure,fig:femmodel
@center @image{grid,4in}
@caption{Example finite element model the showing triangular elements. 
The height of each vertex corresponds to the solution value.}
@end float
@end ifset
@end ifset
@end ifset
@end ifset
