<html lang="en">
<head>
<title>Signal Processing - GNU Octave</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Octave">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Geometry.html#Geometry" title="Geometry">
<link rel="next" href="Image-Processing.html#Image-Processing" title="Image Processing">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Signal-Processing"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Image-Processing.html#Image-Processing">Image Processing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Geometry.html#Geometry">Geometry</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">31 Signal Processing</h2>

<p>This chapter describes the signal processing and fast Fourier
transform functions available in Octave.  Fast Fourier transforms are
computed with the <span class="sc">fftw</span> or <span class="sc">fftpack</span> libraries depending on how
Octave is built.

<!-- detrend scripts/signal/detrend.m -->
   <p><a name="XREFdetrend"></a>

<div class="defun">
&mdash; Function File:  <b>detrend</b> (<var>x, p</var>)<var><a name="index-detrend-3211"></a></var><br>
<blockquote><p>If <var>x</var> is a vector, <code>detrend (</code><var>x</var><code>, </code><var>p</var><code>)</code> removes the
best fit of a polynomial of order <var>p</var> from the data <var>x</var>.

        <p>If <var>x</var> is a matrix, <code>detrend (</code><var>x</var><code>, </code><var>p</var><code>)</code> does the same
for each column in <var>x</var>.

        <p>The second argument is optional.  If it is not specified, a value of 1
is assumed.  This corresponds to removing a linear trend.

        <p>The order of the polynomial can also be given as a string, in which case
<var>p</var> must be either <code>"constant"</code> (corresponds to
<var>p</var><code>=0</code>) or
<code>"linear"</code> (corresponds to <var>p</var><code>=1</code>).

     <p class="noindent"><strong>See also:</strong> <a href="XREFpolyfit.html#XREFpolyfit">polyfit</a>.

        </blockquote></div>

<!-- fft libinterp/corefcn/fft.cc -->
   <p><a name="XREFfft"></a>

<div class="defun">
&mdash; Built-in Function:  <b>fft</b> (<var>x</var>)<var><a name="index-fft-3212"></a></var><br>
&mdash; Built-in Function:  <b>fft</b> (<var>x, n</var>)<var><a name="index-fft-3213"></a></var><br>
&mdash; Built-in Function:  <b>fft</b> (<var>x, n, dim</var>)<var><a name="index-fft-3214"></a></var><br>
<blockquote><p>Compute the discrete Fourier transform of <var>A</var> using
a Fast Fourier Transform (FFT) algorithm.

        <p>The FFT is calculated along the first non-singleton dimension of the
array.  Thus if <var>x</var> is a matrix, <code>fft (</code><var>x</var><code>)</code> computes the
FFT for each column of <var>x</var>.

        <p>If called with two arguments, <var>n</var> is expected to be an integer
specifying the number of elements of <var>x</var> to use, or an empty
matrix to specify that its value should be ignored.  If <var>n</var> is
larger than the dimension along which the FFT is calculated, then
<var>x</var> is resized and padded with zeros.  Otherwise, if <var>n</var> is
smaller than the dimension along which the FFT is calculated, then
<var>x</var> is truncated.

        <p>If called with three arguments, <var>dim</var> is an integer specifying the
dimension of the matrix along which the FFT is performed

     <p class="noindent"><strong>See also:</strong> <a href="XREFifft.html#XREFifft">ifft</a>, <a href="XREFfft2.html#XREFfft2">fft2</a>, <a href="XREFfftn.html#XREFfftn">fftn</a>, <a href="XREFfftw.html#XREFfftw">fftw</a>.

        </blockquote></div>

   <p>Octave uses the <span class="sc">fftw</span> libraries to perform FFT computations.  When Octave
starts up and initializes the <span class="sc">fftw</span> libraries, they read a system wide
file (on a Unix system, it is typically <samp><span class="file">/etc/fftw/wisdom</span></samp>) that
contains information useful to speed up FFT computations.  This
information is called the <em>wisdom</em>.  The system-wide file allows
wisdom to be shared between all applications using the <span class="sc">fftw</span> libraries.

   <p>Use the <code>fftw</code> function to generate and save wisdom.  Using the
utilities provided together with the <span class="sc">fftw</span> libraries
(<samp><span class="command">fftw-wisdom</span></samp> on Unix systems), you can even add wisdom
generated by Octave to the system-wide wisdom file.

<!-- fftw libinterp/dldfcn/fftw.cc -->
   <p><a name="XREFfftw"></a>

<div class="defun">
&mdash; Loadable Function: <var>method</var> = <b>fftw</b> (<var>"planner"</var>)<var><a name="index-fftw-3215"></a></var><br>
&mdash; Loadable Function:  <b>fftw</b> (<var>"planner", method</var>)<var><a name="index-fftw-3216"></a></var><br>
&mdash; Loadable Function: <var>wisdom</var> = <b>fftw</b> (<var>"dwisdom"</var>)<var><a name="index-fftw-3217"></a></var><br>
&mdash; Loadable Function:  <b>fftw</b> (<var>"dwisdom", wisdom</var>)<var><a name="index-fftw-3218"></a></var><br>
&mdash; Loadable Function:  <b>fftw</b> (<var>"threads", nthreads</var>)<var><a name="index-fftw-3219"></a></var><br>
&mdash; Loadable Function: <var>nthreads</var> = <b>fftw</b> (<var>"threads"</var>)<var><a name="index-fftw-3220"></a></var><br>
<blockquote>
        <p>Manage <span class="sc">fftw</span> wisdom data.  Wisdom data can be used to significantly
accelerate the calculation of the FFTs, but implies an initial cost
in its calculation.  When the <span class="sc">fftw</span> libraries are initialized, they read
a system wide wisdom file (typically in <samp><span class="file">/etc/fftw/wisdom</span></samp>), allowing
wisdom to be shared between applications other than Octave.  Alternatively,
the <code>fftw</code> function can be used to import wisdom.  For example,

     <pre class="example">          <var>wisdom</var> = fftw ("dwisdom")
</pre>
        <p class="noindent">will save the existing wisdom used by Octave to the string <var>wisdom</var>. 
This string can then be saved to a file and restored using the <code>save</code>
and <code>load</code> commands respectively.  This existing wisdom can be
re-imported as follows

     <pre class="example">          fftw ("dwisdom", <var>wisdom</var>)
</pre>
        <p>If <var>wisdom</var> is an empty string, then the wisdom used is cleared.

        <p>During the calculation of Fourier transforms further wisdom is generated. 
The fashion in which this wisdom is generated is also controlled by
the <code>fftw</code> function.  There are five different manners in which the
wisdom can be treated:

          <dl>
<dt><code>"estimate"</code><dd>Specifies that no run-time measurement of the optimal means of
calculating a particular is performed, and a simple heuristic is used
to pick a (probably sub-optimal) plan.  The advantage of this method is
that there is little or no overhead in the generation of the plan, which
is appropriate for a Fourier transform that will be calculated once.

          <br><dt><code>"measure"</code><dd>In this case a range of algorithms to perform the transform is considered
and the best is selected based on their execution time.

          <br><dt><code>"patient"</code><dd>Similar to <code>"measure"</code>, but a wider range of algorithms is
considered.

          <br><dt><code>"exhaustive"</code><dd>Like <code>"measure"</code>, but all possible algorithms that may be used to
treat the transform are considered.

          <br><dt><code>"hybrid"</code><dd>As run-time measurement of the algorithm can be expensive, this is a
compromise where <code>"measure"</code> is used for transforms up to the size
of 8192 and beyond that the <code>"estimate"</code> method is used. 
</dl>

        <p>The default method is <code>"estimate"</code>.  The current method can
be queried with

     <pre class="example">          <var>method</var> = fftw ("planner")
</pre>
        <p class="noindent">or set by using

     <pre class="example">          fftw ("planner", <var>method</var>)
</pre>
        <p>Note that calculated wisdom will be lost when restarting Octave.  However,
the wisdom data can be reloaded if it is saved to a file as described
above.  Saved wisdom files should not be used on different platforms since
they will not be efficient and the point of calculating the wisdom is lost.

        <p>The number of threads used for computing the plans and executing the
transforms can be set with

     <pre class="example">          fftw ("threads", <var>NTHREADS</var>)
</pre>
        <p>Note that octave must be compiled with multi-threaded <span class="sc">fftw</span> support for
this feature.  The number of processors available to the current process is
used per default.

     <p class="noindent"><strong>See also:</strong> <a href="XREFfft.html#XREFfft">fft</a>, <a href="XREFifft.html#XREFifft">ifft</a>, <a href="XREFfft2.html#XREFfft2">fft2</a>, <a href="XREFifft2.html#XREFifft2">ifft2</a>, <a href="XREFfftn.html#XREFfftn">fftn</a>, <a href="XREFifftn.html#XREFifftn">ifftn</a>.

        </blockquote></div>

<!-- ifft libinterp/corefcn/fft.cc -->
   <p><a name="XREFifft"></a>

<div class="defun">
&mdash; Built-in Function:  <b>ifft</b> (<var>x</var>)<var><a name="index-ifft-3221"></a></var><br>
&mdash; Built-in Function:  <b>ifft</b> (<var>x, n</var>)<var><a name="index-ifft-3222"></a></var><br>
&mdash; Built-in Function:  <b>ifft</b> (<var>x, n, dim</var>)<var><a name="index-ifft-3223"></a></var><br>
<blockquote><p>Compute the inverse discrete Fourier transform of <var>A</var>
using a Fast Fourier Transform (FFT) algorithm.

        <p>The inverse FFT is calculated along the first non-singleton dimension
of the array.  Thus if <var>x</var> is a matrix, <code>fft (</code><var>x</var><code>)</code> computes
the inverse FFT for each column of <var>x</var>.

        <p>If called with two arguments, <var>n</var> is expected to be an integer
specifying the number of elements of <var>x</var> to use, or an empty
matrix to specify that its value should be ignored.  If <var>n</var> is
larger than the dimension along which the inverse FFT is calculated, then
<var>x</var> is resized and padded with zeros.  Otherwise, if <var>n</var> is
smaller than the dimension along which the inverse FFT is calculated,
then <var>x</var> is truncated.

        <p>If called with three arguments, <var>dim</var> is an integer specifying the
dimension of the matrix along which the inverse FFT is performed

     <p class="noindent"><strong>See also:</strong> <a href="XREFfft.html#XREFfft">fft</a>, <a href="XREFifft2.html#XREFifft2">ifft2</a>, <a href="XREFifftn.html#XREFifftn">ifftn</a>, <a href="XREFfftw.html#XREFfftw">fftw</a>.

        </blockquote></div>

<!-- fft2 libinterp/corefcn/fft2.cc -->
   <p><a name="XREFfft2"></a>

<div class="defun">
&mdash; Built-in Function:  <b>fft2</b> (<var>A</var>)<var><a name="index-fft2-3224"></a></var><br>
&mdash; Built-in Function:  <b>fft2</b> (<var>A, m, n</var>)<var><a name="index-fft2-3225"></a></var><br>
<blockquote><p>Compute the two-dimensional discrete Fourier transform of <var>A</var> using
a Fast Fourier Transform (FFT) algorithm.

        <p>The optional arguments <var>m</var> and <var>n</var> may be used specify the
number of rows and columns of <var>A</var> to use.  If either of these is
larger than the size of <var>A</var>, <var>A</var> is resized and padded with
zeros.

        <p>If <var>A</var> is a multi-dimensional matrix, each two-dimensional sub-matrix
of <var>A</var> is treated separately.

     <p class="noindent"><strong>See also:</strong> ifft2, fft, fftn, fftw.

        </blockquote></div>

<!-- ifft2 libinterp/corefcn/fft2.cc -->
   <p><a name="XREFifft2"></a>

<div class="defun">
&mdash; Built-in Function:  <b>ifft2</b> (<var>A</var>)<var><a name="index-ifft2-3226"></a></var><br>
&mdash; Built-in Function:  <b>ifft2</b> (<var>A, m, n</var>)<var><a name="index-ifft2-3227"></a></var><br>
<blockquote><p>Compute the inverse two-dimensional discrete Fourier transform of <var>A</var>
using a Fast Fourier Transform (FFT) algorithm.

        <p>The optional arguments <var>m</var> and <var>n</var> may be used specify the
number of rows and columns of <var>A</var> to use.  If either of these is
larger than the size of <var>A</var>, <var>A</var> is resized and padded with
zeros.

        <p>If <var>A</var> is a multi-dimensional matrix, each two-dimensional sub-matrix
of <var>A</var> is treated separately

     <p class="noindent"><strong>See also:</strong> fft2, ifft, ifftn, fftw.

        </blockquote></div>

<!-- fftn libinterp/corefcn/fftn.cc -->
   <p><a name="XREFfftn"></a>

<div class="defun">
&mdash; Built-in Function:  <b>fftn</b> (<var>A</var>)<var><a name="index-fftn-3228"></a></var><br>
&mdash; Built-in Function:  <b>fftn</b> (<var>A, size</var>)<var><a name="index-fftn-3229"></a></var><br>
<blockquote><p>Compute the N-dimensional discrete Fourier transform of <var>A</var> using
a Fast Fourier Transform (FFT) algorithm.

        <p>The optional vector argument <var>size</var> may be used specify the
dimensions of the array to be used.  If an element of <var>size</var> is
smaller than the corresponding dimension of <var>A</var>, then the dimension of
<var>A</var> is truncated prior to performing the FFT.  Otherwise, if an element
of <var>size</var> is larger than the corresponding dimension then <var>A</var>
is resized and padded with zeros.

     <p class="noindent"><strong>See also:</strong> <a href="XREFifftn.html#XREFifftn">ifftn</a>, <a href="XREFfft.html#XREFfft">fft</a>, <a href="XREFfft2.html#XREFfft2">fft2</a>, <a href="XREFfftw.html#XREFfftw">fftw</a>.

        </blockquote></div>

<!-- ifftn libinterp/corefcn/fftn.cc -->
   <p><a name="XREFifftn"></a>

<div class="defun">
&mdash; Built-in Function:  <b>ifftn</b> (<var>A</var>)<var><a name="index-ifftn-3230"></a></var><br>
&mdash; Built-in Function:  <b>ifftn</b> (<var>A, size</var>)<var><a name="index-ifftn-3231"></a></var><br>
<blockquote><p>Compute the inverse N-dimensional discrete Fourier transform of <var>A</var>
using a Fast Fourier Transform (FFT) algorithm.

        <p>The optional vector argument <var>size</var> may be used specify the
dimensions of the array to be used.  If an element of <var>size</var> is
smaller than the corresponding dimension of <var>A</var>, then the dimension of
<var>A</var> is truncated prior to performing the inverse FFT.  Otherwise, if an
element of <var>size</var> is larger than the corresponding dimension then <var>A</var>
is resized and padded with zeros.

     <p class="noindent"><strong>See also:</strong> <a href="XREFfftn.html#XREFfftn">fftn</a>, <a href="XREFifft.html#XREFifft">ifft</a>, <a href="XREFifft2.html#XREFifft2">ifft2</a>, <a href="XREFfftw.html#XREFfftw">fftw</a>.

        </blockquote></div>

<!-- fftconv scripts/signal/fftconv.m -->
   <p><a name="XREFfftconv"></a>

<div class="defun">
&mdash; Function File:  <b>fftconv</b> (<var>x, y</var>)<var><a name="index-fftconv-3232"></a></var><br>
&mdash; Function File:  <b>fftconv</b> (<var>x, y, n</var>)<var><a name="index-fftconv-3233"></a></var><br>
<blockquote><p>Convolve two vectors using the FFT for computation.

        <p><code>c = fftconv (</code><var>x</var><code>, </code><var>y</var><code>)</code> returns a vector of length equal to
<code>length (</code><var>x</var><code>) + length (</code><var>y</var><code>) - 1</code>. 
If <var>x</var> and <var>y</var> are the coefficient vectors of two polynomials, the
returned value is the coefficient vector of the product polynomial.

        <p>The computation uses the FFT by calling the function <code>fftfilt</code>.  If
the optional argument <var>n</var> is specified, an N-point FFT is used.

     <p class="noindent"><strong>See also:</strong> <a href="XREFdeconv.html#XREFdeconv">deconv</a>, <a href="XREFconv.html#XREFconv">conv</a>, <a href="XREFconv2.html#XREFconv2">conv2</a>.

        </blockquote></div>

<!-- fftfilt scripts/signal/fftfilt.m -->
   <p><a name="XREFfftfilt"></a>

<div class="defun">
&mdash; Function File:  <b>fftfilt</b> (<var>b, x, n</var>)<var><a name="index-fftfilt-3234"></a></var><br>
<blockquote>
        <p>With two arguments, <code>fftfilt</code> filters <var>x</var> with the FIR filter
<var>b</var> using the FFT.

        <p>Given the optional third argument, <var>n</var>, <code>fftfilt</code> uses the
overlap-add method to filter <var>x</var> with <var>b</var> using an <var>n</var>-point
FFT.  The FFT size must be an even power of 2 and must be greater than
or equal to the length of <var>b</var>.  If the specified <var>n</var> does not
meet these criteria, it is automatically adjusted to the nearest value
that does.

        <p>If <var>x</var> is a matrix, filter each column of the matrix.

     <p class="noindent"><strong>See also:</strong> <a href="XREFfilter.html#XREFfilter">filter</a>, <a href="XREFfilter2.html#XREFfilter2">filter2</a>.

        </blockquote></div>

<!-- filter libinterp/corefcn/filter.cc -->
   <p><a name="XREFfilter"></a>

<div class="defun">
&mdash; Built-in Function: y = <b>filter</b> (<var>b, a, x</var>)<var><a name="index-filter-3235"></a></var><br>
&mdash; Built-in Function: [<var>y</var>, <var>sf</var>] = <b>filter</b> (<var>b, a, x, si</var>)<var><a name="index-filter-3236"></a></var><br>
&mdash; Built-in Function: [<var>y</var>, <var>sf</var>] = <b>filter</b> (<var>b, a, x, </var>[]<var>, dim</var>)<var><a name="index-filter-3237"></a></var><br>
&mdash; Built-in Function: [<var>y</var>, <var>sf</var>] = <b>filter</b> (<var>b, a, x, si, dim</var>)<var><a name="index-filter-3238"></a></var><br>
<blockquote><p>Return the solution to the following linear, time-invariant difference
equation:
<!-- Set example in small font to prevent overfull line -->

     <pre class="smallexample">           N                   M
          SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)    for 1&lt;=n&lt;=length(x)
          k=0                 k=0
</pre>
        <p class="noindent">where
N=length(a)-1 and M=length(b)-1. 
The result is calculated over the first non-singleton dimension of <var>x</var>
or over <var>dim</var> if supplied.

        <p>An equivalent form of the equation is:
<!-- Set example in small font to prevent overfull line -->

     <pre class="smallexample">                    N                   M
          y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1&lt;=n&lt;=length(x)
                   k=1                 k=0
</pre>
        <p class="noindent">where
 c = a/a(1) and d = b/a(1).

        <p>If the fourth argument <var>si</var> is provided, it is taken as the
initial state of the system and the final state is returned as
<var>sf</var>.  The state vector is a column vector whose length is
equal to the length of the longest coefficient vector minus one. 
If <var>si</var> is not supplied, the initial state vector is set to all
zeros.

        <p>In terms of the Z Transform, y is the result of passing the discrete-
time signal x through a system characterized by the following rational
system function:

     <pre class="example">                    M
                   SUM d(k+1) z^(-k)
                   k=0
          H(z) = ---------------------
                      N
                 1 + SUM c(k+1) z^(-k)
                     k=1
</pre>
        <p class="noindent"><strong>See also:</strong> <a href="XREFfilter2.html#XREFfilter2">filter2</a>, <a href="XREFfftfilt.html#XREFfftfilt">fftfilt</a>, <a href="XREFfreqz.html#XREFfreqz">freqz</a>.

        </blockquote></div>

<!-- filter2 scripts/signal/filter2.m -->
   <p><a name="XREFfilter2"></a>

<div class="defun">
&mdash; Function File: <var>y</var> = <b>filter2</b> (<var>b, x</var>)<var><a name="index-filter2-3239"></a></var><br>
&mdash; Function File: <var>y</var> = <b>filter2</b> (<var>b, x, shape</var>)<var><a name="index-filter2-3240"></a></var><br>
<blockquote><p>Apply the 2-D FIR filter <var>b</var> to <var>x</var>.  If the argument
<var>shape</var> is specified, return an array of the desired shape. 
Possible values are:

          <dl>
<dt><code>"full"</code><dd>pad <var>x</var> with zeros on all sides before filtering.

          <br><dt><code>"same"</code><dd>unpadded <var>x</var> (default)

          <br><dt><code>"valid"</code><dd>trim <var>x</var> after filtering so edge effects are no included. 
</dl>

        <p>Note this is just a variation on convolution, with the parameters
reversed and <var>b</var> rotated 180 degrees.

     <p class="noindent"><strong>See also:</strong> <a href="XREFconv2.html#XREFconv2">conv2</a>.

        </blockquote></div>

<!-- freqz scripts/signal/freqz.m -->
   <p><a name="XREFfreqz"></a>

<div class="defun">
&mdash; Function File: [<var>h</var>, <var>w</var>] = <b>freqz</b> (<var>b, a, n, "whole"</var>)<var><a name="index-freqz-3241"></a></var><br>
&mdash; Function File: <var>h</var> = <b>freqz</b> (<var>b, a, w</var>)<var><a name="index-freqz-3242"></a></var><br>
&mdash; Function File: [<small class="dots">...</small>] = <b>freqz</b> (<var><small class="dots">...</small>, Fs</var>)<var><a name="index-freqz-3243"></a></var><br>
&mdash; Function File:  <b>freqz</b> (<var><small class="dots">...</small></var>)<var><a name="index-freqz-3244"></a></var><br>
<blockquote>
        <p>Return the complex frequency response <var>h</var> of the rational IIR filter
whose numerator and denominator coefficients are <var>b</var> and <var>a</var>,
respectively.  The response is evaluated at <var>n</var> angular frequencies
between 0 and
 2*pi.

     <p class="noindent">The output value <var>w</var> is a vector of the frequencies.

        <p>If <var>a</var> is omitted, the denominator is assumed to be 1 (this
corresponds to a simple FIR filter).

        <p>If <var>n</var> is omitted, a value of 512 is assumed.

        <p>For fastest computation, <var>n</var> should factor into a small number of
small primes.

        <p>If the fourth argument, <code>"whole"</code>, is omitted the response is
evaluated at frequencies between 0 and
 pi.

        <p><code>freqz (</code><var>b</var><code>, </code><var>a</var><code>, </code><var>w</var><code>)</code>

        <p>Evaluate the response at the specific frequencies in the vector <var>w</var>. 
The values for <var>w</var> are measured in radians.

        <p><code>[...] = freqz (..., </code><var>Fs</var><code>)</code>

        <p>Return frequencies in Hz instead of radians assuming a sampling rate
<var>Fs</var>.  If you are evaluating the response at specific frequencies
<var>w</var>, those frequencies should be requested in Hz rather than radians.

        <p><code>freqz (...)</code>

        <p>Plot the pass band, stop band and phase response of <var>h</var> rather
than returning them. 
</p></blockquote></div>

<!-- freqz_plot scripts/signal/freqz_plot.m -->
   <p><a name="XREFfreqz_005fplot"></a>

<div class="defun">
&mdash; Function File:  <b>freqz_plot</b> (<var>w, h</var>)<var><a name="index-freqz_005fplot-3245"></a></var><br>
<blockquote><p>Plot the pass band, stop band and phase response of <var>h</var>. 
</p></blockquote></div>

<!-- sinc scripts/signal/sinc.m -->
   <p><a name="XREFsinc"></a>

<div class="defun">
&mdash; Function File:  <b>sinc</b> (<var>x</var>)<var><a name="index-sinc-3246"></a></var><br>
<blockquote><p>Return
 sin (pi*x) / (pi*x). 
</p></blockquote></div>

<!-- unwrap scripts/signal/unwrap.m -->
   <p><a name="XREFunwrap"></a>

<div class="defun">
&mdash; Function File: <var>b</var> = <b>unwrap</b> (<var>x</var>)<var><a name="index-unwrap-3247"></a></var><br>
&mdash; Function File: <var>b</var> = <b>unwrap</b> (<var>x, tol</var>)<var><a name="index-unwrap-3248"></a></var><br>
&mdash; Function File: <var>b</var> = <b>unwrap</b> (<var>x, tol, dim</var>)<var><a name="index-unwrap-3249"></a></var><br>
<blockquote>
        <p>Unwrap radian phases by adding multiples of 2*pi as appropriate to
remove jumps greater than <var>tol</var>.  <var>tol</var> defaults to pi.

        <p>Unwrap will work along the dimension <var>dim</var>.  If <var>dim</var>
is unspecified it defaults to the first non-singleton dimension. 
</p></blockquote></div>

<!-- FIXME - someone needs to organize these... -->
<!-- arch_fit scripts/signal/arch_fit.m -->
   <p><a name="XREFarch_005ffit"></a>

<div class="defun">
&mdash; Function File: [<var>a</var>, <var>b</var>] = <b>arch_fit</b> (<var>y, x, p, iter, gamma, a0, b0</var>)<var><a name="index-arch_005ffit-3250"></a></var><br>
<blockquote><p>Fit an ARCH regression model to the time series <var>y</var> using the
scoring algorithm in Engle's original ARCH paper.  The model is

     <pre class="example">          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(p+1) * e(t-p)^2
</pre>
        <p class="noindent">in which e(t) is N(0, h(t)), given a time-series vector
<var>y</var> up to time t-1 and a matrix of (ordinary) regressors
<var>x</var> up to t.  The order of the regression of the residual
variance is specified by <var>p</var>.

        <p>If invoked as <code>arch_fit (</code><var>y</var><code>, </code><var>k</var><code>, </code><var>p</var><code>)</code> with a
positive integer <var>k</var>, fit an ARCH(<var>k</var>, <var>p</var>) process,
i.e., do the above with the t-th row of <var>x</var> given by

     <pre class="example">          [1, y(t-1), ..., y(t-k)]
</pre>
        <p>Optionally, one can specify the number of iterations <var>iter</var>, the
updating factor <var>gamma</var>, and initial values a0 and
b0 for the scoring algorithm. 
</p></blockquote></div>

<!-- arch_rnd scripts/signal/arch_rnd.m -->
   <p><a name="XREFarch_005frnd"></a>

<div class="defun">
&mdash; Function File:  <b>arch_rnd</b> (<var>a, b, t</var>)<var><a name="index-arch_005frnd-3251"></a></var><br>
<blockquote><p>Simulate an ARCH sequence of length <var>t</var> with AR
coefficients <var>b</var> and CH coefficients <var>a</var>.  I.e., the result
y(t) follows the model
<!-- Set example in small font to prevent overfull line -->

     <pre class="smallexample">          y(t) = b(1) + b(2) * y(t-1) + ... + b(lb) * y(t-lb+1) + e(t),
</pre>
        <p class="noindent">where e(t), given <var>y</var> up to time t-1, is
N(0, h(t)), with
<!-- Set example in small font to prevent overfull line -->

     <pre class="smallexample">          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(la) * e(t-la+1)^2
</pre>
        </blockquote></div>

<!-- arch_test scripts/signal/arch_test.m -->
   <p><a name="XREFarch_005ftest"></a>

<div class="defun">
&mdash; Function File: [<var>pval</var>, <var>lm</var>] = <b>arch_test</b> (<var>y, x, p</var>)<var><a name="index-arch_005ftest-3252"></a></var><br>
<blockquote><p>For a linear regression model

     <pre class="example">          y = x * b + e
</pre>
        <p class="noindent">perform a Lagrange Multiplier (LM) test of the null hypothesis of no
conditional heteroscedascity against the alternative of CH(<var>p</var>).

        <p>I.e., the model is

     <pre class="example">          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
</pre>
        <p class="noindent">given <var>y</var> up to t-1 and <var>x</var> up to t,
e(t) is N(0, h(t)) with

     <pre class="example">          h(t) = v + a(1) * e(t-1)^2 + ... + a(p) * e(t-p)^2,
</pre>
        <p class="noindent">and the null is a(1) == <small class="dots">...</small> == a(p) == 0.

        <p>If the second argument is a scalar integer, k, perform the same
test in a linear autoregression model of order k, i.e., with

     <pre class="example">          [1, y(t-1), ..., y(t-<var>k</var>)]
</pre>
        <p class="noindent">as the t-th row of <var>x</var>.

        <p>Under the null, LM approximately has a chisquare distribution with
<var>p</var> degrees of freedom and <var>pval</var> is the p-value (1
minus the CDF of this distribution at LM) of the test.

        <p>If no output argument is given, the p-value is displayed. 
</p></blockquote></div>

<!-- arma_rnd scripts/signal/arma_rnd.m -->
   <p><a name="XREFarma_005frnd"></a>

<div class="defun">
&mdash; Function File:  <b>arma_rnd</b> (<var>a, b, v, t, n</var>)<var><a name="index-arma_005frnd-3253"></a></var><br>
<blockquote><p>Return a simulation of the ARMA model

     <pre class="example">          x(n) = a(1) * x(n-1) + ... + a(k) * x(n-k)
               + e(n) + b(1) * e(n-1) + ... + b(l) * e(n-l)
</pre>
        <p class="noindent">in which <var>k</var> is the length of vector <var>a</var>, <var>l</var> is the
length of vector <var>b</var> and <var>e</var> is Gaussian white noise with
variance <var>v</var>.  The function returns a vector of length <var>t</var>.

        <p>The optional parameter <var>n</var> gives the number of dummy
<var>x</var>(<var>i</var>) used for initialization, i.e., a sequence of length
<var>t</var>+<var>n</var> is generated and <var>x</var>(<var>n</var>+1:<var>t</var>+<var>n</var>)
is returned.  If <var>n</var> is omitted, <var>n</var> = 100 is used. 
</p></blockquote></div>

<!-- autoreg_matrix scripts/signal/autoreg_matrix.m -->
   <p><a name="XREFautoreg_005fmatrix"></a>

<div class="defun">
&mdash; Function File:  <b>autoreg_matrix</b> (<var>y, k</var>)<var><a name="index-autoreg_005fmatrix-3254"></a></var><br>
<blockquote><p>Given a time series (vector) <var>y</var>, return a matrix with ones in the
first column and the first <var>k</var> lagged values of <var>y</var> in the
other columns.  I.e., for <var>t</var> &gt; <var>k</var>, <code>[1,
</code><var>y</var><code>(</code><var>t</var><code>-1), ..., </code><var>y</var><code>(</code><var>t</var><code>-</code><var>k</var><code>)]</code> is the t-th row
of the result.  The resulting matrix may be used as a regressor matrix
in autoregressions. 
</p></blockquote></div>

<!-- bartlett scripts/signal/bartlett.m -->
   <p><a name="XREFbartlett"></a>

<div class="defun">
&mdash; Function File:  <b>bartlett</b> (<var>m</var>)<var><a name="index-bartlett-3255"></a></var><br>
<blockquote><p>Return the filter coefficients of a Bartlett (triangular) window of
length <var>m</var>.

        <p>For a definition of the Bartlett window, see e.g., A. V. Oppenheim &amp;
R. W. Schafer, <cite>Discrete-Time Signal Processing</cite>. 
</p></blockquote></div>

<!-- blackman scripts/signal/blackman.m -->
   <p><a name="XREFblackman"></a>

<div class="defun">
&mdash; Function File:  <b>blackman</b> (<var>m</var>)<var><a name="index-blackman-3256"></a></var><br>
<blockquote><p>Return the filter coefficients of a Blackman window of length <var>m</var>.

        <p>For a definition of the Blackman window, see e.g., A. V. Oppenheim &amp;
R. W. Schafer, <cite>Discrete-Time Signal Processing</cite>. 
</p></blockquote></div>

<!-- diffpara scripts/signal/diffpara.m -->
   <p><a name="XREFdiffpara"></a>

<div class="defun">
&mdash; Function File: [<var>d</var>, <var>dd</var>] = <b>diffpara</b> (<var>x, a, b</var>)<var><a name="index-diffpara-3257"></a></var><br>
<blockquote><p>Return the estimator <var>d</var> for the differencing parameter of an
integrated time series.

        <p>The frequencies from [2*pi*a/t, 2*pi*b/T] are used for the
estimation.  If <var>b</var> is omitted, the interval
[2*pi/T, 2*pi*a/T] is used.  If both <var>b</var> and <var>a</var> are
omitted then a = 0.5 * sqrt (T) and b = 1.5 * sqrt (T)
is used, where T is the sample size.  If <var>x</var> is a matrix,
the differencing parameter of each column is estimated.

        <p>The estimators for all frequencies in the intervals
described above is returned in <var>dd</var>.  The value of <var>d</var> is
simply the mean of <var>dd</var>.

        <p>Reference: P.J. Brockwell &amp; R.A. Davis. <cite>Time Series:
Theory and Methods</cite>. Springer 1987. 
</p></blockquote></div>

<!-- durbinlevinson scripts/signal/durbinlevinson.m -->
   <p><a name="XREFdurbinlevinson"></a>

<div class="defun">
&mdash; Function File:  <b>durbinlevinson</b> (<var>c, oldphi, oldv</var>)<var><a name="index-durbinlevinson-3258"></a></var><br>
<blockquote><p>Perform one step of the Durbin-Levinson algorithm.

        <p>The vector <var>c</var> specifies the autocovariances <code>[gamma_0, ...,
gamma_t]</code> from lag 0 to <var>t</var>, <var>oldphi</var> specifies the
coefficients based on <var>c</var>(<var>t</var>-1) and <var>oldv</var> specifies the
corresponding error.

        <p>If <var>oldphi</var> and <var>oldv</var> are omitted, all steps from 1 to
<var>t</var> of the algorithm are performed. 
</p></blockquote></div>

<!-- fftshift scripts/signal/fftshift.m -->
   <p><a name="XREFfftshift"></a>

<div class="defun">
&mdash; Function File:  <b>fftshift</b> (<var>x</var>)<var><a name="index-fftshift-3259"></a></var><br>
&mdash; Function File:  <b>fftshift</b> (<var>x, dim</var>)<var><a name="index-fftshift-3260"></a></var><br>
<blockquote><p>Perform a shift of the vector <var>x</var>, for use with the <code>fft</code>
and <code>ifft</code> functions, in order the move the frequency 0 to the
center of the vector or matrix.

        <p>If <var>x</var> is a vector of N elements corresponding to N
time samples spaced by dt, then
<code>fftshift (fft (</code><var>x</var><code>))</code> corresponds to frequencies

     <pre class="example">          f = [ -(ceil((N-1)/2):-1:1)*df 0 (1:floor((N-1)/2))*df ]
</pre>
        <p class="noindent">where df = 1 / dt.

        <p>If <var>x</var> is a matrix, the same holds for rows and columns.  If
<var>x</var> is an array, then the same holds along each dimension.

        <p>The optional <var>dim</var> argument can be used to limit the dimension
along which the permutation occurs. 
</p></blockquote></div>

<!-- ifftshift scripts/signal/ifftshift.m -->
   <p><a name="XREFifftshift"></a>

<div class="defun">
&mdash; Function File:  <b>ifftshift</b> (<var>x</var>)<var><a name="index-ifftshift-3261"></a></var><br>
&mdash; Function File:  <b>ifftshift</b> (<var>x, dim</var>)<var><a name="index-ifftshift-3262"></a></var><br>
<blockquote><p>Undo the action of the <code>fftshift</code> function.  For even length
<var>x</var>, <code>fftshift</code> is its own inverse, but odd lengths differ
slightly. 
</p></blockquote></div>

<!-- fractdiff scripts/signal/fractdiff.m -->
   <p><a name="XREFfractdiff"></a>

<div class="defun">
&mdash; Function File:  <b>fractdiff</b> (<var>x, d</var>)<var><a name="index-fractdiff-3263"></a></var><br>
<blockquote><p>Compute the fractional differences (1-L)^d x where L
denotes the lag-operator and d is greater than -1. 
</p></blockquote></div>

<!-- hamming scripts/signal/hamming.m -->
   <p><a name="XREFhamming"></a>

<div class="defun">
&mdash; Function File:  <b>hamming</b> (<var>m</var>)<var><a name="index-hamming-3264"></a></var><br>
<blockquote><p>Return the filter coefficients of a Hamming window of length <var>m</var>.

        <p>For a definition of the Hamming window, see e.g., A. V. Oppenheim &amp;
R. W. Schafer, <cite>Discrete-Time Signal Processing</cite>. 
</p></blockquote></div>

<!-- hanning scripts/signal/hanning.m -->
   <p><a name="XREFhanning"></a>

<div class="defun">
&mdash; Function File:  <b>hanning</b> (<var>m</var>)<var><a name="index-hanning-3265"></a></var><br>
<blockquote><p>Return the filter coefficients of a Hanning window of length <var>m</var>.

        <p>For a definition of this window type, see e.g., A. V. Oppenheim &amp;
R. W. Schafer, <cite>Discrete-Time Signal Processing</cite>. 
</p></blockquote></div>

<!-- hurst scripts/signal/hurst.m -->
   <p><a name="XREFhurst"></a>

<div class="defun">
&mdash; Function File:  <b>hurst</b> (<var>x</var>)<var><a name="index-hurst-3266"></a></var><br>
<blockquote><p>Estimate the Hurst parameter of sample <var>x</var> via the rescaled range
statistic.  If <var>x</var> is a matrix, the parameter is estimated for
every single column. 
</p></blockquote></div>

<!-- pchip scripts/polynomial/pchip.m -->
   <p><a name="XREFpchip"></a>

<div class="defun">
&mdash; Function File: <var>pp</var> = <b>pchip</b> (<var>x, y</var>)<var><a name="index-pchip-3267"></a></var><br>
&mdash; Function File: <var>yi</var> = <b>pchip</b> (<var>x, y, xi</var>)<var><a name="index-pchip-3268"></a></var><br>
<blockquote><p>Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip) of
points <var>x</var> and <var>y</var>.

        <p>If called with two arguments, return the piecewise polynomial <var>pp</var>
that may be used with <code>ppval</code> to evaluate the polynomial at specific
points.  When called with a third input argument, <code>pchip</code> evaluates
the pchip polynomial at the points <var>xi</var>.  The third calling form is
equivalent to <code>ppval (pchip (</code><var>x</var><code>, </code><var>y</var><code>), </code><var>xi</var><code>)</code>.

        <p>The variable <var>x</var> must be a strictly monotonic vector (either
increasing or decreasing) of length <var>n</var>.  <var>y</var> can be either a
vector or array.  If <var>y</var> is a vector then it must be the same length
<var>n</var> as <var>x</var>.  If <var>y</var> is an array then the size of <var>y</var> must
have the form
<code>[</code><var>s1</var><code>, </code><var>s2</var><code>, ..., </code><var>sk</var><code>, </code><var>n</var><code>]</code>
The array is reshaped internally to a matrix where the leading
dimension is given by
<var>s1</var><code> * </code><var>s2</var><code> * ... * </code><var>sk</var>
and each row of this matrix is then treated separately.  Note that this
is exactly opposite to <code>interp1</code> but is done for <span class="sc">matlab</span>
compatibility.

     <p class="noindent"><strong>See also:</strong> <a href="XREFspline.html#XREFspline">spline</a>, <a href="XREFppval.html#XREFppval">ppval</a>, <a href="XREFmkpp.html#XREFmkpp">mkpp</a>, <a href="XREFunmkpp.html#XREFunmkpp">unmkpp</a>.

        </blockquote></div>

<!-- periodogram scripts/signal/periodogram.m -->
   <p><a name="XREFperiodogram"></a>

<div class="defun">
&mdash; Function File: [Pxx, <var>w</var>] = <b>periodogram</b> (<var>x</var>)<var><a name="index-periodogram-3269"></a></var><br>
<blockquote><p>For a data matrix <var>x</var> from a sample of size <var>n</var>, return the
periodogram.  The angular frequency is returned in <var>w</var>.

        <p>[Pxx,w] = periodogram (<var>x</var>).

        <p>[Pxx,w] = periodogram (<var>x</var>,win).

        <p>[Pxx,w] = periodogram (<var>x</var>,win,nfft).

        <p>[Pxx,f] = periodogram (<var>x</var>,win,nfft,Fs).

        <p>[Pxx,f] = periodogram (<var>x</var>,win,nfft,Fs,"range").

          <ul>
<li>x: data; if real-valued a one-sided spectrum is estimated,
if complex-valued or range indicates <code>"twosided"</code>, the full
spectrum is estimated.

          <li>win: weight data with window, x.*win is used for further computation,
if window is empty, a rectangular window is used.

          <li>nfft: number of frequency bins, default max (256, 2.^ceil (log2 (length (x)))).

          <li>Fs: sampling rate, default 1.

          <li>range: <code>"onesided"</code> computes spectrum from [0..nfft/2+1]. 
<code>"twosided"</code> computes spectrum from [0..nfft-1].  These
strings can appear at any position in the list input arguments after
window.

          <li>Pxx: one-, or two-sided power spectrum.

          <li>w: angular frequency [0..2*pi) (two-sided) or [0..pi] one-sided.

          <li>f: frequency [0..Fs) (two-sided) or [0..Fs/2] one-sided. 
</ul>
        </p></blockquote></div>

<!-- rectangle_lw scripts/signal/private/rectangle_lw.m -->
   <p><a name="XREFrectangle_005flw"></a>

<div class="defun">
&mdash; Function File:  <b>rectangle_lw</b> (<var>n, b</var>)<var><a name="index-rectangle_005flw-3270"></a></var><br>
<blockquote><p>Rectangular lag window.  Subfunction used for spectral density
estimation. 
</p></blockquote></div>

<!-- rectangle_sw scripts/signal/private/rectangle_sw.m -->
   <p><a name="XREFrectangle_005fsw"></a>

<div class="defun">
&mdash; Function File:  <b>rectangle_sw</b> (<var>n, b</var>)<var><a name="index-rectangle_005fsw-3271"></a></var><br>
<blockquote><p>Rectangular spectral window.  Subfunction used for spectral density
estimation. 
</p></blockquote></div>

<!-- sinetone scripts/signal/sinetone.m -->
   <p><a name="XREFsinetone"></a>

<div class="defun">
&mdash; Function File:  <b>sinetone</b> (<var>freq, rate, sec, ampl</var>)<var><a name="index-sinetone-3272"></a></var><br>
<blockquote><p>Return a sinetone of frequency <var>freq</var> with length of <var>sec</var>
seconds at sampling rate <var>rate</var> and with amplitude <var>ampl</var>. 
The arguments <var>freq</var> and <var>ampl</var> may be vectors of common size.

        <p>Defaults are <var>rate</var> = 8000, <var>sec</var> = 1 and <var>ampl</var> = 64. 
</p></blockquote></div>

<!-- sinewave scripts/signal/sinewave.m -->
   <p><a name="XREFsinewave"></a>

<div class="defun">
&mdash; Function File:  <b>sinewave</b> (<var>m, n, d</var>)<var><a name="index-sinewave-3273"></a></var><br>
<blockquote><p>Return an <var>m</var>-element vector with <var>i</var>-th element given by
<code>sin (2 * pi * (</code><var>i</var><code>+</code><var>d</var><code>-1) / </code><var>n</var><code>)</code>.

        <p>The default value for <var>d</var> is 0 and the default value for <var>n</var>
is <var>m</var>. 
</p></blockquote></div>

<!-- spectral_adf scripts/signal/spectral_adf.m -->
   <p><a name="XREFspectral_005fadf"></a>

<div class="defun">
&mdash; Function File:  <b>spectral_adf</b> (<var>c</var>)<var><a name="index-spectral_005fadf-3274"></a></var><br>
&mdash; Function File:  <b>spectral_adf</b> (<var>c, win</var>)<var><a name="index-spectral_005fadf-3275"></a></var><br>
&mdash; Function File:  <b>spectral_adf</b> (<var>c, win, b</var>)<var><a name="index-spectral_005fadf-3276"></a></var><br>
<blockquote><p>Return the spectral density estimator given a vector of
autocovariances <var>c</var>, window name <var>win</var>, and bandwidth,
<var>b</var>.

        <p>The window name, e.g., <code>"triangle"</code> or <code>"rectangle"</code> is
used to search for a function called <var>win</var><code>_lw</code>.

        <p>If <var>win</var> is omitted, the triangle window is used.  If <var>b</var> is
omitted, <code>1 / sqrt (length (</code><var>x</var><code>))</code> is used.

     <p class="noindent"><strong>See also:</strong> <a href="XREFspectral_005fxdf.html#XREFspectral_005fxdf">spectral_xdf</a>.

        </blockquote></div>

<!-- spectral_xdf scripts/signal/spectral_xdf.m -->
   <p><a name="XREFspectral_005fxdf"></a>

<div class="defun">
&mdash; Function File:  <b>spectral_xdf</b> (<var>x</var>)<var><a name="index-spectral_005fxdf-3277"></a></var><br>
&mdash; Function File:  <b>spectral_xdf</b> (<var>x, win</var>)<var><a name="index-spectral_005fxdf-3278"></a></var><br>
&mdash; Function File:  <b>spectral_xdf</b> (<var>x, win, b</var>)<var><a name="index-spectral_005fxdf-3279"></a></var><br>
<blockquote><p>Return the spectral density estimator given a data vector <var>x</var>,
window name <var>win</var>, and bandwidth, <var>b</var>.

        <p>The window name, e.g., <code>"triangle"</code> or <code>"rectangle"</code> is
used to search for a function called <var>win</var><code>_sw</code>.

        <p>If <var>win</var> is omitted, the triangle window is used.  If <var>b</var> is
omitted, <code>1 / sqrt (length (</code><var>x</var><code>))</code> is used.

     <p class="noindent"><strong>See also:</strong> <a href="XREFspectral_005fadf.html#XREFspectral_005fadf">spectral_adf</a>.

        </blockquote></div>

<!-- spencer scripts/signal/spencer.m -->
   <p><a name="XREFspencer"></a>

<div class="defun">
&mdash; Function File:  <b>spencer</b> (<var>x</var>)<var><a name="index-spencer-3280"></a></var><br>
<blockquote><p>Return Spencer's 15 point moving average of each column of
<var>x</var>. 
</p></blockquote></div>

<!-- stft scripts/signal/stft.m -->
   <p><a name="XREFstft"></a>

<div class="defun">
&mdash; Function File: [<var>y</var>, <var>c</var>] = <b>stft</b> (<var>x, win_size, inc, num_coef, win_type</var>)<var><a name="index-stft-3281"></a></var><br>
<blockquote><p>Compute the short-time Fourier transform of the vector <var>x</var> with
<var>num_coef</var> coefficients by applying a window of <var>win_size</var> data
points and an increment of <var>inc</var> points.

        <p>Before computing the Fourier transform, one of the following windows
is applied:

          <dl>
<dt>hanning<dd>win_type = 1

          <br><dt>hamming<dd>win_type = 2

          <br><dt>rectangle<dd>win_type = 3
</dl>

        <p>The window names can be passed as strings or by the <var>win_type</var> number.

        <p>If not all arguments are specified, the following defaults are used:
<var>win_size</var> = 80, <var>inc</var> = 24, <var>num_coef</var> = 64, and
<var>win_type</var> = 1.

        <p><var>y</var><code> = stft (</code><var>x</var><code>, ...)</code> returns the absolute values
of the Fourier coefficients according to the <var>num_coef</var> positive
frequencies.

        <p><code>[</code><var>y</var><code>, </code><var>c</var><code>] = stft (x, ...)</code> returns the
entire STFT-matrix <var>y</var> and a 3-element vector <var>c</var> containing
the window size, increment, and window type, which is needed by the
synthesis function. 
</p></blockquote></div>

<!-- synthesis scripts/signal/synthesis.m -->
   <p><a name="XREFsynthesis"></a>

<div class="defun">
&mdash; Function File:  <b>synthesis</b> (<var>y, c</var>)<var><a name="index-synthesis-3282"></a></var><br>
<blockquote><p>Compute a signal from its short-time Fourier transform <var>y</var> and a
3-element vector <var>c</var> specifying window size, increment, and
window type.

        <p>The values <var>y</var> and <var>c</var> can be derived by

     <pre class="example">          [<var>y</var>, <var>c</var>] = stft (<var>x</var> , ...)
</pre>
        </blockquote></div>

<!-- triangle_lw scripts/signal/private/triangle_lw.m -->
   <p><a name="XREFtriangle_005flw"></a>

<div class="defun">
&mdash; Function File:  <b>triangle_lw</b> (<var>n, b</var>)<var><a name="index-triangle_005flw-3283"></a></var><br>
<blockquote><p>Triangular lag window.  Subfunction used for spectral density
estimation. 
</p></blockquote></div>

<!-- triangle_sw scripts/signal/private/triangle_sw.m -->
   <p><a name="XREFtriangle_005fsw"></a>

<div class="defun">
&mdash; Function File:  <b>triangle_sw</b> (<var>n, b</var>)<var><a name="index-triangle_005fsw-3284"></a></var><br>
<blockquote><p>Triangular spectral window.  Subfunction used for spectral density
estimation. 
</p></blockquote></div>

<!-- yulewalker scripts/signal/yulewalker.m -->
   <p><a name="XREFyulewalker"></a>

<div class="defun">
&mdash; Function File: [<var>a</var>, <var>v</var>] = <b>yulewalker</b> (<var>c</var>)<var><a name="index-yulewalker-3285"></a></var><br>
<blockquote><p>Fit an AR (p)-model with Yule-Walker estimates given a vector <var>c</var>
of autocovariances <code>[gamma_0, ..., gamma_p]</code>.

        <p>Returns the AR coefficients, <var>a</var>, and the variance of white
noise, <var>v</var>. 
</p></blockquote></div>

<!-- DO NOT EDIT!  Generated automatically by munge-texi.pl. -->
<!-- Copyright (C) 1996-2012 John W. Eaton -->
<!-- This file is part of Octave. -->
<!-- Octave is free software; you can redistribute it and/or modify it -->
<!-- under the terms of the GNU General Public License as published by the -->
<!-- Free Software Foundation; either version 3 of the License, or (at -->
<!-- your option) any later version. -->
<!-- Octave is distributed in the hope that it will be useful, but WITHOUT -->
<!-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or -->
<!-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License -->
<!-- for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with Octave; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
   </body></html>

